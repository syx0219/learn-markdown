{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Main Page","text":""},{"location":"index.html#we-are-elecrow","title":"We Are Elecrow","text":"<p>Elecrow is devoted in open source hardware industry, which is located in a city that benefiting from the largest electronic market, local manufacture power and convenient global logistic system, a vast number of funny and exciting products are created every day. We integrate resources to serve new era of innovation. To make your making and innovation easier, we offer various development platform, modules, tools, electronics components,and other open source hardware. We also provide many kinds of service, include Fusion PCB service, Component Sourcing service and PCB Assembly service etc. No matter whether you're a curious student, a qualified engineer, or a hobbyist who loves to create, there will always be something here to meet your needs - and if there isn't ,we'd love to know. please list your wishes through the Forum or contact with us.</p>"},{"location":"index.html#getting-started","title":"Getting Started","text":"<ul> <li>Step1: Download Arduino IDE and install Arduino driver</li> <li>Step2: The very basic experiments with Crowduino</li> <li>Step3: How to Download the Arduino library and install</li> <li>Step4: Error Debugging</li> </ul>"},{"location":"index.html#products","title":"Products","text":""},{"location":"index.html#arduino","title":"Arduino","text":"<ul> <li>Crowduino</li> <li>Crowduino Uno-SD</li> <li>Crowduino M0- SD</li> <li>Crowduino Mega2560</li> <li>ESP8266 IOT Board(Arduino IDE or NodeMCU Lua Programming)</li> <li>32u4 with A7 GPRS/GSM</li> <li>32u4 with A9G GPRS/GSM/GPS</li> <li>Smart Pump ShieldScrew Shield</li> <li>Crowduino Leonardo</li> <li>Crowduino-Nano-V3.1</li> <li>Elecrow SIMduino UNO+SIM808 GPRS/GSM Board</li> <li>32u4 with A6 GPRS/GSM</li> <li>Leonardo GPRS/GSM IOT Board v1.1</li> <li>Nano 168(Arduino Compatible)</li> <li>Easy Module Shield for Arduino UNO</li> <li>IO Shield For Arduino Nano</li> <li>Arduino CNC Shield</li> <li>Larduino Mini</li> <li>Crowduino Pro Mini</li> <li>Elecrow ESPduino UNO+ESP8266 Wifi Board</li> <li>ESP32 WIFI/BLE Board v1.0</li> <li>32u4 with Lora RFM95 IOT Board-868MHz</li> <li>RFM69 Shield</li> <li>2.4 inch TFT Touch Shield for Arduino</li> <li>3.5 Inch TFT Color Screen Module 320 X 480 Support Arduino UNO Mega2560</li> <li>TEXT</li> </ul>"},{"location":"index.html#shield","title":"Shield","text":"<ul> <li>GPRS/GSM Shield v1.0</li> <li>Ehternet Shield</li> <li>WiFi Shield</li> <li>GPS shield</li> <li>2.8'' TFT Touch Shield</li> <li>Dual Channel H-Bridge Motor Shield</li> <li>Relay Shield</li> <li>CC3000 WiFi Shield</li> <li>USB Host Shield for Arduino</li> <li>Lipower Shield v1.1</li> <li>Mini solar Lipo Charger v1.0</li> <li>USB Hub&amp;Powermanager for RPI Zero v1.0</li> <li>Current/Voltage/Power Monitor HAT for Raspberry Pi</li> <li>Breakout Board for micro:bit IO Expansion Board</li> <li>Rainbow Shield</li> <li>Bluetooth Shield v1.0</li> <li>NFC Shield</li> <li>Motor Shield v1.0</li> <li>Wireless SDshield</li> <li>Motor&amp;Stepper Shield</li> <li>EM Shield</li> <li>CAN-BUS Shield</li> <li>Joystick Shield</li> <li>SIM5360E 3G Shield</li> <li>Speech Interaction board for Raspberry Pi</li> <li>Power over Internet(POE) Hat for Raspberry Pi</li> <li>Uninterruptible Power Supply UPS HAT For Raspberry Pi</li> <li>4 Channel I2C Motor Shield v1.1</li> <li>XBee shield</li> <li>LCD Keypad Shield</li> <li>Arduino Motor/Stepper/Servo Shield</li> <li>8-Channel EL Shield</li> <li>SIM808 GPRS/GSM+GPS Shield</li> <li>RTC Data Logger Shield v1.1</li> <li>Capacitive Touch Shield</li> <li>VS1053 MP3 Shield</li> <li>AVR ISP Shield</li> <li>Solderless Protoboard for raspberry pi v1.0</li> <li>IMX219-83 Stereo Camera</li> <li>Binocular Stereo Vision Expansion Board for Raspberry Pi</li> <li>Mbits</li> <li>Pico Shield</li> </ul>"},{"location":"index.html#crowtail","title":"Crowtail","text":"<ul> <li>Crowtail- Base Shield</li> <li>Crowtail- Linear Potentiometer</li> <li>Crowtail- Sound Sensor</li> <li>Crowtail- UV Sensor</li> <li>Crowtail- Thumb Joystick</li> <li>Crowtail- Button</li> <li>Crowtail- LED</li> <li>Crowtail- Buzzer</li> <li>Crowtail- Touch Sensor</li> <li>Crowtail- Tilt Switch</li> <li>Crowtail- I2C LCD</li> <li>Crowtail- Infrared Temperature Sensor</li> <li>Crowtail- Digital Light Sensor</li> <li>Crowtail- GPS</li> <li>Crowtail- One Wire Waterproof Temperature Sensor</li> <li>Crowtail- Dust Sensor</li> <li>Crowtail- Gas Sensor(MQ2)</li> <li>Crowtail- ES08A Mini Servo</li> <li>Crowtail- PIR Motion Sensor</li> <li>Crowtail- 3-Axis Digital Compass</li> <li>Crowtail- SIM808</li> <li>Crowtail- Microwave sensor</li> <li>Crowtail- Dry-Reed Relay</li> <li>Crowtail- Pulse Sensor</li> <li>Crowtail- Air Quality Sensor</li> <li>Crowtail- AM2302 Humidity&amp;Temperature Sensor</li> <li>Crowtail- Solid-State Relay</li> <li>Crowtail- I2C Motor Driver</li> <li>Crowtail- LED Bar</li> <li>Crowtail- Protoboard</li> <li>Crowtail- SPDT Relay</li> <li>Crowtail- Super Bright</li> <li>Crowtail-Rotation Angle Sensor</li> <li>Crowtail- Haptic Motor</li> <li>Crowtail- TPL5111 Reset Enable Timer</li> <li>Crowtail- MEMS Microphone</li> <li>Crowtail- LiPo Fuel Gauge</li> <li>Crowtail- Mini PIR Motion Sensor</li> <li>Crowtail- BMP280 Barometer Sensor</li> <li>Crowtail- Strain Gauge sensor</li> <li>Crowtail- VL53L0X Laser Ranging Sensor</li> <li>Crowtail-Digital-Programmable-Potentiometer</li> <li>Crowtail-Weight Sensor</li> <li>Crowtail- MPU6050 Accelerometer &amp; Gyro</li> <li>Crowtail- Vibration Motor</li> <li>Crowtail- Relay</li> <li>Crowtail- Moisture Sensor</li> <li>Crowtail- Light Sensor</li> <li>Crowtail- Hall Sensor</li> <li>Crowtail- Encoder</li> <li>Crowtail- IR Reflective Sensor</li> <li>Crowtail- Temperature&amp; Humidity Sensor</li> <li>Crowtail- Analog Gyro</li> <li>Crowtail- MOSFET</li> <li>Crowtail- Flame Sensor</li> <li>Crowtail- Rotary Angle Sensor</li> <li>Crowtail-Nano Base Board</li> <li>Crowtail- Fingerprint Sensor</li> <li>Crowtail- Gas Sensor(MQ5)</li> <li>Crowtail- Adjustable Infrared Sensor</li> <li>Crowtail- 3-Axis Digital Gyro</li> <li>Crowtail- Gas Sensor(MQ9)</li> <li>Crowtail- I2C Color Sensor</li> <li>Crowtail- Collision Sensor</li> <li>Crowtail- 9G Servo</li> <li>Crowtail- Magnetic Switch</li> <li>Crowtail- Electromagnet</li> <li>Crowtail- Vibration Sensor</li> <li>Crowtail- Analog Grayscale Sensor</li> <li>Crowtail- Switch</li> <li>Crowtail- I2C EEPROM</li> <li>Crowtail- Recorder</li> <li>Crowtail- Speaker</li> <li>Crowtail- MP3</li> <li>Crowtail- Screw Terminal</li> <li>Crowtail- I2C Hub</li> <li>Crowtail- UV sensor(GUVA- S12SD) 2.0</li> <li>Crowtail- PH SensorCrowtail- NFC</li> <li>Crowtail- Logic Block</li> <li>Crowtail- 1.3 Inch OLED v1.0</li> <li>Crowtail- CurrentPower Sensor</li> <li>Crowtail-LED Matrix</li> <li>Crowtail- DHT20Crowtail- IMU 10DOF</li> <li>Crowtail- HTU21D Humidity&amp; Temperature Sensor</li> <li>Crowtail-Knock Sensor</li> <li>Crowtail-GP02</li> <li>Crowtail- BMP180 Barometer</li> <li>Crowtail- Blutooth Low Energy Module</li> <li>Crowtail- Thermistor Temperaturen Sensor</li> <li>Crowtail- RTC</li> <li>Crowtail- Serial Wifi</li> <li>Crowtail- IR Emitter</li> <li>Crowtail- IR Receiver</li> <li>Crowtail- Current Sensor</li> <li>Crowtail- RGB-LED</li> <li>Crowtail- OLED</li> <li>Crowtail- Gas Sensor(MQ3)</li> <li>Crowtail- Water Sensor</li> <li>Crowtail- 3-Axis Digital Accelerometer</li> <li>Crowtail- Laser Pointer</li> <li>Crowtail- Ultrasonic Ranging Sensor</li> <li>Crowtail- 80cm Infrared Proximity Sensor</li> <li>Crowtail- 4-Digit Display</li> <li>Crowtail- Current Sensor Kit</li> <li>Crowtail- Extend board for Connection</li> <li>Crowtail- Photo Electric Counter</li> <li>Crowtail- Electricity Sensor</li> <li>Crowtail- Voltage Sensor</li> <li>Crowtail- thermocouple Sensor</li> <li>Crowtail- Gesture</li> <li>Crowtail- G\u00bc\" Water Flow Sensor</li> <li>Crowtail- G\u00bd\" Water Flow Sensor</li> <li>Crowtail- G\u00be\" Water Flow Sensor</li> <li>Crowtail- G1\" Water Flow Sensor</li> <li>Crowtail- Non-contact liquid level sensor</li> <li>Crowtail- Serial Camera</li> <li>Crowtail- Luminance sensor</li> <li>Crowtail- Dual Channel Latching Module</li> <li>Crowtail- Temperature Sensor TMP102</li> <li>Crowtail- 315Mhz RF Receiver with Transmitter</li> <li>Crowtail- MAX30105 Particle Sensor</li> <li>Crowtail-Rotation Angle Sensor</li> <li>Crowtail-Capacitive Moisture V2.0</li> <li>Crowtail- Stackable Shield for Raspberry Pi 2.0</li> <li>Crowtail- Motor Base Shield</li> <li>Crowtail- A6 GPRS/GSM Module</li> <li>Crowtail- WIFI Module</li> <li>Crowtail- LoRa RA-08H</li> <li>Crowtail- DWM1000 UWB(Ultra Wide Band)</li> <li>Crowtail- 4G SIM-A7670E</li> </ul>"},{"location":"index.html#crowbits","title":"Crowbits","text":"<ul> <li>Crowbits-LED (Red Green Yellow)</li> <li>Crowbits-Buzzer</li> <li>Crowbits-Relay</li> <li>Crowbits-Bright LED</li> <li>Crowbits-Vibration Motor</li> <li>Crowbits-Electromagnet</li> <li>Crowbits-DC Motor</li> <li>Crowbits-MOSFET</li> <li>Crowbits-MP3</li> <li>Crowbits-Recorder</li> <li>Crowbits-TPL5111 Timer</li> <li>Crowbits-Vibration Sensor</li> <li>Crowbits-Magnetic Switch</li> <li>Crowbits-Water Sensor</li> <li>Crowbits-Reaction</li> <li>Crowbits-Touch Sensor</li> <li>Crowbits-PIR Sensor</li> <li>Crowbits-Tilt Switch</li> <li>Crowbits-Button</li> <li>Crowbits-Switch</li> <li>Crowbits-Flame Sensor</li> <li>Crowbits-Collision Sensor</li> <li>Crowbits-IR Reflective Sensor</li> <li>Crowbits-Photo Electric Counter</li> <li>Crowbits-Hall Sensor</li> <li>Crowbits-Microphone</li> <li>Crowbits-Potentiometer</li> <li>Crowbits-Light Sensor</li> <li>Crowbits-Pressure Sensor</li> <li>Crowbits-Servo Control</li> <li>Crowbits-Linear Potentiometer</li> <li>Crowbits-Terminal</li> <li>Crowbits-315Mhz Emitter</li> <li>Crowbits-Expansion</li> <li>Crowbits-Protoboard</li> <li>Crowbits-Power Supply(S)</li> <li>Crowbits-Power Supply</li> <li>Crowbits-Trigger Delay</li> <li>Crowbits-Logic AND</li> <li>Crowbits-Logic OR</li> <li>Crowbits-Logic NOT</li> <li>Crowbits-Logic Input</li> <li>Crowbits-315MHz Controller</li> <li>Crowbits-IR Emitter</li> <li>Crowbits-RGB LED</li> <li>Crowbits-LED Bar</li> <li>Crowbits-315Mhz Receiver</li> <li>Crowbits-IR Receiver</li> <li>Crowbits-DHT11 Sensor</li> <li>Crowbits-Gas Sensor</li> <li>Crowbits-Encoder</li> <li>Crowbits-Pulse Sensor</li> <li>Crowbits-Air Quality Sensor</li> <li>Crowbits-Grayscale Sensor</li> <li>Crowbits-UV Sensor</li> <li>Crowbits-Ultrasonic Ranging Sensor</li> <li>Crowbits-Thumb Joystick</li> <li>Crowbits-Digital Potentiometer</li> <li>Crowbits-Keyboard</li> <li>Crowbits-Voltage Sensor</li> <li>Crowbits-CurrentPower Sensor</li> <li>Crowbits-IR Temperature Sensor</li> <li>Crowbits-NFC</li> <li>Crowbits-Barometer Sensor</li> <li>Crowbits-Digital Light Sensor</li> <li>Crowbits-LED Matrix</li> <li>Crowbits-RGB Matrix</li> <li>Crowbits-HTU21D Humiture Sensor</li> <li>Crowbits-Laser Ranging Sensor</li> <li>Crowbits-Color Sensor</li> <li>Crowbits-RTC</li> <li>Crowbits-Gesture Sensor</li> <li>Crowbits-OLED</li> <li>Crowbits-EEPROM</li> <li>Crowbits-Digital Display</li> <li>Crowbits-WiFi</li> <li>Crowbits-GPS</li> <li>Crowbits-2G Module</li> <li>Crowbits-Microbit Compatible</li> <li>Crowbits-UNO</li> <li>Crowbits-80cm Infrared Proximity Sensor</li> <li>Crowbits-Adjustable Infrared Sensor</li> <li>Crowbits-9G Servo</li> <li>Crowbits-G1-4 Water Flow Sensor</li> <li>Crowbits-Non-Contact Liquid Level Sensor</li> <li>Crowbits-One Wire Waterproof Temperature Sensor</li> <li>Crowbits-Moisture Sensor</li> <li>Crowbits-DHT20</li> </ul>"},{"location":"index.html#sensors","title":"Sensors","text":"<ul> <li>Temperature &amp; Humidity Sensor</li> <li>PIR Motion Sensor</li> <li>Tiny RTC</li> <li>Adjustable Infrared Sensor Switch</li> <li>Triple Axis Magnetometer Breakout</li> <li>Ultrasonic Ranging Sensor Module</li> <li>ACS712 Current Sensor- 5A</li> <li>1-Axis Analog Gyro Module-ENC03</li> <li>2-Axis Analog Gyro Module-ENC03</li> <li>Strain Gauge Module</li> <li>4MM Inductive Metal Proximity Sensor</li> <li>Fingerprint Sensor</li> <li>Infrared Thermometer MLX90614 Breakout Board</li> <li>Luminosity Sensor- TSL2561 Breakout</li> <li>HC-SR505 Mini PIR Motion Sensor</li> <li>Digital light Sensor</li> <li>Photosensor- Short Range</li> <li>Photosensor- Long Range</li> <li>One Wire Waterproof Temperature Sensor</li> <li>Accelerometer Breakout-MMA7361</li> <li>MPU-6050</li> <li>3-Axis Analog Gyro Module-ENC03</li> <li>Weight Sensor Scales Kit- 20KG</li> <li>Non-invasive AC Current Sensor-100A</li> <li>TCS3200 Colour Sensor Module</li> <li>Analog CO/Combustible Gas Sensor(MQ9)</li> <li>UV Sensor ML8511</li> <li>Barometer Sensor</li> <li>IMU 10DOF LSM303D+L3GD20 +BMP180</li> <li>Encoder Gear Motor-25MM 95RPM</li> <li>Weight Sensor Amplifier-HX711</li> <li>DHT11</li> <li>Tiny Adjustable Infrared Sensor Switch</li> <li>Serial JPG Camera</li> <li>Dust Sensor- DSM501A</li> <li>Dust Sensor- GP2Y1010AU0F</li> <li>Pulse Sensor</li> <li>Sound Recorder- ISD1760</li> <li>80cm Infrared Proximity Sensor-GP2Y0A21YK0F</li> <li>Analog Smoke/LPG/CO Gas Sensor(MQ2)</li> <li>G\u00bc\" Water Flow Sensor</li> <li>ENC28J60 Ethernet Module</li> <li>UV Sensor Module-UVM30A</li> <li>APM2.5 Airspeed Breakout Board MPXV7002DP</li> <li>Soil Moisture Sensor</li> <li>Rectangle capacitive fingerprint scanner breathing light fingerprint AS608 sensor</li> <li>1019DRound fingerprint recognition sensor module ID809</li> </ul>"},{"location":"index.html#wireless","title":"Wireless","text":"<ul> <li>315/433Mhz RF Link Kit</li> <li>NRF24L01+PA+LNA Wireless Module</li> <li>Smart car with ESP32-CAM Board</li> <li>2.4G Wireless nRF24L01</li> <li>Serial Port Bluetooth Module</li> <li>Wireless Charger&amp; Receiver</li> <li>433MHz RF Transceiver CC1101 Module</li> <li>Serial WIFI Transceiver Module ESP8266</li> <li>ESP32S WIFI BLE Board</li> <li>CrowBot-BOLT Programmable Smart Robot Car STEAM Robot Kit</li> </ul>"},{"location":"index.html#display","title":"Display","text":"<ul> <li>0.96\" OLED 128x64- Blue</li> <li>I2C 0.96\" OLED 128x64- Blue</li> <li>1.44'' 128x 128 TFT LCD with SPI Interface</li> <li>3.5 Inch 480x320 TFT Display with Touch Screen for Raspberry Pi</li> <li>3.95 Inch TFT Display for Raspberry Pi</li> <li>RC070M 7 inch 1024 X 600 Touch Screen Display with 720P Camera for Raspberry Pi/ MacBook Pro./ Windows 10</li> <li>RR070 7 Inch 1024x600 HDMI/VGA/AV Display for Raspberry Pi B/B+/2B/3B</li> <li>SF101C 10.1 inch 1280*800 IPS HDMI LCD Display(with case) for Raspberry Pi</li> <li>SF116 11.6 Inch 1920x1080 HDMI 1080P LED Display for Raspberry Pi</li> <li>2.9 inch e-Paper Module Three Color-Red Black White</li> <li>1.3 inch IPS TFT LCD Display ST7789</li> <li>Elecrow 10.1 inch Display IPS 1280x800 Acrylic Case Touch Screen Compatible with Raspberry Pi Jetson Nano PC</li> <li>5.0 Inch HDMI-Compatible Display for Raspberry Pi Compatible with Jetson Nano, Beaglebone</li> <li>I2C LCD2004(Yellow)</li> <li>I2C LCD1602(Blue)</li> <li>WS2812 RGB LED Ring</li> <li>HDMI Interface 5 Inch 800x480 TFT Display</li> <li>4 Inch HD 480x320 TFT Display with Touch Screen for Rapberry Pi</li> <li>RC050 5 inch HDMI 800 x 480 Capacitive Touch LCD Display for Raspberry Pi/ PC/ SONY PS4</li> <li>ELECROW 11.6 Inch 1080P IPS 1920x1080 Monitor with Built-in Speaker for Raspberry Pi PS4 XBOX Windows without touch function</li> <li>ELECROW 11.6 Inch 1080P IPS 1920x1080 Monitor with Built-in Speaker for Raspberry Pi PS4 XBOX Windows with touch function</li> <li>SF101 10.1 Inch 1920x1080 Display HDMI VGA IPS PS3 PS4 Gaming Screen</li> <li>SF101R 10.1 Inch Portable HD Display for Raspberry Pi 3</li> <li>SF133 13.3 Inch IPS 1920X1080 Monitor Dual HDMI PortablePS3 PS4 Gaming Screen</li> <li>3.5inch 480x320 MCU SPI Serial TFT LCD Module Display</li> <li>Meteor Screen 10.1\" IPS Touch Screen (with RGB Animated light))</li> <li>2.8'' TFT Touch Shield </li> <li>1602 LCD Display Module</li> <li>16x16 LED Display Module</li> <li>7 Inch 1024*600 HDMI LCD Display with Touch Screen</li> <li>7 Inch 1024x600 TFT Display for Raspberry Pi B+ Pcduino Banana Pi</li> <li>Elecrow RR040I 4 inch HD 800x480 Resolution IPS TFT Touch Screen Display for Raspberry Pi</li> <li>7 Inch TFT Display for Raspberry Pi B+ Banana Pi BB BLACK</li> <li>SF133M 13.3 inch 1920 x 1080 HDMI Portable Display for Raspberry Pi/ PS4/ XBOX/ NS</li> <li>RR040I 4 inch HD 800x480 Resolution IPS TFT Touch Screen Display for Raspberry Pi</li> <li>GC1016 10.1\" TFT-LCD Monitor 1280*800 Color Screen with AV1 VGA HDMI BNC USB Input Built-in Speaker</li> <li>2 inch IPS Module</li> <li>Elecrow 10.1 Inch Touchscreen 1280x800 IPS TFT LCD Monitor Kit</li> </ul>"},{"location":"index.html#hmi-display","title":"HMI Display","text":"<ul> <li>Wizee HMI touch display</li> </ul>"},{"location":"index.html#crowvision","title":"CrowVision","text":"<ul> <li>CrowVision 11.6'' Capacitive Touch Screen Portable HD 1366*768 IPS LCD Display</li> <li>CrowVision 7.0\" Touch Screen Capacitive Portable HDMI-compatible 1024*600 IPS LCD Monitor</li> </ul>"},{"location":"index.html#mechanical-keyboard","title":"Mechanical Keyboard","text":"<ul> <li>Mechanical_Keyboard_ESP32-S3 </li> </ul>"},{"location":"index.html#elecrow-services","title":"Elecrow Services","text":"<ul> <li>PCB Fabricate Service Overview</li> <li>Q&amp;A for PCB service</li> <li>Export gerber files from Eagle</li> <li>Export gerber files from Proteus_ARES</li> </ul>"},{"location":"index.html#modules-for-prototyping","title":"Modules for Prototyping","text":"<ul> <li>Breadboard Power Supply</li> <li>ULN2003 Stepper Motor Driver</li> <li>Lipo Charger v1.0</li> <li>LED matrix kit</li> <li>1602 LCD Display Module</li> <li>RTD2556 Driver Board/Controller Board Kit</li> <li>devDuino Sensor Node V1.3 (ATmega 328)</li> <li>Adjustable Integrated DC-DC Module- LM2596S</li> </ul>"},{"location":"index.html#accessories","title":"Accessories","text":"<ul> <li>Transparent Acrylic Switches Tester Collection</li> </ul>"},{"location":"index.html#application-kits","title":"Application Kits","text":"<ul> <li>Crazepony MINI Quadcopter </li> </ul>"},{"location":"index.html#elecrow-cooperatorpartner","title":"Elecrow Cooperator/Partner","text":"<ul> <li>Cooperator Designer</li> <li>Drop Shipping</li> <li>Products Wiki</li> </ul>"},{"location":"index.html#raspberry-pi","title":"Raspberry Pi","text":"<ul> <li>CrowPi</li> <li>CrowPi-2</li> <li>CrowPi-L</li> </ul>"},{"location":"index.html#arduino-kit","title":"Arduino Kit","text":"<ul> <li>GrowCube </li> </ul>"},{"location":"index.html#esp-terminal-esp32-display","title":"ESP Terminal&amp; ESP32 Display","text":"<ul> <li>ESP Terminal with 3.5inch RGB Capacitive Touch Display</li> <li>ESP Terminal with 3.5inch SPI Capacitive Touch Display</li> <li>ESP32 Display 2.4'' Intelligent Touch Screen Wi-Fi&amp;BLE 240*320 HMI Display</li> <li>ESP32 Display 2.8'' Intelligent Touch Screen Wi-Fi&amp;BLE 240*320 HMI Display</li> <li>ESP32 Display 3.5'' Intelligent Touch Screen Wi-Fi&amp;BLE 320*480 HMI Display</li> <li>ESP32 Display 4.3'' Intelligent Touch Screen Wi-Fi&amp;BLE 480*272 HMI Display</li> <li>ESP32 Display 5.0'' Intelligent Touch Screen Wi-Fi&amp;BLE 800*480 HMI Display</li> <li>ESP32 Display 7.0'' Intelligent Touch Screen Wi-Fi&amp;BLE 800*480 HMI Display</li> </ul>"},{"location":"index.html#lora","title":"Lora","text":"<ul> <li>Lora RA-08H Development Board</li> <li>Lora RA-08H Node Board</li> <li>Lora Basic Gateway Module</li> <li>LR1302 LoRaWAN Gateway Module</li> <li>LR1302 LoRaWAN HAT for RPI_PRD</li> <li>LR1262 LoRaWAN Node Module</li> </ul>"},{"location":"index.html#tutorials","title":"Tutorials","text":"<p>LVGL ESP32 Display Tutorial-A Step-by-Step Guide to LVGL GUI Development</p>"},{"location":"Crowduino_v1.0.html","title":"Crowduino_v1.0","text":""},{"location":"Crowduino_v1.0.html#description","title":"Description","text":"<p>We sale Crowduio V1.1 now, it is almost the same as Crowduino V1.0. it added wireless programming function using 2 XBee module. please visit Crowduino V1.1 wiki for more details.</p> <p>The Crowduino is Arduino compatible board. Based on arduino Duemilanuve Schematic, 100% compatible to its existing program, shield and IDEs.</p> <p>it is a microcontroller board based on the ATmega328 (datasheet). It has 14 digital input/output pins (of which 6 can be used as PWM outputs), 6 analog inputs, a 16 MHz ceramic resonator, a USB connection, a power jack, an ICSP header, a reset button, and a XBee socket. It contains everything needed to support the microcontroller; simply connect it to a computer with a USB cable or power it with a AC-to-DC adapter or battery to get started.</p> <p>Crowduino differs from all preceding boards in that it contains Shield and XBee socket . it adapts to all the shield that compatible with arduino Uno. it also adapts to the Xbee modules from Digi,and any module with the same footprint.</p> <p>Model MCA01328A</p> <p></p>"},{"location":"Crowduino_v1.0.html#summary","title":"Summary","text":"Microcontroller ATmega328 Operating Voltage 5v Input Voltage (recommended) 7-12V Digital I/O Pins 14 (of which 6PINs provide PWM output) Analog Input Pins 8 DC Current per I/O Pin 40mA DC Current for 3.3V Pin 50 mA Flash Memory 32 KB (ATmega328) of which 0.5 KB used by bootloader SRAM 2 KB (ATmega328) EEPROM 1 KB (ATmega328) Clock Speed 16 MHz"},{"location":"Crowduino_v1.0.html#features","title":"Features","text":"<ul> <li>It contains Bee Shield that you can wireless communicate to the microcontroller</li> <li>Flat DC Jack.</li> <li>Inherits all of Arduino Duemilanuve's features.</li> <li>Compatible to Uno's pin layout, screw hole and dimensions.</li> <li>Evolved with SMD components.</li> </ul>"},{"location":"Crowduino_v1.0.html#interface-function","title":"Interface Function","text":""},{"location":"Crowduino_v1.0.html#usage","title":"Usage","text":"<p>Except 100% compatible with Arduino,Crowduino has another funtion that it also adapts to the Xbee modules from Digi,and other Bee module with the same footprint.</p>"},{"location":"Crowduino_v1.0.html#faq","title":"FAQ","text":"<p>There are a number of switches that I am unsure of the function of, not having seen them on another Arduino board:</p> <p>***Q:****3V3_VCC_5V: Does this convert the entire board to output 3V3 or 5V, or is it input voltage?*</p> <p>**A:**This is the input voltage choice switch. If you push the switch to 3v3, and set the output pin to high, the votage of it is 3v3. If you push the switch to 5v, and set the output pin to high, the votage of it is 5v.</p> <p>Q*:What does the \"serial select\" switch do?*</p> <p>**A:**This switch is to choose Rx, Tx PIN of XBee connect to RX, TX of atmega328 or RX, TX of XBee connect to TX, RX pin of atmega328. The theory is that if you connect the RX pin of XBee to TX pin of atmega328, The Xbee or XBee compatible Bee can communicate with atmega328 through Serial port. if you connect the RX pin of XBee to the RX pin of atmega328, the RX pin of XBee will connect to the TX of FTDI, the XBee can commucate with you computer through Serial port.</p>"},{"location":"Crowduino_v1.0.html#resources","title":"Resources","text":"<ul> <li>Crowduino Schematic in PDF</li> <li>Crowduino eagle files</li> </ul>"},{"location":"Crowduino_v1.0.html#how-to-buy","title":"How to buy","text":"<p>Please visit this page to purchase Crowduino.</p>"},{"location":"Crowduino_v1.0.html#support","title":"Support","text":"<p>If you have any problem about how to use it, you can connect to us at the bottom-right of bazzer or contact to techsupport@elecrow.com to get technology support.</p>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html","title":"Crazepony MINI Quadcopter","text":""},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#description","title":"Description","text":"<p>Crazepony MINI is an ultra-compact quadcopter kit that fits the size of your palm. It is remote controllable by smart phone or tablet through bluetooth. It is open sourced. It is designed for those who are interested in learning, experimenting and coaching how to develop your very own drone. let's begin our flying dream.</p> <p>Model:AKA04020A</p> <p></p>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#specifications-of-the-crazepony-mini-quadcopter-body","title":"Specifications of the Crazepony MINI Quadcopter Body","text":"<ul> <li>Sized 100mm * 100mm (wheelbase 140mm with 75mm propeller), ultra-compact as its name suggests</li> <li>Light weight: 46g (incl. battery)</li> <li>Up to 6 minutes when fully charged (with standard 650mAh Li-Po rechargeable battery)</li> <li>Charge time about 40min to 100% with Standard Micro USB connector on a 2A adapter</li> <li>On-board low-energy radio based on the nRF24L01+ chip</li> <li>Powerful 32 bit MCU: STM32F103T8U6 72 MHz (64Kbs flash, 20kb RAM)</li> <li>3-axis high-performance MEMs gyros with 3-axis accelerometer: Invensense MPU-6050</li> <li>High precision altimeter MS5611-01BA03</li> <li>Extended reservation position for compass HMC5883L</li> <li>With common USB to UART bridge CP2102,micro USB connector to download and debug firmware</li> <li>Bluetooth 4.0 LE wireless connection (with TI CC2541 chip) to enable remote control by smartphone or tablet</li> </ul>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#specifications-of-the-crazepony-mini-remote-controller","title":"Specifications of the Crazepony MINI Remote Controller","text":"<ul> <li>Powerful 32 bit MCU: STM32F103T8U6 72 MHz (64Kbs flash, 20kb RAM).</li> <li>Pluggable nRF24L01+ dongle for 20m range,up to 100m with power amplifier(PA) and SMA antenna.</li> <li>With common USB to UART bridge CP2102,micro USB connector to download and debug firmware.</li> </ul>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#user-guide","title":"User Guide","text":"<p>1.Place the Crazepony on a stable ground.The Arrow on the center of the PCB indicate the front. </p> <p>2.Firstly switch on the Crazepony RC, then quadcopter.About 10s later, blue LEDs on M1/M2 flashing,IMU is calibrated. </p> <p>3.Press the \"-\" button on RC to start IMU calibration.Press the \"+\" button on RC to start the motors. </p> <p>4.Push the throttle on the left joystick to take off.Press the \"+\" button again to stop motors after landing. </p>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#resources","title":"Resources","text":""},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#source-code-firmware","title":"Source Code &amp; Firmware","text":"<p>1.Flight Control Source Code</p> <ul> <li>Crazepony 5.2 Bluetooth 4.0 LE version flight control firmware.</li> <li>Search the 2.4G remote control connected last time first when power on</li> <li>Support the Bluetooth LE connection by smartphone(Bluetooth 2.1 not supported now)</li> <li>Communication with PC assistant is closed by default</li> </ul> <p>Download:</p> <ul> <li>Crazepony-5.2-ble-fc-0929-6f07e60.hex</li> <li>crazepony-firmware-none-5.2-ble.zip</li> </ul> <p>2.Remote Control Source Code</p> <p>Crazepony 5.2 Bluetooth 4.0 LE version remote control firmware.</p> <ul> <li>Generate a rand 2.4G address for the remote control</li> <li>Press 'Mode' button to 2.4G address</li> </ul> <p>Download:</p> <ul> <li>Remote Control Source Code</li> </ul>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#schematic-datasheet","title":"Schematic &amp; Datasheet","text":"<ul> <li>Schematic</li> <li>Datasheet</li> </ul>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#android-client-pc-gui","title":"Android Client &amp; PC GUI","text":"<ul> <li>Android APP APK File</li> <li>Crazepony GUI</li> </ul>"},{"location":"Products/Application-Kits/crazepony-mini-quadcopter.html#external-links","title":"External links","text":"<ul> <li>Related Data Download</li> <li>Crazepony Official Website</li> <li>Users Manual</li> </ul>"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html","title":"2.4 inch TFT Touch Shield for Arduino","text":""},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#description","title":"Description","text":"<p>The 2.4 inch TFT Touch Screen Module with micro SD card slot is now available as a SHIELD for Arduino UNO. It has a four wire resistive touch screen, a micro SD card socket, a reset switch and a convenient Arduino Uno shield footprint. Model: ACS44240D </p> <p> </p>"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#features","title":"Features","text":"<ul> <li>Colorful, 18-bit 262,000 different shades</li> <li>Bright, 4 white LED backlight. On by default but you can connect the transistor to a digital pin for backlight control</li> <li>Works with any Arduino 328 or Mega (Leonardo not supported yet)</li> <li>Onboard 3.3V 300mA LDO regulator</li> <li>4-wire resistive touchscreen</li> <li>Uses digital pins 5-13 and analog 0-3. That means you can use digital pins 2, 3 and analog 4 and 5. Pin 12 is available if not using the micro SD</li> </ul>"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#specification","title":"Specification","text":"Item Value Display Color RGB 65K color Screen Size 2.4(inch) Type TFT Driver IC ILI9341 Resolution 320*240(Pixel) Module Interface 8-bit parallel interface Active Area 48.96*36.72(mm) Module PCB Size 72.20*52.7(mm) Operating Temperature -20\u2103~60\u2103 Storage Temperature -30\u2103~70\u2103 Operating Voltage 5V/3.3V Power Consumption TBD Product Weight(Package containing) 39(g)"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#pin-layout","title":"Pin Layout","text":"No. Pin Label Pin Description 1 LCD_RST LCD bus reset signal, low level reset 2 LCD_CS LCD bus chip select signal, low level enable 3 LCD_RS LCD bus command / data selection signal, low level:command, high level:data 4 LCD_WR LCD bus write signal 5 LCD_RD LCD bus read signal 6 GND Power ground 7 5V 5V power input 8 3V3 3.3V power input, this pin can be disconnected 9 LCD_D0 LCD 8-bit data Bit0 10 LCD_D1 LCD 8-bit data Bit1 11 LCD_D2 LCD 8-bit data Bit2 12 LCD_D3 LCD8-bit data Bit3 13 LCD_D4 LCD 8-bit data Bit4 14 LCD_D5 LCD 8-bit data Bit5 15 LCD_D6 LCD 8-bit data Bit6 16 LCD_D7 LCD 8-bit data Bit7 17 SD_SS SD card SPI bus chip select signal, low level enable 18 SD_DI SD card SPI bus MOSI signal 19 SD_DO SD card SPI bus MISO signal 20 SD_SCK SD card SPI bus clock signal"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#platforms-supported","title":"Platforms Supported","text":"Arduino"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#usage","title":"Usage","text":""},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#hardware","title":"Hardware","text":"<p>STEP1 Prepare the below stuffs:</p> Crowduino Uno 2.4 inch TFT Touch Shield for Arduino Get one now Get one now <p>STEP2 Plug 2.4 inch TFT Touch Shield into Crowduino Uno;   STEP3 Connect Crowduino Uno to PC via a Mini USB cable.  </p>"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#software","title":"Software","text":"<p>STEP 1 Download filesArduino_Demo_code_ArduinoUNO%26Mega2560.zip STEP 2 Configure controller board&amp;communication port  On top of the Arduino IDE, click \u201cTools&gt;Board&gt;\u201d and select \u201cArduino Uno\u201dfrom the available options  Select the COM port that indicates Arduino Uno. Please note that the actual numbers after the \u201cCOM\u201d word will vary from computer to computer, so they could be different from the ones shown in the figure. </p> <p>STEP 3 Install Library: Unzip the Arduino Demo code_ArduinoUNO&amp;Mega2560.zip file. Copy the dependent libraries in the Install libraries directory in the package (shown below) to the Libraries directory under the Arduino installation directory </p> <p>STEP 4 Open the sample program in the Example directory of the package to test  </p> <p>STEP 5 Click the  to upload the code to the Crowduino board  </p> <p>STEP6 After the program is downloaded, run it directly and observe the running status. If it can be displayed normally, the program runs successfully </p>"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#faqs","title":"FAQS","text":"<p>You can list you question here or contact with techsupport@elecrow.com for technology support.</p>"},{"location":"Products/Arduino/24-inch-tft-touch-shield-for-arduino.html#resources","title":"Resources","text":"<p>Arduino_Demo_code_ArduinoUNO&amp;Mega2560.zip ILI9341_Datasheet.pdf Schematic </p>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html","title":"32u4 with A6 GPRS/GSM","text":""},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#introduction","title":"Introduction","text":"<p>The 32U4 with A6 GSM/GPRS Board is based on mega32U4 and A6 GSM/GPRS module. It can be used to call and seed text messages, via GPRS to upload data to server. At the same time it leads to an analog interface, an IIC interface and 2 digital interface. which you can connect to other module more easily.</p> <p>Model: (Discontinued) </p>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#features","title":"Features","text":"<ul> <li>32U4+A6</li> <li>Work voltage: 5V</li> <li>Operating temperature -30 \u2103 to + 80 \u2103;</li> <li>Three kinds of interface</li> <li>3.7V Battery power supply</li> <li>Low standby current</li> <li>Standby average current 3ma less;</li> <li>Support the GSM / GPRS Quad-band, including 850,900,1800,1900MHZ;</li> <li>Support China Mobile and China Unicom's 2G GSM network worldwide;</li> <li>GPRS Class 10;</li> <li>Sensitivity &lt;-105;</li> <li>Support voice calls;</li> <li>Support SMS text messaging;</li> <li>Support GPRS data traffic, the maximum data rate, download 85.6Kbps, upload 42.8Kbps;</li> <li>Supports standard GSM07.07,07.05 AT commands and extended commands Ai-Thinker;</li> <li>Supports two serial ports, a serial port to download an AT command port;</li> <li>AT command supports the standard AT and TCP / IP command interface;</li> <li>Support digital audio and analog audio support for HR, FR, EFR, AMR speech coding;</li> <li>Support ROHS, FCC, CE, CTA certification;</li> </ul>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#specifications","title":"Specifications","text":"<ul> <li>Quad-band: 850/900/1800/1900 MHz</li> <li>GPRS multi-slot: 12, 1 to 12 may be configured</li> <li>GPRS mobile station: Class B</li> <li>Compatible with GSM Phase 2/2 +: Class 4 (2W @ 850/900 MHz) Class 1 (1W @ 1800 / 1900MHz)</li> <li>Current consumption: 1.3mA @ DRX = 5; 1.2mA @ DRX = 9</li> <li>AT command control: Standard GSM07.07,07.05 AT commands and extended commands Ai-Thinker</li> <li>SIM Application Toolkit</li> <li>GPRS Class 10: Up 85.6 kbps (upstream) &amp; 42.8Kbps (downlink)</li> <li>PBCCH support</li> <li>Coding scheme: CS 1, 2, 3, 4</li> <li>Support CSD: Up 14.4 kbps</li> <li>Support USSD</li> <li>Stack: PPP / TCP / UDP / HTTP / FTP / SMTP / MUX</li> </ul>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#cautions","title":"Cautions","text":"<ul> <li>Make sure your SIM card is unlocked.</li> <li>The product is provided as is without an insulating enclosure. Please observe ESD precautions specially in dry (low humidity) weather.</li> <li>It just supports baud rate 115200bps.</li> </ul>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#interface-function","title":"Interface Function","text":""},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#usage","title":"Usage","text":""},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#connect-the-antenna","title":"Connect the Antenna","text":"<p>1.A miniature coaxial RF connector is present on the 32u4 with A6 GPRS/GSM to connect with a GSM Antenna. The connector present on the 32u4 with A6 GPRS/GSM is called a U.FL connecto.The GSM Antenna supplied with the GPRS Shield has an SMA connector (and not an RP-SMA connector) on it.The connection topology is shown in the diagram below:</p> <p></p>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#insert-an-micro-sim-card-to-sim-card-holder","title":"Insert an Micro SIM card to SIM Card Holder","text":"<p>2.Pin Holder for SIM Cards. Both 1.8 volts and 3.0 volts SIM Cards are supported by A6 GPRS/GSM Module, the SIM card voltage type is automatically detected. </p>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#download-code","title":"Download Code","text":"<p>Connect the USB cable to the 32u4 with A6 GPRS/GSM board,then download the code as below:</p> <pre><code>#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define DEBUG true\n\nvoid setup()\n{\n  Serial.begin(115200);\n  Serial1.begin(115200);\n  pinMode(4, OUTPUT);\n  pinMode(5, OUTPUT);\n  pinMode(8,OUTPUT);\n  digitalWrite(5, HIGH); \n  digitalWrite(4, LOW); \n  digitalWrite(8, LOW); \n  Serial.println(\"After 5s, test begin!!\");\n  delay(5000);\n}\n\nvoid loop()\n{\n  Serial.println(\"Test begin!!\");\n  digitalWrite(8, HIGH); \n  delay(3000);       \n  digitalWrite(8, LOW);\n  Serial.println(\"A6 Power ON!\");\n  Serial.println(\"You may receive the AT   OK\"); \n   sendData( \"AT\",1000,DEBUG);\n  sendData( \"AT\",1000,DEBUG);\n  Serial.println(\"A6 go to sleep now!\"); \n   digitalWrite(5, LOW);  //sleep\n   delay(2000);\n   Serial.println(\"call 10086\");\n   call();          //no call, A6 sleeping   \n   sendData( \"AT\",1000,DEBUG);\n   Serial.println(\"if you hear the voice and receive AT   OK,test failed!\");\n   digitalWrite(5, HIGH);   // wake up\n   delay(1000);\n   Serial.println(\"A6 WAKE UP!\"); \n   Serial.println(\"test it weather wakaup, if re ok, a6 wakeup\"); \n   sendData( \"AT\",1000,DEBUG);     \n   Serial.println(\"A6 power off!\"); \n   digitalWrite(4, HIGH); // power off A6\n   delay(2000);\n   digitalWrite(4, LOW);\n   Serial.println(\"pringt AT and you not re OK\"); \n   sendData( \"AT\",1000,DEBUG);      //NO RE OK\n     Serial.println(\"A6 NO RESBOND\"); \n   digitalWrite(8, HIGH);           //POWER UP\n  delay(3000);       \n  digitalWrite(8, LOW);\n  delay(5000);\n  Serial.println(\"A6 Power ON!\"); \n   delay(5000);\n   Serial.println(\".................................\"); \n   sendData( \"AT\",1000,DEBUG); //TEST AND MAKE CALL\n   delay(3000);\n   call();\n   Serial.println(\"A6 Test complete!\");\n   while(1);\n}\n\nvoid call(void)\n   {\n         sendData( \"AT+CSQ\",1000,DEBUG);     \n         sendData(\"AT+SNFS=0\",1000,DEBUG);\n         sendData(\"ATD10086;\",1000,DEBUG);\n         delay(10000);\n         sendData( \"ATH\",1000,DEBUG);\n   }\n\nString sendData(String command, const int timeout, boolean debug)\n{\n    String response = \"\";    \n    Serial1.println(command); \n    long int time = millis();   \n    while( (time+timeout) &gt; millis())\n    {\n      while(Serial1.available())\n      {       \n        char c = Serial1.read(); \n        response+=c;\n      }  \n    }    \n    if(debug)\n    {\n      Serial.print(response);\n    }    \n    return response;\n}\n</code></pre> <p>After you complete download the code, open the serial debug window(notice set the baud rate 115200), you will see some information as bellow:</p> <p></p>"},{"location":"Products/Arduino/32u4-with-a6-gprsgsm.html#resource","title":"Resource","text":"<ul> <li>32u4 with A6 GPRS/GSM eagle file</li> </ul>"},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html","title":"32u4 with A7 GPRS/GSM","text":""},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#introduction","title":"Introduction","text":"<p>The 32U4 with A7 GPS+GSM/GPRS Board is based on Mega32U4 and A7 GPS+GSM/GPRS module. It can be used to make a call, send text messages and get GPS positioning. Also it has one analog interface, one IIC interface and two digital interface, which you can connect to other expansion modules. It is very easy for you to make a GPS Tracker by using this board.</p> <p>Model: (Discontinued\uff09 </p>"},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#features","title":"Features","text":"<ul> <li>ATMEGA32U4+A7.</li> <li>Work voltage: 3.3V to 5V.</li> <li>Operating temperature\uff1a -30 \u2103 to + 80 \u2103.</li> <li>Three kinds of interface.</li> <li>Equipped with 3.5mm headphone jack.</li> <li>3.7V Battery power supply.</li> <li>Standby average current 3ma or less.</li> <li>Support the GSM / GPRS Quad-band, including 850,900,1800,1900MHZ.</li> <li>Support China Mobile and China Unicom's 2G GSM network worldwide.</li> <li>GPRS Class 10.</li> <li>Sensitivity &lt; -105.</li> <li>Support GPS Positioning.</li> <li>Support for voice calls.</li> <li>Support for SMS text messaging.</li> <li>Support GPRS data business, the maximum data rate: download 85.6Kbps, upload 42.8Kbps.</li> <li>Supports standard GSM07.07, 07.05 AT commands and Ai-Thinker extended commands.</li> <li>Supports two serial ports, a serial port to download an AT command port.</li> <li>Support for Global Positioning System.</li> <li>Horizontal positioning accuracy of less than 2.5m.</li> <li>AT command supports the standard AT and TCP / IP command interface.</li> <li>Support digital audio and analog audio support for HR, FR, EFR, AMR speech coding.</li> <li>Support ROHS, FCC, CE, CTA certification.</li> </ul>"},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#specifications","title":"Specifications","text":"<ul> <li>Quad-band: 850/900/1800/1900 MHz.</li> <li>GPRS multi-slot: 12, 1 to 12 can be configured.</li> <li>GPRS mobile station: Class B.</li> <li>Compatible with GSM Phase 2/2 +: Class 4 (2W @ 850/900 MHz) Class 1 (1W @ 1800 / 1900MHz).</li> <li>Current consumption: 1.3mA @ DRX = 5; 1.2mA @ DRX = 9.</li> <li>AT command control: Standard GSM07.07, 07.05 AT commands and Ai-Thinker extended commands.</li> <li>SIM Application Toolkit.</li> <li>GPRS Class 10: Up 85.6 kbps (upstream) &amp; 42.8Kbps (downlink).</li> <li>Dynamic Conditions Altitude &lt;18,000 meters (60,000 feet).</li> <li>Speed &lt;515 m / s (1000 nautical miles), acceleration &lt;4 g.</li> <li>PBCCH support.</li> <li>Coding scheme: CS 1, 2, 3, 4.</li> <li>Support CSD: Up 14.4 kbps.</li> <li>Support USSD.</li> <li>Stack: PPP / TCP / UDP / HTTP / FTP / SMTP / MUX.</li> <li>Dimensions(mm):50.0(L)x36.5(W)x9.6(H)</li> </ul>"},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#cautions","title":"Cautions","text":"<ul> <li>Make sure your SIM card is locked.</li> <li>This product is supplied as is, without an insulated housing. In high humidity weather, pay special attention to ESD precautions.</li> <li>It just supports baud rate 115200bps.</li> </ul>"},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#interface","title":"Interface","text":""},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#usage","title":"Usage","text":"<p>1. Install the antenna.</p> <p>Two miniature coaxial RF connector is present on the back of the 32U4 with A7 GPRS/GSM/GPS Board to connect with a GSM antenna or a GPS antenna . The connector present on the 32U4 with A7 GPRS/GSM/GPS is called a U.FL connector.The GSM Antenna supplied with the GPRS Shield has an SMA connector (and not an RP-SMA connector) on it.The connection topology is shown in the diagram below:</p> <p> </p> <p>2. Insert the Micro SIM card into the SIM card holder.</p> <p>There is a SIM card holder on the back of the board. Both 1.8 volts and 3.0 volts SIM Cards are supported by this board, the SIM card voltage type is automatically detected.</p> <p></p> <p>3. Connect the battery.</p> <p>Because the PC USB port output current is not enough\uff0cso you should connedct an 3.7V lithium battery to the battery port.</p> <p></p> <p>4. Upload the code</p> <p>Open your Arduino IDE, choose the file, choose the Arduino Leonardo Board. You can refer to this test code and upload it to your board: 32U4_with_A7_test</p> <pre><code>/*\n * Created by Keen\n * Modified by Keen \n * Date: 11/04/2017\n */\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#define DEBUG true\nString target_phone = \"+861**********6\"; // Your phone number, not number of 32U4 with A7/GSM/GPS.\n\nvoid setup()\n{\n  Serial.begin(115200);\n  Serial1.begin(115200);\n  pinMode(4, OUTPUT);\n  pinMode(5, OUTPUT);\n  pinMode(8,OUTPUT);\n  digitalWrite(5, HIGH); \n  digitalWrite(4, LOW); \n  digitalWrite(8, LOW); \n  Serial.println(\"After 2s, test begin!!\");\n  delay(2000);\n  funtion_test();\n}\n\nvoid loop()\n{\n  if (Serial1.available()&gt;0) {\n    Serial.write(Serial1.read());\n  }\n  if (Serial.available()&gt;0) {\n    Serial1.write(Serial.read());\n  }\n}\n\nvoid funtion_test(){\n   Serial.println(\"Test begin!!\");\n   digitalWrite(8, HIGH); \n   delay(3000);       \n   digitalWrite(8, LOW); //Power ON..\n   Serial.println(\"A7 Power ON!\");\n   Serial.println(\"You may receive the AT   OK\"); \n   sendData( \"AT\",1000,DEBUG);\n   delay(500);\n   digitalWrite(5, LOW);  //Sleep\n   Serial.println(\"A7 go to sleep now!\");\n   delay(3000);\n   Serial.println(\"test GPS function\");\n   testGPS();          //no call, A7 sleeping   \n   sendData( \"AT\",1000,DEBUG);\n   delay(500);\n   Serial.println(\"if you receive GPS data,the sleep test failed!\");\n   digitalWrite(5, HIGH);   // wake up\n   delay(1000);\n   Serial.println(\"A7 WAKE UP!\"); \n   Serial.println(\"test whether wake up or not, if OK, A7 wake up\"); \n   sendData( \"AT\",1000,DEBUG);\n   delay(500);     \n   digitalWrite(4, HIGH); // power off A6\n   Serial.println(\"A7 power off!\");\n   delay(3000);\n   digitalWrite(4, LOW);\n   Serial.println(\"print AT and you not receive OK\"); \n   sendData( \"AT\",1000,DEBUG);\n   delay(500); \n   Serial.println(\"A7 not Respond\"); \n   digitalWrite(8, HIGH);           //POWER UP\n   delay(3000);       \n   digitalWrite(8, LOW);\n   delay(3000);\n   Serial.println(\"A7 Power ON!\"); \n   Serial.println(\".................................\"); \n   sendData( \"AT\",1000,DEBUG); //\n   delay(1000);\n   Serial.println(\"The funtion is Get GPS...\"); \n   testGPS();\n   Serial.println(\"The funtion is Dial Voice Call...\"); \n   delay(1000);\n   DialVoiceCall();\n   Serial.println(\"The funtion is Send SMS ...\"); \n   delay(1000);\n   SendTextMessage();\n   Serial.println(\"This function is submit a HTTP request...\");\n   delay(1000);\n   TCP_GPRS();\n   Serial.println(\"All the test of 32U4 with A7 is complete!\");\n}\n\nvoid testGPS(void){\n  sendData(\"AT+GPS=1\",1000,DEBUG);     \n  sendData(\"AT+GPSRD=1\",3000,DEBUG);\n  sendData(\"AT+GPS=0\",10000,DEBUG);\n}\n\nvoid TCP_GPRS(){\n   sendData(\"AT+CREG?\",5000,DEBUG); //Query network registration\n   delay(100);\n   sendData(\"AT+CGATT=1\",5000,DEBUG);\n   delay(100); \n   sendData(\"AT+CGDCONT=1,\\\"IP\\\",\\\"CMNET\\\"\",2000,DEBUG);//setting PDP parameter \n   delay(100); \n   sendData(\"AT+CGACT=1,1\",10000,DEBUG); //Activate PDP, open Internet service\n   delay(100);  \n   sendData(\"AT+CIPSTART=\\\"TCP\\\",\\\"www.baidu.com\\\",80\",10000,DEBUG);\n   delay(100);\n   sendData(\"AT+CIPSEND=5,\\\"12345\\\"\",2000,DEBUG); //Send string \"12345\" \n   delay(100); \n   sendData(\"AT+CIPCLOSE\",2000,DEBUG);     //Close TCP\n   delay(100); \n   /*\n     sendData(\"AT+CREG?\",3000,DEBUG);     \n     sendData(\"AT+CGATT=1\",1000,DEBUG);\n     sendData(\"AT+CGDCONT=1,\\\"IP\\\",\\\"CMNET\\\"\",1000,DEBUG);\n     sendData(\"AT+CGACT=1,1\",1000,DEBUG);\n     sendData(\"AT+CIPSTART=\\\"TCP\\\",\\\"google.com\\\",80\",3000,DEBUG);\n     sendData(\"AT+CIPSEND=80\",1000,DEBUG);\n     sendData(\"GET http://www.google.com HTTP/1.0\\r\\n\",100,DEBUG);\n     */\n}\n\nvoid SendTextMessage()\n{ \n  sendData(\"\",2000,DEBUG);\n  sendData(\"AT+CMGF=1\",2000,DEBUG);//Because we want to send the SMS in text mode\n  delay(100);\n  sendData(\"AT+CMGS=\"+target_phone,2000,DEBUG);//send sms message, be careful need to add a country code before the cellphone number\n  delay(100);\n  sendData(\"GSM test message!\",2000,DEBUG);//the content of the message\n  delay(100);\n  Serial1.println((char)26);//the ASCII code of the ctrl+z is 26\n  delay(100);\n}\n\nvoid DialVoiceCall()\n{\n   sendData(\"AT+SNFS=0\",5000,DEBUG);\n   delay(100);\n   sendData(\"ATD\"+target_phone,5000,DEBUG);// \"ATD+86137xxxxxxxx\"dial the number\n   delay(100);\n}\n\n\nString sendData(String command, const int timeout, boolean debug)\n{\n    String response = \"\";    \n    Serial1.println(command); \n    long int time = millis();\n    while( (time+timeout) &gt; millis())\n    {\n      while(Serial1.available())\n      {       \n        char c = Serial1.read(); \n        response+=c;\n      }  \n    }    \n    if(debug)\n    {\n      Serial.print(response);\n    }    \n    return response;\n}\n\nvoid httpRec(const int timeout){\n    String response = \"\";    \n    long int time = millis();\n    while( (time+timeout) &gt; millis())\n    {\n      while(Serial1.available())\n      {       \n        char c = Serial1.read(); \n        response+=c;\n      }  \n    }    \n    Serial.print(response); \n}\n</code></pre> <p>After you complete download the code, open the Serial monitor, you will see some information as bellow:</p> <p> </p>"},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#get-and-send-the-location-information-to-your-phone-by-sms","title":"Get and send the location information to your phone by SMS","text":"<p>This example is how to get the GPS location information and send it to your cellphone.In the code,we need to change the target phone. And the Lithium Batteries must be used. When the board gets the 30 times location information successfully and the information will be send by SMS.</p> <pre><code>/*\n * Created by Keen\n * Modified by Keen \n * Date: 15/07/2017\n * Please note:\n * 1.You need to change the \"target_phone\". \n * 2.Lithium batteries must be used.\n * 3.The GPS and GSM antenna must be used.\n * Please open your \"Serial Monitor\" and you will get the debug information. \n */\n#define DEBUG true\n\nchar byteGPS=-1;\nchar linea[300] = \"\";\nchar comandoGPR[7] = \"$GPRMC\";\nint cont=0;\nint bien=0;\nint conta=0;\nint indices[13];\n\nint GPS_time=30;                        // When the board gets the 30 times location information successfully and the location information will be send by sms.      \nString target_phone = \"+861************6\"; // Your phone number,be careful need to add a country code before the cellphone number\n\nString GPS_position=\"\";\nint GPS_position_count=0;\n\nvoid setup()\n{\n  Serial.begin(115200);\n  Serial1.begin(115200);\n  pinMode(4, OUTPUT);\n  pinMode(5, OUTPUT);\n  pinMode(8,OUTPUT);\n  digitalWrite(5, HIGH); \n  digitalWrite(4, LOW); \n  digitalWrite(8, LOW); \n  delay(2000);\n  digitalWrite(8, HIGH); \n  delay(3000);       \n  digitalWrite(8, LOW);\n  Serial.println(\"A7 Power ON!\");\n  sendData(\"AT+GPS=0\",3000,DEBUG);     //Close GPS\n  for(int i=0;i&lt;2;i++){                //Make sure the GPS has been turned on\n    sendData(\"AT+GPSRD=1\",1000,DEBUG);\n    Serial1.println(\"AT+GPS=1\");\n  }\n  Serial.println(\"*********************************************************\");\n  Serial.println(\"**If don`t display 'GPS positioning....',please reboot.**\");\n  Serial.println(\"*********************************************************\");\n}\n\nvoid loop()\n{\n    testgps();\n}\n\nvoid testgps(){\n  while(Serial1.available()){\n   byteGPS=Serial1.read();  \n  // Read a byte of the serial port\n   if (byteGPS == -1) {       \n    // See if the port is empty yet\n   } \n   else {\n     // note: there is a potential buffer overflow here!\n     linea[conta]=byteGPS;        // If there is serial port data, it is put in the buffer\n     conta++;                      \n     //Serial.print(byteGPS);    //If you delete '//', you will get the all GPS information\n     if (byteGPS==13){\n      // If the received byte is = to 13, end of transmission\n      // note: the actual end of transmission is &lt;CR&gt;&lt;LF&gt; (i.e. 0x13 0x10)\n      cont=0;\n      bien=0;\n      // The following for loop starts at 1, because this code is clowny and the first byte is the &lt;LF&gt; (0x10) from the previous transmission.\n       for (int i=1;i&lt;7;i++){     // Verifies if the received command starts with $GPR\n         if (linea[i]==comandoGPR[i-1]){\n           bien++;\n         }\n       }\n       if(bien==6){ \n        // If yes, continue and process the data\n        //Data Partitioning\n         for (int i=0;i&lt;300;i++){\n           if (linea[i]==','){    // check for the position of the  \",\" separator\n             // note: again, there is a potential buffer overflow here!\n             indices[cont]=i;\n             cont++;\n           }\n           if (linea[i]=='*'){    // ... and the \"*\"\n             indices[12]=i;\n             cont++;\n           }\n         }\n         //panel data, for example:Direction (E/W):Longitude-Direction(N/S):Latitude&lt;---&gt;E:11350.51872-N:2236.40687        \n         for(int i=5;i&gt;1;i--){\n           for (int j=indices[i];j&lt;(indices[i+1]-1);j++){\n             GPS_position+=linea[j+1];\n           }\n           if((i==5)||(i==3)){\n             GPS_position+=\":\";  \n           }else if(i==4){\n             GPS_position+=\"-\";   \n           }\n         }\n         //If the return \":-:\", it means empty data, continue positioning \n         if(GPS_position==\":-:\"){\n          Serial.println(\"GPS positioning....\");\n         }else{\n            Serial.println(GPS_position);\n            GPS_position_count++;\n            //When GPS_position_count is equivalent to GPS_time, stop positioning and start to send sms messages\n            if(GPS_position_count==GPS_time){\n            GPS_position_count=0;          //Reset count\n            sendData(\"AT+GPS=0\",1000,DEBUG);\n            delay(1000); \n            SendTextMessage(GPS_position);\n            sendData(\"AT+GPS=1\",1000,DEBUG); \n           }\n\n         }\n       }\n       GPS_position=\"\";\n       conta=0;                    // Reset the buffer\n       for (int i=0;i&lt;300;i++){    //  \n       linea[i]=' ';             \n       }                \n     }\n   }  \n   }\n}\n\nvoid SendTextMessage(String message)\n{ \n  sendData(\"AT+CMGF=1\",5000,DEBUG);            //Set the SMS in text mode\n  delay(100);\n  sendData(\"AT+CMGS=\"+target_phone,2000,DEBUG);//send sms message to the cellphone , be careful need to add a country code before the cellphone number\n  delay(100);\n  sendData(message,2000,DEBUG);                //the content of the message\n  delay(100);\n  Serial1.println((char)26);                  //the ASCII code of the ctrl+z is 26\n  delay(100);\n  sendData(\"\",1000,DEBUG);                     //Clear serial data\n  delay(100);\n}\n\nvoid sendData(String command, const int timeout, boolean debug)\n{\n    String response = \"\";    \n    Serial1.println(command); \n    long int time = millis();   \n    while( (time+timeout) &gt; millis()){\n      while(Serial1.available()){       \n        response += (char)Serial1.read(); \n      }  \n    }    \n    if(debug){\n      Serial.print(response);\n    }    \n}\n</code></pre>"},{"location":"Products/Arduino/32u4-with-a7-gprsgsm.html#resource","title":"Resource","text":"<ul> <li>32u4 with A7 GPRS/GSM+GPS eagle file</li> <li>A7_(GSM+GPRS+GPS+AGPS)_module_Hardware_introduction</li> </ul>"},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html","title":"32u4 with A9G GPRS/GSM/GPS","text":""},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#introduction","title":"Introduction","text":"<p>The 32U4 with A9 GPRS/GSM/GPS Board is based on Mega32U4 and A9 GPRS/GSM/GPS module. It can be used to make a call, send text messages and get GPS positioning. Also it has one analog interface, one IIC interface and two digital interface, which you can connect to other expansion modules. It is very easy for you to make a GPS Tracker by using this board. It is also very easy to use AT firmware and use several AT commands can be configured successfully.</p> <p>Model: AMC01219U</p> <p></p> <p></p>"},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#features","title":"Features","text":"<ul> <li>ATMEGA32U4+A9G.</li> <li>Work voltage: 3.3V to 5V.</li> <li>Operating temperature\uff1a -30 \u2103 to + 80 \u2103.</li> <li>Three kinds of interface.</li> <li>Equipped with 3.5mm headphone jack.</li> <li>3.7V Battery power supply.</li> <li>Standby average current 3ma or less.</li> <li>Support the GSM / GPRS/ GPS Quad-band, including 850,900,1800,1900MHZ.</li> <li>Support China Mobile and China Unicom's 2G GSM network worldwide.</li> <li>GPRS Class 10.</li> <li>Sensitivity &lt; -105.</li> <li>Support GPS Positioning.</li> <li>Support for voice calls.</li> <li>Support for SMS text messaging.</li> <li>Support GPRS data business, the maximum data rate: download 85.6Kbps, upload 42.8Kbps.</li> <li>Supports standard GSM07.07, 07.05 AT commands and Ai-Thinker extended commands.</li> <li>Supports two serial ports, a serial port to download an AT command port.</li> <li>Support for Global Positioning System.</li> <li>Horizontal positioning accuracy of less than 2.5m.</li> <li>AT command supports the standard AT and TCP / IP command interface.</li> <li>Support digital audio and analog audio support for HR, FR, EFR, AMR speech coding.</li> <li>Support ROHS, FCC, CE, CTA certification.</li> </ul>"},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#pin-definitions","title":"Pin Definitions","text":""},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#specifications","title":"Specifications","text":"<ul> <li>The size of A9G: 19.2*18.8*3mm</li> <li>Quad-band: 850/900/1800/1900 MHz.</li> <li>GPRS multi-slot: 12, 1 to 12 can be configured.</li> <li>GPRS mobile station: Class B.</li> <li>Compatible with GSM Phase 2/2 +: Class 4 (2W @ 850/900 MHz) Class 1 (1W @ 1800 / 1900MHz).</li> <li>Current consumption: 1.3mA @ DRX = 5; 1.2mA @ DRX = 9.</li> <li>AT command control: Standard GSM07.07, 07.05 AT commands and Ai-Thinker extended commands.</li> <li>SIM Application Toolkit.</li> <li>GPRS Class 10: Up 85.6 kbps (upstream) &amp; 42.8Kbps (downlink).</li> <li>Dynamic Conditions Altitude &lt;18,000 meters (60,000 feet).</li> <li>Speed &lt;515 m / s (1000 nautical miles), acceleration &lt;4 g.</li> <li>PBCCH support.</li> <li>Coding scheme: CS 1, 2, 3, 4.</li> <li>Support CSD: Up 14.4 kbps.</li> <li>Support USSD.</li> <li>Stack: PPP / TCP / UDP / HTTP / FTP / SMTP / MUX</li> </ul>"},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#cautions","title":"Cautions","text":"<ul> <li>Make sure your SIM card is locked.</li> <li>This product is supplied as is, without an insulated housing. In high humidity weather, pay special attention to ESD precautions.</li> <li>It just supports baud rate 115200bps.</li> </ul>"},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#interface-function","title":"Interface Function","text":""},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#usage","title":"Usage","text":""},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#1connect","title":"1.Connect","text":"<p>Let's start a simple test.</p> <p>1. Install the antenna.</p> <p>Two miniature coaxial RF connector is present on the back of the 32U4 with A9G GPRS/GSM/GPS Board to connect with a GSM antenna or a GPS antenna . The connector present on the 32U4 with A9G GPRS/GSM/GPS is called a U.FL connector.The GSM Antenna supplied with the GPRS Shield has an SMA connector (and not an RP-SMA connector) on it.The connection topology is shown in the diagram below:</p> <p> </p> <p>2. Insert the Micro SIM card into the SIM card holder.</p> <p>There is a SIM card holder on the back of the board. Both 1.8 volts and 3.0 volts SIM Cards are supported by this board, the SIM card voltage type is automatically detected. </p> <p>3. Connect the battery.</p> <p>Because the PC USB port output current is not enough\uff0cso you should connedct an 3.7V lithium battery to the battery port.</p> <p></p> <p>4. Upload the code</p> <p>Open your Arduino IDE, choose the file, choose the Arduino Leonardo Board.</p> <p>You can refer to this test code and upload it to your board: 32U4_with_A9_test</p> <p>5.Then open the SSCOM32. Please configure it as follows:</p> <p></p> <p>6.Now, you can use some AT commands to control the 32u4 with A9G GPRS/GSM/GPS.</p>"},{"location":"Products/Arduino/32u4-with-a9g-gprsgsmgps.html#resource","title":"Resource","text":"<p>32U4 with A9 eagle file</p> <p>32u4_with_A9G_GPS_test_step.pdf</p> <p>32U4_with_A9_test</p> <p>serial port tool SSCOM</p>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html","title":"32u4 with Lora RFM95 IOT Board-868MHz","text":""},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#introduction","title":"Introduction","text":"<p>The 32u4 with Lora RFM95 IOT Board consists of the mega24u and the wireless RF module RFM95. The module can accomplish long distance transmission of data, that is, and it can provide long range spread spectrum communication and high anti-interference. It also has the function of transmitting data through the wall.This board is small and easy to carry,and it can be compatible with both USAR and I2C.The wireless transmission module is mainly used in remote control, telemetry, remote communication equipment, robot control, wireless communications and so on. Its high anti-interference can give your project a certain degree of convenience.</p> <p>Model: WIR01322B </p>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#features","title":"Features","text":"<ul> <li>LoRaTM Modem</li> <li>Operating frequency: 868MHZ@RFM95</li> <li>Output power: 20dbm</li> <li>Maximum emission current: 120mA</li> <li>Current accepted: 12mA</li> <li>Sleep current 2ua</li> <li>Transmission rate: 300kbps</li> <li>Power: 3.7-5</li> </ul>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#specifications","title":"Specifications","text":"<ul> <li>168 dB maximum link budget</li> <li>Excellent blocking immunity</li> <li>Compatible with I2C and USAR</li> <li>Rechargeable and uninterrupted</li> <li>Analog port and digital port</li> <li>Long distance</li> <li>Automated meter reading</li> <li>Built-in temperature sensor and low battery indicator</li> <li>Built-in bit synchronizer for clock recovery</li> <li>Dimensions(mm):62.0(L)x37.0(W)x9.0(H)</li> </ul>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#interface-function","title":"Interface Function","text":"<p>ICSP:2.0mm spacing ICSP package</p>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#usage","title":"Usage","text":""},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#1connect","title":"1.Connect","text":"<p>a.Connect USB and the other end connect to PC.When the board is working properly, PMR LED turn on,as follow picture:</p> <p></p> <p>b.Connect any two pieces of board onto the computer by USB, the two antennas corresponding to each other, as shown in the following picture:</p> <p></p>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#2download-the-file","title":"2.Download the file","text":"<p>1.Download the RadioHead library and put the RadioHead file under the Arduino IDE installation directory Library</p>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#3download","title":"3.Download","text":"<p>3.Copy the following code, one is the sending program, one for the receiving program, downloaded to two boards:</p> <p>client code</p> <pre><code>// rf95_client.pde\n// -*- mode: C++ -*-\n// Example sketch showing how to create a simple messageing client\n// with the RH_RF95 class. RH_RF95 class does not provide for addressing or\n// reliability, so you should only use RH_RF95 if you do not need the higher\n// level messaging abilities.\n// It is designed to work with the other example rf95_server\n// Tested with Anarduino MiniWirelessLoRa, Rocket Scream Mini Ultra Pro with\n// the RFM95W, Adafruit Feather M0 with RFM95\n\n#include &lt;SPI.h&gt;\n#include &lt;RH_RF95.h&gt;\n\n// Singleton instance of the radio driver\n//RH_RF95 rf95;\nRH_RF95 rf95(10, 7); // Rocket Scream Mini Ultra Pro with the RFM95W\n//RH_RF95 rf95(8, 3); // Adafruit Feather M0 with RFM95 \n\n// Need this on Arduino Zero with SerialUSB port (eg RocketScream Mini Ultra Pro)\n//#define Serial SerialUSB\n\nvoid setup() \n{\n  // Rocket Scream Mini Ultra Pro with the RFM95W only:\n  // Ensure serial flash is not interfering with radio communication on SPI bus\n//  pinMode(4, OUTPUT);\n//  digitalWrite(4, HIGH);\n\n  Serial.begin(9600);\n  while (!Serial)\u00a0; // Wait for serial port to be available\n  if (!rf95.init())\n    Serial.println(\"init failed\");\n  // Defaults after init are 434.0MHz, 13dBm, Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on\n\n  // The default transmitter power is 13dBm, using PA_BOOST.\n  // If you are using RFM95/96/97/98 modules which uses the PA_BOOST transmitter pin, then \n  // you can set transmitter powers from 5 to 23 dBm:\n//  driver.setTxPower(23, false);\n  // If you are using Modtronix inAir4 or inAir9,or any other module which uses the\n  // transmitter RFO pins and not the PA_BOOST pins\n  // then you can configure the power transmitter power for -1 to 14 dBm and with useRFO true. \n  // Failure to do that will result in extremely low transmit powers.\n//  driver.setTxPower(14, true);\n   if (!rf95.setFrequency(868.0)){\n    Serial.println(\"setFrequency failed\");\n    while(1)\n    ;\n    }\n}\n\nvoid loop()\n{\n  Serial.println(\"Sending to rf95_server\");\n  // Send a message to rf95_server\n  uint8_t data[] = \"Hello World!\";\n  rf95.send(data, sizeof(data));\n\n  rf95.waitPacketSent();\n  // Now wait for a reply\n  uint8_t buf[RH_RF95_MAX_MESSAGE_LEN];\n  uint8_t len = sizeof(buf);\n\n  if (rf95.waitAvailableTimeout(3000))\n  { \n    // Should be a reply message for us now   \n    if (rf95.recv(buf, &amp;len))\n   {\n      Serial.print(\"got reply: \");\n      Serial.println((char*)buf);\n    }\n    else\n    {\n      Serial.println(\"recv failed\");\n    }\n  }\n  else\n  {\n    Serial.println(\"No reply, is rf95_server running?\");\n  }\n  delay(1000);\n}\n</code></pre> <p>server code</p> <pre><code>// -*- mode: C++ -*-\n// Example sketch showing how to create a simple messageing server\n// with the RH_RF95 class. RH_RF95 class does not provide for addressing or\n// reliability, so you should only use RH_RF95  if you do not need the higher\n// level messaging abilities.\n// It is designed to work with the other example rf95_client\n// Tested with Anarduino MiniWirelessLoRa, Rocket Scream Mini Ultra Pro with\n// the RFM95W, Adafruit Feather M0 with RFM95\n\n#include &lt;SPI.h&gt;\n#include &lt;RH_RF95.h&gt;\n\n// Singleton instance of the radio driver\n//RH_RF95 rf95;\n RH_RF95 rf95(10, 7); // Rocket Scream Mini Ultra Pro with the RFM95W\n//RH_RF95 rf95(8, 3); // Adafruit Feather M0 with RFM95 \n\n// Need this on Arduino Zero with SerialUSB port (eg RocketScream Mini Ultra Pro)\n//#define Serial SerialUSB\n\nint led = 9;\n\nvoid setup() \n{\n  // Rocket Scream Mini Ultra Pro with the RFM95W only:\n  // Ensure serial flash is not interfering with radio communication on SPI bus\n//  pinMode(4, OUTPUT);\n//  digitalWrite(4, HIGH);\n\n  pinMode(led, OUTPUT);     \n  Serial.begin(9600);\n  //while (!Serial)\u00a0; // Wait for serial port to be available\n  if (!rf95.init())\n    Serial.println(\"init failed\");  \n  // Defaults after init are 434.0MHz, 13dBm, Bw = 125 kHz, Cr = 4/5, Sf = 128chips/symbol, CRC on\n\n  // The default transmitter power is 13dBm, using PA_BOOST.\n  // If you are using RFM95/96/97/98 modules which uses the PA_BOOST transmitter pin, then \n  // you can set transmitter powers from 5 to 23 dBm:\n//  driver.setTxPower(23, false);\n  // If you are using Modtronix inAir4 or inAir9,or any other module which uses the\n  // transmitter RFO pins and not the PA_BOOST pins\n  // then you can configure the power transmitter power for -1 to 14 dBm and with useRFO true. \n  // Failure to do that will result in extremely low transmit powers.\n//  driver.setTxPower(14, true)\n    if (!rf95.setFrequency(868.0)){\n    Serial.println(\"setFrequency failed\");\n    while(1)\n    ;\n    }\n}\n\nvoid loop()\n{\n  if (rf95.available())\n  {\n    // Should be a message for us now   \n    uint8_t buf[RH_RF95_MAX_MESSAGE_LEN];\n    uint8_t len = sizeof(buf);\n    if (rf95.recv(buf, &amp;len))\n    {\n      digitalWrite(led, HIGH);\n//      RH_RF95::printBuffer(\"request: \", buf, len);\n      Serial.print(\"got request: \");\n      Serial.println((char*)buf);\n//      Serial.print(\"RSSI: \");\n//      Serial.println(rf95.lastRssi(), DEC);\n\n      // Send a reply\n      uint8_t data[] = \"And hello back to you\";\n      rf95.send(data, sizeof(data));\n      rf95.waitPacketSent();\n      Serial.println(\"Sent a reply\");\n       digitalWrite(led, LOW);\n    }\n    else\n    {\n      Serial.println(\"recv failed\");\n    }\n  }\n}\n</code></pre> <p></p>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#4observe","title":"4.Observe","text":"<p>Open Arduino IDE serial monitor, and then observe the serial port debugging window display data, as shown in the following figure:</p> <p></p>"},{"location":"Products/Arduino/32u4-with-lora-rfm95-iot-board-868mhz.html#resource","title":"Resource","text":"<p>RadioHead library</p> <p>rf95_client</p> <p>rf95_server</p> <p>RFM95</p>"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html","title":"3.5 Inch TFT Color Screen Module 320 X 480 Support Arduino UNO Mega2560","text":""},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#description","title":"Description","text":"<p>This is a 3.5-inch 320 * 480 resolution TFT color screen. It supports working boards such as Arduino uno and Arduino mega2560 and Arduino due. Also supports STM32, 51 and other conventional microcontrollers. When using this screen, you do not need any wiring operations, just plug onto your arduino board, we will provide the corresponding Arduino library files, the development code is open source, you can use arduino and this screen to build some applications.The backlight always on, can not control the backlight, backlight is connect to 3.3V. Model: ARS36125D </p> <p></p>"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#features","title":"Features","text":"<ul> <li>Supports development boards such as Arduino UNO and Mega2560 for plug-in use without wiring</li> <li>480X320 resolution, clear display, support for touch function</li> <li>Support 16-bit RGB 65K color display, display rich colors</li> <li>8-bit parallel bus, faster than serial SPI refresh</li> <li>On-board 5V/3.3V level shifting IC, compatible with 5V/3.3V operating voltage</li> <li>Easy to expand the experiment with SD card slot</li> <li>Provides an Arduino library with a rich sample program</li> <li>Military-grade process standards, long-term stable work</li> <li>Provide underlying driver technical support</li> </ul>"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#specification","title":"Specification","text":"Item Value Display Color RGB 65K color Screen Size 3.5(inch) Type TFT Driver IC ILI9341 Resolution 480*320(Pixel) Module Interface 8-bit parallel interface Active Area 73.44*48.96(mm) Module PCB Size 85.49*55.63(mm) Operating Temperature -20\u2103~60\u2103 Storage Temperature -30\u2103~70\u2103 Operating Voltage 5V/3.3V Power Consumption TBD Product Weight(Package containing) 44g"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#pin-layout","title":"Pin Layout","text":"No. Pin Label Pin Description 1 LCD_RST LCD bus reset signal, low level reset 2 LCD_CS LCD bus chip select signal, low level enable 3 LCD_RS LCD bus command / data selection signal, low level:command, high level:data 4 LCD_WR LCD bus write signal 5 LCD_RD LCD bus read signal 6 GND Power ground 7 5V 5V power input 8 3V3 3.3V power input, this pin can be disconnected 9 LCD_D0 LCD 8-bit data Bit0 10 LCD_D1 LCD 8-bit data Bit1 11 LCD_D2 LCD 8-bit data Bit2 12 LCD_D3 LCD8-bit data Bit3 13 LCD_D4 LCD 8-bit data Bit4 14 LCD_D5 LCD 8-bit data Bit5 15 LCD_D6 LCD 8-bit data Bit6 16 LCD_D7 LCD 8-bit data Bit7 17 SD_SS SD card SPI bus chip select signal, low level enable 18 SD_DI SD card SPI bus MOSI signal 19 SD_DO SD card SPI bus MISO signal 20 SD_SCK SD card SPI bus clock signal"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#platforms-supported","title":"Platforms Supported","text":"Arduino"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#usage","title":"Usage","text":""},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#hardware","title":"Hardware","text":"<p>STEP1 Prepare the below stuffs: </p> Crowduino Uno 3.5 Inch TFT Color Screen Module Get one now Get one now <p>STEP2 Plug 2.4 inch TFT Touch Shield into Crowduino Uno; </p> <p>STEP3 Connect Crowduino Uno to PC via a Mini USB cable.</p>"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#software","title":"Software","text":"<p>STEP 1 Download filesArduino_Demo_code_ArduinoUNO&amp;26Mega2560.zip </p> <p>STEP 2 Configure controller board&amp;communication port On top of the Arduino IDE, click \u201cTools&gt;Board&gt;\u201d and select \u201cArduino Uno\u201dfrom the available options  Select the COM port that indicates Arduino Uno. Please note that the actual numbers after the \u201cCOM\u201d word will vary from computer to computer, so they could be different from the ones shown in the figure. </p> <p>STEP 3 Install Library: Unzip the Arduino Demo code_ArduinoUNO&amp;Mega2560.zip file. Copy the dependent libraries in the Install libraries directory in the package (shown below) to the Libraries directory under the Arduino installation directory </p> <p>STEP 4 Open the sample program in the Example directory of the package to test </p> <p>STEP 5 Click the  to upload the code to the Crowduino board  </p> <p>STEP6 After the program is downloaded, run it directly and observe the running status. If it can be displayed normally, the program runs successfully </p>"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#faqs","title":"FAQS","text":"<p>You can list you question here or contact with techsupport@elecrow.com for technology support.</p>"},{"location":"Products/Arduino/35-inch-tft-color-screen-module-320-x-480-support-arduino-uno-mega2560.html#resources","title":"Resources","text":"<p>Arduino_Demo_code_ArduinoUNO&amp;26Mega2560.zip ILI9341_Datasheet.pdf</p>"},{"location":"Products/Arduino/arduino-cnc-shield.html","title":"Arduino CNC Shield","text":""},{"location":"Products/Arduino/arduino-cnc-shield.html#description","title":"Description","text":"<p>What projects can this be used for?  -Small CNC routers, DIY Laser Cutters, 3D Printers and almost any project where you need to control a stepper motors with high precision.  At Protoneer we designed this simple Arduino CNC shield kit (Arduino Extension Board) with the following features:  New with Version 3.51: Added circuitry for End-Stop and Probe signal filtering. This eliminates false triggers and makes it possible use non-shielded cable for end-stops/probes. Bigger Solder pads making it easier to assemble. Probe pin labels have been updated to make it easier to install a probe. Model: CDP03051C </p> <p></p> <p></p>"},{"location":"Products/Arduino/arduino-cnc-shield.html#features","title":"Features","text":"<ul> <li>Includes Noise Filers on all endstops and the probing pin.(New in V3.51)</li> <li>GRBL 0.9 compatible. (Open source firmware that runs on an Arduino UNO that turns G-code commands into stepper signals https://github.com/grbl/grbl)</li> <li>4-Axis support (X, Y, Z , A-Can duplicate X,Y,Z or do a full 4<sup>th</sup> axis with custom firmware using pins A4 and A3)</li> <li>2 x End stops for each axis (6 in total)</li> <li>Coolant enable</li> <li>Uses removable Pololu A4988 compatible stepper drivers. (A4988, DRV8825 and others)(Not Included)</li> <li>Jumpers to set the Micro-Stepping for the stepper drivers. (Some drivers like the DRV8825 can do up to 1/32 micro-stepping )</li> <li>Compact design.</li> <li>Stepper Motors can be connected with 4 pin molex connectors or soldered in place. .</li> <li>Runs on 12-36V DC. (At the moment only the Pololu DRV8825 drivers can handle up to 36V so please consider the operation voltage when powering the board.)</li> </ul>"},{"location":"Products/Arduino/arduino-cnc-shield.html#faqs","title":"FAQS","text":"<ul> <li>What is a CNC router? http://en.wikipedia.org/wiki/CNC_router</li> <li>What is GRBL?An open source, embedded, high performance g-code-parser and CNC milling controller written in optimized C that runs on an Arduino UNO. ttps://github.com/grbl/grbl</li> <li>What is Arduino? http://en.wikipedia.org/wiki/Arduino</li> <li>What Pololu stepper driver can it use? Pololu A4988 - http://www.pololu.com/catalog/product/1182 or Pololu DRV8825 http://www.pololu.com/catalog/product/2133 works well. Both of these driver are available at Elecrow.</li> <li>A4988 Stepper Motor Driver https://www.elecrow.com/a4988-stepper-motor-driver-module.html</li> <li>For more question, please visit forum.protoneer.co.nz</li> </ul>"},{"location":"Products/Crowbits/crowbits-2g-module.html","title":"Crowbits-2G Module","text":""},{"location":"Products/Crowbits/crowbits-2g-module.html#description","title":"Description","text":"<p>Crowbits- OLED is constructed from 128 x 64 dot matrix OLED module. The display offers high brightness, self-emission, high contrast ratio, slim/thin outline, wide viewing angle, wide temperature range and low power consumption.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-2g-module.html#features","title":"Features","text":"<ul> <li>GSM</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-2g-module.html#specification","title":"Specification","text":"<ul> <li>Interface Type: UART</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-2g-module.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board. And Crowbits-Key Board module.</p> <p>2. Connect the module to the D4 and D5 interface of the Crowbits-UNO board, and Crowbits-Key Board connect the MIC interface of the Crowbits-2G Module. As shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;SoftwareSerial.h&gt;\n\nSoftwareSerial mySerial(4, 5); // RX, TX\n\nvoid setup() {\n  // Open serial communications and wait for port to open:\n  Serial.begin(9600);\n  while (!Serial) {\n    ; // wait for serial port to connect. Needed for native USB port only\n  }\n\n\n  Serial.println(\"test uart!\");\n\n  // set the data rate for the SoftwareSerial port\n  mySerial.begin(9600);\n}\n\nvoid loop() { // run over and over\n  if (mySerial.available()) {\n    Serial.write(mySerial.read());\n  }\n  if (Serial.available()) {\n    mySerial.write(Serial.read());\n  }\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Then send a command to call.</p> <ul> <li>AT return OK // The serial port connection is normal</li> <li>AT+CREG? Return +CREG: 0,1 // Indicates successful network registration</li> <li>AT+CSQ //Test signal strength</li> <li>ATD10086; //Call</li> <li>ATH // hang up the phone</li> <li>ATA // answer the phone</li> </ul> <p></p>"},{"location":"Products/Crowbits/crowbits-315mhz-controller.html","title":"Crowbits-315MHz Controller","text":""},{"location":"Products/Crowbits/crowbits-315mhz-controller.html#description","title":"Description","text":"<p>The 315MHz controller is suitable for wireless control, you can use the remote controller to control all the four outputs.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-315mhz-controller.html#features","title":"Features","text":"<ul> <li>Remote controller</li> </ul>"},{"location":"Products/Crowbits/crowbits-315mhz-controller.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-315mhz-controller.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply; Four output modules, such as Crowbits-LED; And a remote control.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Turn on the power. Press the button on the remote control, the LED of the corresponding interface will light up.</p> <p></p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-315mhz-emitter.html","title":"Crowbits-315Mhz Emitter","text":""},{"location":"Products/Crowbits/crowbits-315mhz-emitter.html#description","title":"Description","text":"<p>It uses 315Mhz simplex wireless communication. This module is small, affordable and easy to carry, suitable for indoor and outdoor wireless communication systems, and anti-theft systems, household appliances.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-315mhz-emitter.html#features","title":"Features","text":"<ul> <li>Remote controller system</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-315mhz-emitter.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-315mhz-emitter.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare two Crowbits motherboards, such as Crowbits-UNO board. And a Crowbits-315Mhz Emitter board. Two output modules, such as Crowbits-LED.</p> <p>2. Connect the Crowbits-315Mhz Receiver board to the D2 interface of the Crowbits-UNO board and Crowbits-LED to the D11 interface.</p> <p>3. Connect the Crowbits-315Mhz Emitter board to the D9 interface of another Crowbits-UNO board and Crowbits-LED to the D5 interface.</p> <p>4. Download the \u201ctransmitter\u201d program to the motherboard with the Crowbits-315Mhz Emitter module.</p> <pre><code>// transmitter.pde\n//\n// Simple example of how to use VirtualWire to transmit messages\n// Implements a simplex (one-way) transmitter with an TX-C1 module\n//\n// See VirtualWire.h for detailed API docs\n// Author: Mike McCauley (mikem@open.com.au)\n// Copyright (C) 2008 Mike McCauley\n// $Id: transmitter.pde,v 1.3 2009/03/30 00:07:24 mikem Exp $\n\n#include &lt;VirtualWire.h&gt;\n#undef int\n#undef abs\n#undef double\n#undef float\n#undef round\n\n//TX-PIN 9\n//LED-PIN 4\n#define LedPin 5\n\nvoid setup()\n{\n    pinMode(LedPin,OUTPUT);\n    Serial.begin(9600);   // Debugging only\n    Serial.println(\"setup\");\n\n    // Initialise the IO and ISR\n    vw_set_ptt_inverted(true); // Required for DR3100\n    vw_setup(2000);  // Bits per sec\n}\n\nvoid loop()\n{\n    const char *msg = \"hello\";\n\n    digitalWrite(LedPin, true); // Flash a light to show transmitting\n    vw_send((uint8_t *)msg, strlen(msg));\n    vw_wait_tx(); // Wait until the whole message is gone\n    Serial.print(\"Send: \");\n    Serial.println(msg);\n    digitalWrite(LedPin, false);\n    delay(1000);\n}\n</code></pre> <p>5. Download the \u201creceiver\u201d program to the motherboard with the Crowbits-315Mhz Receiver module.</p> <pre><code>// receiver.pde\n//\n// Simple example of how to use VirtualWire to receive messages\n// Implements a simplex (one-way) receiver with an Rx-B1 module\n//\n// See VirtualWire.h for detailed API docs\n// Author: Mike McCauley (mikem@open.com.au)\n// Copyright (C) 2008 Mike McCauley\n// $Id: receiver.pde,v 1.3 2009/03/30 00:07:24 mikem Exp $\n\n#include &lt;VirtualWire.h&gt;\n#undef int\n#undef abs\n#undef double\n#undef float\n#undef round\n\n//RX-PIN  2\n//LED-PIN 11\n\n#define LedPin 11\n\nvoid setup()\n{\n  pinMode(LedPin, OUTPUT);\n  Serial.begin(9600);   // Debugging only\n  Serial.println(\"setup\");\n\n  // Initialise the IO and ISR\n  vw_set_ptt_inverted(true); // Required for DR3100\n  vw_setup(2000);    // Bits per sec\n\n  vw_rx_start();       // Start the receiver PLL running\n}\n\nvoid loop()\n{\n  char buf[VW_MAX_MESSAGE_LEN];\n  char buflen = VW_MAX_MESSAGE_LEN;\n\n  if (vw_get_message(buf, &amp;buflen)) // Non-blocking\n  {\n    int i;\n\n    digitalWrite(LedPin, true); // Flash a light to show received good message\n    // Message with a good checksum received, dump it.\n    Serial.print(\"Got: \");\n\n    for (i = 0; i &lt; buflen; i++)\n    {\n      Serial.print(buf[i]);\n    }\n    Serial.println(\"\");\n    digitalWrite(LedPin, false);\n  }\n}\n</code></pre> <p>6. After the download procedure is completed, if the Crowbits-315Mhz Receiver module receives the information, the LED light connected to the D11 port will be on.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-315mhz-receiver.html","title":"Crowbits-315Mhz Receiver","text":""},{"location":"Products/Crowbits/crowbits-315mhz-receiver.html#description","title":"Description","text":"<p>It uses 315Mhz simplex wireless communication. This module is small, affordable and easy to carry, suitable for indoor and outdoor wireless communication systems, and anti-theft systems, household appliances.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-315mhz-receiver.html#features","title":"Features","text":"<ul> <li>Remote controller system</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-315mhz-receiver.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-315mhz-receiver.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare two Crowbits motherboards, such as Crowbits-UNO board. And a Crowbits-315Mhz Emitter board. Two output modules, such as Crowbits-LED.</p> <p>2. Connect the Crowbits-315Mhz Receiver board to the D2 interface of the Crowbits-UNO board and Crowbits-LED to the D11 interface.</p> <p>3. Connect the Crowbits-315Mhz Emitter board to the D9 interface of another Crowbits-UNO board and Crowbits-LED to the D5 interface.</p> <p>4. Download the \u201ctransmitter\u201d program to the motherboard with the Crowbits-315Mhz Emitter module.</p> <pre><code>// transmitter.pde\n//\n// Simple example of how to use VirtualWire to transmit messages\n// Implements a simplex (one-way) transmitter with an TX-C1 module\n//\n// See VirtualWire.h for detailed API docs\n// Author: Mike McCauley (mikem@open.com.au)\n// Copyright (C) 2008 Mike McCauley\n// $Id: transmitter.pde,v 1.3 2009/03/30 00:07:24 mikem Exp $\n\n#include &lt;VirtualWire.h&gt;\n#undef int\n#undef abs\n#undef double\n#undef float\n#undef round\n\n//TX-PIN 9\n//LED-PIN 4\n#define LedPin 5\n\nvoid setup()\n{\n    pinMode(LedPin,OUTPUT);\n    Serial.begin(9600);   // Debugging only\n    Serial.println(\"setup\");\n\n    // Initialise the IO and ISR\n    vw_set_ptt_inverted(true); // Required for DR3100\n    vw_setup(2000);  // Bits per sec\n}\n\nvoid loop()\n{\n    const char *msg = \"hello\";\n\n    digitalWrite(LedPin, true); // Flash a light to show transmitting\n    vw_send((uint8_t *)msg, strlen(msg));\n    vw_wait_tx(); // Wait until the whole message is gone\n    Serial.print(\"Send: \");\n    Serial.println(msg);\n    digitalWrite(LedPin, false);\n    delay(1000);\n}\n</code></pre> <p>5. Download the \u201creceiver\u201d program to the motherboard with the Crowbits-315Mhz Receiver module.</p> <pre><code>// receiver.pde\n//\n// Simple example of how to use VirtualWire to receive messages\n// Implements a simplex (one-way) receiver with an Rx-B1 module\n//\n// See VirtualWire.h for detailed API docs\n// Author: Mike McCauley (mikem@open.com.au)\n// Copyright (C) 2008 Mike McCauley\n// $Id: receiver.pde,v 1.3 2009/03/30 00:07:24 mikem Exp $\n\n#include &lt;VirtualWire.h&gt;\n#undef int\n#undef abs\n#undef double\n#undef float\n#undef round\n\n//RX-PIN  2\n//LED-PIN 11\n\n#define LedPin 11\n\nvoid setup()\n{\n  pinMode(LedPin, OUTPUT);\n  Serial.begin(9600);   // Debugging only\n  Serial.println(\"setup\");\n\n  // Initialise the IO and ISR\n  vw_set_ptt_inverted(true); // Required for DR3100\n  vw_setup(2000);    // Bits per sec\n\n  vw_rx_start();       // Start the receiver PLL running\n}\n\nvoid loop()\n{\n  char buf[VW_MAX_MESSAGE_LEN];\n  char buflen = VW_MAX_MESSAGE_LEN;\n\n  if (vw_get_message(buf, &amp;buflen)) // Non-blocking\n  {\n    int i;\n\n    digitalWrite(LedPin, true); // Flash a light to show received good message\n    // Message with a good checksum received, dump it.\n    Serial.print(\"Got: \");\n\n    for (i = 0; i &lt; buflen; i++)\n    {\n      Serial.print(buf[i]);\n    }\n    Serial.println(\"\");\n    digitalWrite(LedPin, false);\n  }\n}\n</code></pre> <p>6. After the download procedure is completed, if the Crowbits-315Mhz Receiver module receives the information, the LED light connected to the D11 port will be on.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-80cm-infrared-proximity-sensor.html","title":"Crowbits-80cm Infrared Proximity Sensor","text":""},{"location":"Products/Crowbits/crowbits-80cm-infrared-proximity-sensor.html#description","title":"Description","text":"<p>The Sharp distance sensors are a popular choice for many projects that require accurate distance measurements. This IR sensor is more economical than sonar rangefinders, yet it provides much better performance than other IR alternatives. Interfacing to most microcontrollers is straightforward: the single analog output can be connected to an analog-to-digital converter for taking distance measurements, or the output can be connected to a comparator for threshold detection</p> <p></p>"},{"location":"Products/Crowbits/crowbits-80cm-infrared-proximity-sensor.html#features","title":"Features","text":"<ul> <li>\uf06cHigh precision</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-80cm-infrared-proximity-sensor.html#specification","title":"Specification","text":"<ul> <li>Distance measuring range: 10 cm to 80 cm (4\" to 32\")</li> <li>Operating voltage: 3.3V</li> <li>Response time: 38 \u00b1 10ms</li> </ul>"},{"location":"Products/Crowbits/crowbits-80cm-infrared-proximity-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the A0 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*\n *      \n *      VCC -- VCC  \n *      GND -- GND  \n *      Signal -- Analog 0 \n */\n#define pin A0\n\nvoid setup () {\n    Serial.begin (9600);\n    pinMode (pin, INPUT);\n}\n\nvoid loop () {\n    uint16_t value = analogRead (pin);\n    uint16_t range = get_gp2d12 (value);\n    Serial.print(\"Analog value:\");\n    Serial.println (value);\n    Serial.print (\"Distance:\");\n    Serial.print (range);\n    Serial.println (\" mm\");\n    Serial.println ();\n    delay (500);\n}\n\nuint16_t get_gp2d12 (uint16_t value) {\n    if (value &lt; 10) value = 10;\n    return ((67870.0 / (value - 3.0)) - 40.0);\n}\n</code></pre> <p>4.After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Place an object in front of the sensor and the serial port will print its distance.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-9g-servo.html","title":"Crowbits-9G Servo","text":""},{"location":"Products/Crowbits/crowbits-9g-servo.html#description","title":"Description","text":"<p>The module is a high quality, low-cost servo for all your mechatronic needs. It comes with a 3-pin power and control cable, mounting hardware. Hope you can make your work easier by using it.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-9g-servo.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-9g-servo.html#specification","title":"Specification","text":"<ul> <li>Compatible with Crowbits</li> <li>Operating Voltage: 3.3V</li> </ul>"},{"location":"Products/Crowbits/crowbits-9g-servo.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the D11 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Download the library \u201cServo\u201d. Unzip and put it in the libraries file of the Arduino IDE, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <p>// Sweep</p> <p>// by BARRAGAN &lt;http://barraganstudio.com&gt;</p> <p>// This example code is in the public domain.</p> <pre><code>#include &lt;Servo.h&gt; \n\nServo myservo;  // create servo object to control a servo \n                // a maximum of eight servo objects can be created \n\nint pos = 0;    // variable to store the servo position \n\nvoid setup() \n{ \n  myservo.attach(11);  // attaches the servo on pin 11 to the servo object \n} \n\n\nvoid loop() \n{ \n  for(pos = 0; pos &lt; 180; pos += 1)  // goes from 0 degrees to 180 degrees \n  {                                  // in steps of 1 degree \n    myservo.write(pos);              // tell servo to go to position in variable 'pos' \n    delay(15);                       // waits 15ms for the servo to reach the position \n  } \n  for(pos = 180; pos&gt;=1; pos-=1)     // goes from 180 degrees to 0 degrees \n  {                                \n    myservo.write(pos);              // tell servo to go to position in variable 'pos' \n    delay(15);                       // waits 15ms for the servo to reach the position \n  } \n}\n</code></pre> <p>5.After the upload is successful, you can see the steering gear is turning.</p>"},{"location":"Products/Crowbits/crowbits-adjustable-infrared-sensor.html","title":"Crowbits-Adjustable Infrared Sensor","text":""},{"location":"Products/Crowbits/crowbits-adjustable-infrared-sensor.html#description","title":"Description","text":"<p>This infrared distance switch features a high-sensitivity photo reflector to perform distance detection function, ranging from 3cm to 80cm. When the infrared light emitted by the emitter gets reflected on a surface that blocked it, the phototransistor can pick up the signal for distance calculation. Also a potentiometer for adjustment is arranged for easy and clear use. It is small, easy to use/assemble, and inexpensive. Useful for robotics, interactive media, industrial assembly line, etc.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-adjustable-infrared-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use/assemble</li> <li>High-sensitivity</li> </ul>"},{"location":"Products/Crowbits/crowbits-adjustable-infrared-sensor.html#specification","title":"Specification","text":"<ul> <li>Power supply: 3.3V</li> <li>Current: 100mA</li> <li>Range: 3-80cm adjustable</li> <li>Wire length: 20cm</li> </ul>"},{"location":"Products/Crowbits/crowbits-adjustable-infrared-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the D2 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>void setup()  {\n Serial.begin(9600);\n pinMode(2,INPUT);\n}\nvoid loop()  {\n while(1)  {\n   delay(500);\n   if(digitalRead(2)==LOW)  {\n     Serial.println(\"object detected.\");\n   }\n   else  {\n     Serial.println(\"no object detected.\");\n   }\n }\n}\n</code></pre> <p>4.After the upload is successful, open the serial port monitor, the baud rate is set to 9600. When an object is detected, the serial port will print \u201cobject detected.\u201d</p> <p></p>"},{"location":"Products/Crowbits/crowbits-air-quality-sensor.html","title":"Crowbits-Air Quality Sensor","text":""},{"location":"Products/Crowbits/crowbits-air-quality-sensor.html#description","title":"Description","text":"<p>This sensor is designed for a comprehensive monitor over indoor air condition. It's responsive to a wide scope of harmful gases, as carbon monoxide, alcohol, acetone, thinner, formaldehyde and so on. Due to the measuring mechanism, this sensor can\u2019t output specific data to describe target gases' concentrations quantitatively. But it's still competent enough to be used in applications that require only qualitative results, like auto refresher sprayers and auto air cycling systems.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-air-quality-sensor.html#features","title":"Features","text":"<ul> <li>Cost efficient</li> <li>Responsive to a wide scope of target gases</li> </ul>"},{"location":"Products/Crowbits/crowbits-air-quality-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: Analog input</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-air-quality-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A2 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cAirQuality\u201d. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*\n  AirQuality Demo V1.0.\n  connect to A0 to start testing. it will needs about 20s to start \n* By: http://www.seeedstudio.com\n*/\n#include\"AirQuality.h\"\n#include\"Arduino.h\"\nAirQuality airqualitysensor;\nint current_quality =-1;\n\nvoid setup()\n{\n    Serial.begin(9600);\n    airqualitysensor.init(14);\n}\nvoid loop()\n{\n    current_quality=airqualitysensor.slope();\n    if (current_quality &gt;= 0)// if a valid data returned.\n    {\n        if (current_quality==0)\n            Serial.println(\"High pollution! Force signal active\");\n        else if (current_quality==1)\n            Serial.println(\"High pollution!\");\n        else if (current_quality==2)\n            Serial.println(\"Low pollution!\");\n        else if (current_quality ==3)\n            Serial.println(\"Fresh air\");\n    }\n}\n\nISR(TIMER1_OVF_vect)\n{\n    if(airqualitysensor.counter==61)//set 2 seconds as a detected duty\n    {\n\n            airqualitysensor.last_vol=airqualitysensor.first_vol;\n            airqualitysensor.first_vol=analogRead(A2);\n            airqualitysensor.counter=0;\n            airqualitysensor.timer_index=1;\n            PORTB=PORTB^0x20;\n    }\n    else\n    {\n        airqualitysensor.counter++;\n    }\n}\n</code></pre> <p>5.After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The serial port will print out the current air quality related information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-barometer-sensor.html","title":"Crowbits-Air Quality Sensor","text":""},{"location":"Products/Crowbits/crowbits-barometer-sensor.html#description","title":"Description","text":"<p>The BMP180 offers a pressure measuring range of 300 to 1100 hPa with an accuracy down to 0.02 hPa in advanced resolution mode. It\u2019s based on piezo-resistive technology for high accuracy, ruggedness and long term stability. These come factory-calibrated, with the calibration coefficients already stored in ROM.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-barometer-sensor.html#features","title":"Features","text":"<ul> <li>Ultra-low power consumption</li> <li>Low noise measurements</li> <li>Wide barometric pressure range</li> </ul>"},{"location":"Products/Crowbits/crowbits-barometer-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-barometer-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cSFE_BMP180\u201d. Unzip and put it in the libraries file of the Arduino IDE, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;SFE_BMP180.h&gt;\n#include &lt;Wire.h&gt;\n\n// You will need to create an SFE_BMP180 object, here called \"pressure\":\n\nSFE_BMP180 pressure;\n\n#define ALTITUDE 1655.0 // Altitude of SparkFun's HQ in Boulder, CO. in meters\n\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"REBOOT\");\n\n  // Initialize the sensor (it is important to get calibration values stored on the device).\n\n  if (pressure.begin())\n    Serial.println(\"BMP180 init success\");\n  else\n  {\n    // Oops, something went wrong, this is usually a connection problem,\n    // see the comments at the top of this sketch for the proper connections.\n\n    Serial.println(\"BMP180 init fail\\n\\n\");\n    while(1); // Pause forever.\n  }\n}\n\nvoid loop()\n{\n  char status;\n  double T,P,p0,a;\n\n  // Loop here getting pressure readings every 10 seconds.\n\n  // If you want sea-level-compensated pressure, as used in weather reports,\n  // you will need to know the altitude at which your measurements are taken.\n  // We're using a constant called ALTITUDE in this sketch:\n\n  Serial.println();\n  Serial.print(\"provided altitude: \");\n  Serial.print(ALTITUDE,0);\n  Serial.print(\" meters, \");\n  Serial.print(ALTITUDE*3.28084,0);\n  Serial.println(\" feet\");\n\n  // If you want to measure altitude, and not pressure, you will instead need\n  // to provide a known baseline pressure. This is shown at the end of the sketch.\n\n  // You must first get a temperature measurement to perform a pressure reading.\n\n  // Start a temperature measurement:\n  // If request is successful, the number of ms to wait is returned.\n  // If request is unsuccessful, 0 is returned.\n\n  status = pressure.startTemperature();\n  if (status\u00a0!= 0)\n  {\n    // Wait for the measurement to complete:\n    delay(status);\n\n    // Retrieve the completed temperature measurement:\n    // Note that the measurement is stored in the variable T.\n    // Function returns 1 if successful, 0 if failure.\n\n    status = pressure.getTemperature(T);\n    if (status\u00a0!= 0)\n    {\n      // Print out the measurement:\n      Serial.print(\"temperature: \");\n      Serial.print(T,2);\n      Serial.print(\" deg C, \");\n      Serial.print((9.0/5.0)*T+32.0,2);\n      Serial.println(\" deg F\");\n\n      // Start a pressure measurement:\n      // The parameter is the oversampling setting, from 0 to 3 (highest res, longest wait).\n      // If request is successful, the number of ms to wait is returned.\n      // If request is unsuccessful, 0 is returned.\n\n      status = pressure.startPressure(3);\n      if (status\u00a0!= 0)\n      {\n        // Wait for the measurement to complete:\n        delay(status);\n\n        // Retrieve the completed pressure measurement:\n        // Note that the measurement is stored in the variable P.\n        // Note also that the function requires the previous temperature measurement (T).\n        // (If temperature is stable, you can do one temperature measurement for a number of pressure measurements.)\n        // Function returns 1 if successful, 0 if failure.\n\n        status = pressure.getPressure(P,T);\n        if (status\u00a0!= 0)\n        {\n          // Print out the measurement:\n          Serial.print(\"absolute pressure: \");\n          Serial.print(P,2);\n          Serial.print(\" mb, \");\n          Serial.print(P*0.0295333727,2);\n          Serial.println(\" inHg\");\n\n          // The pressure sensor returns abolute pressure, which varies with altitude.\n          // To remove the effects of altitude, use the sealevel function and your current altitude.\n          // This number is commonly used in weather reports.\n          // Parameters: P = absolute pressure in mb, ALTITUDE = current altitude in m.\n          // Result: p0 = sea-level compensated pressure in mb\n\n          p0 = pressure.sealevel(P,ALTITUDE); // we're at 1655 meters (Boulder, CO)\n          Serial.print(\"relative (sea-level) pressure: \");\n          Serial.print(p0,2);\n          Serial.print(\" mb, \");\n          Serial.print(p0*0.0295333727,2);\n          Serial.println(\" inHg\");\n\n          // On the other hand, if you want to determine your altitude from the pressure reading,\n          // use the altitude function along with a baseline pressure (sea-level or other).\n          // Parameters: P = absolute pressure in mb, p0 = baseline pressure in mb.\n          // Result: a = altitude in m.\n\n          a = pressure.altitude(P,p0);\n          Serial.print(\"computed altitude: \");\n          Serial.print(a,0);\n          Serial.print(\" meters, \");\n          Serial.print(a*3.28084,0);\n          Serial.println(\" feet\");\n        }\n        else Serial.println(\"error retrieving pressure measurement\\n\");\n      }\n      else Serial.println(\"error starting pressure measurement\\n\");\n    }\n    else Serial.println(\"error retrieving temperature measurement\\n\");\n  }\n  else Serial.println(\"error starting temperature measurement\\n\");\n\n  delay(5000);  // Pause for 5 seconds.\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The serial port will print out the corresponding information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-bright-led.html","title":"Crowbits-Bright LED","text":""},{"location":"Products/Crowbits/crowbits-bright-led.html#description","title":"Description","text":"<p>The bright LED is a digital output module, it\u2019s small but puts out a bright light. Which has a high brightness and large angle LED.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-bright-led.html#features","title":"Features","text":"<ul> <li>Can provide a strong light source for your project, lighting and etc</li> <li>Digital output module</li> </ul>"},{"location":"Products/Crowbits/crowbits-bright-led.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-bright-led.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an input module, such as Crowbits-Switch.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power, press the button of the self-locking switch, and the Bright LED will light up, otherwise, it will be off.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-button.html","title":"Crowbits-Button","text":""},{"location":"Products/Crowbits/crowbits-button.html#description","title":"Description","text":"<p>The button is a digital input module, it acts like a switch of a door. When you press it, the door opens. You can do an unlimited amount of projects using a button and it's definitely one of the most important modules.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-button.html#features","title":"Features","text":"<ul> <li>Momentary Button</li> <li>Digital input module</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-button.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-button.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When you press the button, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-buzzer.html","title":"Crowbits-Buzzer","text":""},{"location":"Products/Crowbits/crowbits-buzzer.html#description","title":"Description","text":"<p>The buzzer is a digital output module, it makes a sound when receives the signal. Typical uses of buzzer include alarm devices, timers, etc.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-buzzer.html#features","title":"Features","text":"<ul> <li>Easy to use the piezoelectric buzzer</li> <li>Digital output module</li> </ul>"},{"location":"Products/Crowbits/crowbits-buzzer.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Oscillation Frequency: (2.7 \u00b10.3) KHz</li> <li>Sound Pressure Level: \u226580dB</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-buzzer.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an input module, such as Crowbits-Switch.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p>3. Then, turn on the power, the buzzer will beep when you press the self-locking switch.</p> <p></p> <p>Note: Please tear off the paper on the buzzer when you want to use it for the buzzer to work properly. The paper on top is in order to protect it while shipping and transporting.</p>"},{"location":"Products/Crowbits/crowbits-collision-sensor.html","title":"Crowbits-Collision Sensor","text":""},{"location":"Products/Crowbits/crowbits-collision-sensor.html#description","title":"Description","text":"<p>The collision sensor is a digital input module, it is based on the collision component, which has high sensitivity and can detect any collision movement.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-collision-sensor.html#features","title":"Features","text":"<ul> <li>Digital input module</li> <li>Easy to use</li> <li>High sensitivity</li> </ul>"},{"location":"Products/Crowbits/crowbits-collision-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-collision-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When you hit the sensor with your hand, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-color-sensor.html","title":"Crowbits-Color Sensor","text":""},{"location":"Products/Crowbits/crowbits-color-sensor.html#description","title":"Description","text":"<p>This module is based on the color sensor TCS3414CS with digital output I2C. Based on the 8*2 array of filtered photodiodes and 16-bits analog-to-digital converters, you can gain the color chromaticity of ambient light or the color of objects. Of the 16 photodiodes, 4 have red filters, 4 have green filters, 4 have blue filters and 4 have no filter(clear). With the synchronization input pin, an external pulsed light source can provide precise synchronous conversion control.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-color-sensor.html#features","title":"Features","text":"<ul> <li>SYNC Input Synchronizes Integration Cycle to Modulated Light Sources</li> </ul>"},{"location":"Products/Crowbits/crowbits-color-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-color-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Download the library \u201cAdafruit_TCS34725-master\u201d. Unzip and put it in the libraries file of the Arduino IDE, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4.Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;Wire.h&gt;\n#include \"Adafruit_TCS34725.h\"\n\n// Pick analog outputs, for the UNO these three work well\n// use ~560  ohm resistor between Red &amp; Blue, ~1K for green (its brighter)\n#define redpin 2\n#define greenpin 4\n#define bluepin 6\n// for a common anode LED, connect the common pin to +5V\n// for common cathode, connect the common to ground\n\n// set to false if using a common cathode LED\n#define commonAnode true\n\n// our RGB -&gt; eye-recognized gamma color\nbyte gammatable[256];\n\n\nAdafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"Color View Test!\");\n\n  if (tcs.begin()) {\n    Serial.println(\"Found sensor\");\n  } else {\n    Serial.println(\"No TCS34725 found ... check your connections\");\n    while (1); // halt!\n  }\n\n  // use these three pins to drive an LED\n  pinMode(redpin, OUTPUT);\n  pinMode(greenpin, OUTPUT);\n  pinMode(bluepin, OUTPUT);\n\n  // thanks PhilB for this gamma table!\n  // it helps convert RGB colors to what humans see\n  for (int i=0; i&lt;256; i++) {\n    float x = i;\n    x /= 255;\n    x = pow(x, 2.5);\n    x *= 255;\n\n    if (commonAnode) {\n      gammatable[i] = 255 - x;\n    } else {\n      gammatable[i] = x;      \n    }\n    //Serial.println(gammatable[i]);\n  }\n}\n\n\nvoid loop() {\n  uint16_t clear, red, green, blue;\n\n  tcs.setInterrupt(false);      // turn on LED\n\n  delay(60);  // takes 50ms to read \n\n  tcs.getRawData(&amp;red, &amp;green, &amp;blue, &amp;clear);\n\n  tcs.setInterrupt(true);  // turn off LED\n\n  Serial.print(\"C:\\t\"); Serial.print(clear);\n  delay(1000);\n  Serial.print(\"\\tR:\\t\"); Serial.print(red);\n  delay(1000);\n  Serial.print(\"\\tG:\\t\"); Serial.print(green);\n  delay(1000);\n  Serial.print(\"\\tB:\\t\"); Serial.print(blue);\n  delay(1000);\n\n  // Figure out some basic hex code for visualization\n  uint32_t sum = clear;\n  float r, g, b;\n  r = red; r /= sum;\n  g = green; g /= sum;\n  b = blue; b /= sum;\n  r *= 256; g *= 256; b *= 256;\n  Serial.print(\"\\t\");\n  Serial.print((int)r, HEX); Serial.print((int)g, HEX); Serial.print((int)b, HEX);\n  Serial.println();\n\n  //Serial.print((int)r ); Serial.print(\" \"); Serial.print((int)g);Serial.print(\" \");  Serial.println((int)b );\n\n  analogWrite(redpin, gammatable[(int)r]);\n  analogWrite(greenpin, gammatable[(int)g]);\n  analogWrite(bluepin, gammatable[(int)b]);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Pointing the sensor at different colors will output different values. When facing different colors, the value of CRBG changes significantly.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-currentpower-sensor.html","title":"Crowbits-CurrentPower Sensor","text":""},{"location":"Products/Crowbits/crowbits-currentpower-sensor.html#description","title":"Description","text":"<p>The module can detect the size of the current in the circuit. By detecting the size of the current, you can learn about the power consumption of the circuit, the power of other meta-electronic devices and so on.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-currentpower-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-currentpower-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Measuring voltage range: DC 0-26V</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-currentpower-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board. An expansion module, such as Crowbits-Terminal board. There is also a power supply motherboard and a load motherboard.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, Crowbits-Terminal is connected behind it. The connection requirements are as follows.</p> <p>2.1. Connect the ground of the power supply main board and the ground of the load PCB board with a DuPont line.</p> <p>2.2. Connect the 5V output of the power supply motherboard to the positive terminal of the Crowbits-Current Power terminal with a DuPont cable.</p> <p>2.3. Connect the negative pole of the Crowbits-Current Power terminal to the 5V input end of the load PCB board with Dupont wire.</p> <p>2.4. Use a MINI USB cable to connect the external 5V power supply to the power supply PCB.</p> <p>2.5.Connect the GND on the Crowbits-Terminal board to the GND of the load motherboard with a DuPont cable.</p> <p></p> <p>3. Download the library \u201cINA219\u201d. Unzip and put it in the libraries file of the Arduino IDE, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;Adafruit_INA219.h&gt;\n\nAdafruit_INA219 ina219;\n\nvoid setup(void) \n{\n  Serial.begin(9600);\n  while (!Serial) {\n      // will pause Zero, Leonardo, etc until serial console opens\n      delay(1);\n  }\n\n  uint32_t currentFrequency;\n\n  Serial.println(\"Hello!\");\n\n  // Initialize the INA219.\n  // By default the initialization will use the largest range (32V, 2A).  However\n  // you can call a setCalibration function to change this range (see comments).\n  ina219.begin();\n  // To use a slightly lower 32V, 1A range (higher precision on amps):\n  //ina219.setCalibration_32V_1A();\n  // Or to use a lower 16V, 400mA range (higher precision on volts and amps):\n  //ina219.setCalibration_16V_400mA();\n\n  Serial.println(\"Measuring voltage and current with INA219 ...\");\n}\n\nvoid loop(void) \n{\n  float shuntvoltage = 0;\n  float busvoltage = 0;\n  float current_mA = 0;\n  float loadvoltage = 0;\n\n  shuntvoltage = ina219.getShuntVoltage_mV();\n  busvoltage = ina219.getBusVoltage_V();\n  current_mA = ina219.getCurrent_mA();\n  loadvoltage = busvoltage + (shuntvoltage / 1000);\n\n  Serial.print(\"Bus Voltage:   \"); Serial.print(busvoltage); Serial.println(\" V\");\n  Serial.print(\"Shunt Voltage: \"); Serial.print(shuntvoltage); Serial.println(\" mV\");\n  Serial.print(\"Load Voltage:  \"); Serial.print(loadvoltage); Serial.println(\" V\");\n  Serial.print(\"Current:       \"); Serial.print(current_mA); Serial.println(\" mA\");\n  Serial.println(\"\");\n\n  delay(2000);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The serial port will print out the voltage, current, and power values, as shown in the figure:</p> <p></p>"},{"location":"Products/Crowbits/crowbits-dc-motor.html","title":"Crowbits-DC Motor","text":""},{"location":"Products/Crowbits/crowbits-dc-motor.html#description","title":"Description","text":"<p>The DC motor is a digital output module, it\u2019s a rotary electrical machine that converts direct current electrical energy into mechanical energy. Use the DC motor, you can make your projects spin, turn and twist.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-dc-motor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-dc-motor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-dc-motor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an input module, such as Crowbits-Button.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Turn on the power.</p> <p>1)Set the toggle switch on the DC Motor board to F, when you press and hold the button, you can see that the DC motor is rotating forward;</p> <p>2)Set the toggle switch on the DC Motor board to R, when you press and hold the button, you can see the DC motor reverse.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-dht11-sensor.html","title":"Crowbits-DHT11 Sensor","text":""},{"location":"Products/Crowbits/crowbits-dht11-sensor.html#description","title":"Description","text":"<p>Temperature and humidity sensors refer to devices or devices that can convert temperature and humidity into electrical signals that can be easily measured and processed.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-dht11-sensor.html#features","title":"Features","text":"<ul> <li>Digital reading accuracy</li> </ul>"},{"location":"Products/Crowbits/crowbits-dht11-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type\uff1aGPIO</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-dht11-sensor.html#application-ideas","title":"Application Ideas","text":"<p>Display test information</p>"},{"location":"Products/Crowbits/crowbits-dht11-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A0 interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library Crowbits-DHT11 Sensor library. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>// Example testing sketch for various DHT humidity/temperature sensors\n// Written by ladyada, public domain\n\n#include \"DHT.h\"\n\n#define DHTPIN A0     // what pin we're connected to\n\n// Uncomment whatever type you're using!\n#define DHTTYPE DHT11   // DHT 11 \n//#define DHTTYPE DHT22   // DHT 22  (AM2302)\n//#define DHTTYPE DHT21   // DHT 21 (AM2301)\n\n// Connect pin 1 (on the left) of the sensor to +5V\n// Connect pin 2 of the sensor to whatever your DHTPIN is\n// Connect pin 4 (on the right) of the sensor to GROUND\n// Connect a 10K resistor from pin 2 (data) to pin 1 (power) of the sensor\n\nDHT dht(DHTPIN, DHTTYPE);\n\nvoid setup() \n{\n    Serial.begin(9600); \n    Serial.println(\"DHTxx test!\");\n\n    dht.begin();\n}\n\nvoid loop() \n{\n    // Reading temperature or humidity takes about 250 milliseconds!\n    // Sensor readings may also be up to 2 seconds 'old' (its a very slow sensor)\n    float h = dht.readHumidity();\n    float t = dht.readTemperature();\n\n    // check if returns are valid, if they are NaN (not a number) then something went wrong!\n    if (isnan(t) || isnan(h)) \n    {\n        Serial.println(\"Failed to read from DHT\");\n    } \n    else \n    {\n        Serial.print(\"Humidity: \"); \n        Serial.print(h);\n        Serial.print(\"\u00a0%\\t\");\n        Serial.print(\"Temperature: \"); \n        Serial.print(t);\n        Serial.println(\" *C\");\n    }\n}\n</code></pre> <p>5.After the code is uploaded successfully, Open the debug window and observe the displayed humidity and temperature.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-dht20.html","title":"Crowbits-DHT20","text":""},{"location":"Products/Crowbits/crowbits-dht20.html#description","title":"Description","text":"<p>DHT20 is an intelligent temperature and humidity sensor module that can convert temperature and humidity into electrical signals to easily measure temperature and humidity. The module is equipped with a newly designed ASIC dedicated chip, an improved MEMS semiconductor capacitive humidity sensor element and a standard temperature sensor element. After comprehensive improvement, DHT20 reduces power consumption and cost, while greatly improving measurement accuracy, power supply voltage, measurement range, response time, stability, etc.; it has the characteristics of no calibration, low power consumption, high accuracy, and high stability. Using fully calibrated digital I2C communication interface, it has fast response, strong anti-interference ability and high cost performance.</p> <p> </p>"},{"location":"Products/Crowbits/crowbits-dht20.html#technical-specifications","title":"Technical specifications","text":"<p>Working voltage: DC2.2V+5.5V</p> <p>Measuring range</p> <ul> <li>Humidity: 0%-100% RH</li> <li>Temperature: -40~80\u00b0C</li> </ul> <p>Error range</p> <ul> <li>Humidity: \u00b13% RH</li> <li>Temperature: \u00b10.5\u00b0C</li> </ul> <p>Resolution</p> <ul> <li>Humidity: \u00b10.024% RH</li> <li>Temperature: 0.01\u00b0C</li> </ul> <p>Response time</p> <ul> <li>Humidity: \u03c463% condition is less than 8 seconds</li> <li>Temperature: \u03c463% condition mini5 seconds, max30 seconds</li> </ul> <p>Interface type: I2C Size: 31.5 (L)*24.5(W)*13(H)mm</p>"},{"location":"Products/Crowbits/crowbits-dht20.html#application-scenarios","title":"Application scenarios","text":"<p>Test environment temperature and humidity information</p>"},{"location":"Products/Crowbits/crowbits-dht20.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A4 and A5 interface on the Crowbits-UNO board, as shown in the figure below:</p> <p> </p> <p>3. Download the Crowbit-DHT20 software file and unzip it and place it in the libraries folder of the Arduino IDE. Run Arduino.exe, Open path: Crowtail-DHT20 --&gt; examples --&gt; DHT20 --&gt; DHT20.ino</p> <pre><code>#include &lt;DHT20.h&gt;\n/*!\n * @brief Construct the function\n * @param pWire IC bus pointer object and construction device, can both pass or not pass parameters, Wire in default.\n * @param address Chip IIC address, 0x38 in default.\n */\nDHT20  dht20;\nvoid setup()\n{\n  Serial.begin(115200);\n  //Initialize sensor\n  while(dht20.begin())\n{\n    Serial.println(\"Initialize sensor failed\");\n    delay(1000);\n   }\n}\n\nvoid loop()\n{\n  //Get ambient temperature\n  Serial.print(\"temperature:\"); Serial.print(dht20.getTemperature());Serial.print(\"\u2103\");\n  //Get relative humidity\n  Serial.print(\"  humidity:\"); Serial.print(dht20.getHumidity()*100);Serial.println(\" %RH\");\n    delay(1000);\n}\n</code></pre> <p>4. Upload it to your Crowbits-UNO board, open the COM serial port, select 115200 for the baud rate at the bottom right, and the monitor displays the current environmental temperature and relative humidity information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-digital-display.html","title":"Crowbits-Digital Display","text":""},{"location":"Products/Crowbits/crowbits-digital-display.html#description","title":"Description","text":"<p>The nixie tube is composed of four 7-segment nixie tubes. Each 7-segment nixie tube can display a number. It can display all the parameters that can be represented by numbers, such as time, date, and temperature. The module has an LED driver chip TM1650, which can communicate through the I2C interface. When the module receives data, it is encoded by TM1650 and sent to the digital display.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-digital-display.html#features","title":"Features","text":"<ul> <li>4-digit red alpha-numeric display</li> </ul>"},{"location":"Products/Crowbits/crowbits-digital-display.html#specification","title":"Specification","text":"<ul> <li>Interface Type\uff1aI2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-digital-display.html#application-ideas","title":"Application Ideas","text":"<ul> <li>Time display</li> <li>Stopwatch</li> </ul>"},{"location":"Products/Crowbits/crowbits-digital-display.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of digital display.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library Crowbits-Digital Display library. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*\n  Demo code of P21 - 4 Digital 7-Segment LED with Time Separator\n  by maker studio\n*/\n#include \"TM1650.h\"\n#include &lt;inttypes.h&gt;\nstatic uint8_t TubeTab[] = {\n               0x3F,0x06,0x5B,0x4F,\n               0x66,0x6D,0x7D,0x07,\n               0x7F,0x6F,0x77,0x7C,\n               0x39,0x5E,0x79,0x71,   \n               };//0~9,A,B,C,D,E,F  \nstatic uint8_t TubeTabwithPoit[] = {\n               0xBF,0x86,0xDB,0xCF,\n               0xE6,0xED,0xFD,0x87,\n               0xFF,0xEF   \n               };//0~9  \nTM1650 DigitalLED(A5,A4);\nint8_t number[] = {0,0,0,0};\nvoid setup()\n{\n  //Serial.begin(9600);\n}\n\nvoid loop()\n{\n    DigitalLED.clearDisplay();\n     delay(1000);\n     DigitalLED.display(0,TubeTab[1]);\n     DigitalLED.display(1,TubeTab[2]);\n     DigitalLED.display(2,TubeTab[3]);\n     DigitalLED.display(3,TubeTab[4]);\n     delay(1000);\n     DigitalLED.clearDisplay();\n     delay(100);\n     DigitalLED.display(0,TubeTabwithPoit[5]);\n     DigitalLED.display(1,TubeTabwithPoit[6]);\n     DigitalLED.display(2,TubeTabwithPoit[7]);\n     DigitalLED.display(3,TubeTabwithPoit[8]);\n     delay(1000);\n}\n</code></pre> <p>5. After the code is uploaded successfully, you will see the following display on the digital tube.</p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-digital-light-sensor.html","title":"Crowbits-Digital Light Sensor","text":""},{"location":"Products/Crowbits/crowbits-digital-light-sensor.html#description","title":"Description","text":"<p>This module is based on the I2C light-to-digital converter TSL2561 to transform light intensity to a digital signal. Different from traditional analog light sensor, this digital module features a selectable light spectrum range due to its dual light sensitive diodes: infrared and full spectrum.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-digital-light-sensor.html#features","title":"Features","text":"<ul> <li>Programmable interrupt function with User-Defined Upper and lower threshold settings</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-digital-light-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-digital-light-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cDigital_Light_Sensor\u201d. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*\n * Digital_Light_Sensor.ino\n * A library for TSL2561\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include &lt;Wire.h&gt;\n#include &lt;Digital_Light_TSL2561.h&gt;\nvoid setup()\n{\n  Wire.begin();\n  Serial.begin(9600);\n  TSL2561.init();\n}\n\nvoid loop()\n{\n  Serial.print(\"The Light value is: \");\n  Serial.println(TSL2561.readVisibleLux());\n  delay(1000);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The stronger the light, the greater the output value, as shown in the figure:</p> <p></p>"},{"location":"Products/Crowbits/crowbits-digital-potentiometer.html","title":"Crowbits-Digital Potentiometer","text":""},{"location":"Products/Crowbits/crowbits-digital-potentiometer.html#description","title":"Description","text":"<p>The high-precision digital adjustable potentiometer is a potentiometer that can be adjusted by digital signals. It functions like a linear potentiometer. It controls the circuit by adjusting the resistance value in the circuit, but here it is controlled by digital signals.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-digital-potentiometer.html#features","title":"Features","text":"<ul> <li>Digital and Programmable</li> <li>High resistance resolution</li> <li>Temperature compensation</li> </ul>"},{"location":"Products/Crowbits/crowbits-digital-potentiometer.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-digital-potentiometer.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board. 2 digital input modules, such as Crowbits-Button and Crowbits-touch sensor. 1 digital output module, such as Crowbits-LED.</p> <p>2. Connect the Crowbits-Digital Potentiometer to the D2 and D3 interface. The keys are connected to the D5 and D10 interfaces respectively. And the Crowbits-LED is connected to the SIG_OUT pin on Crowbits-Digital Potentiometer board.</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#define dig_INC 3\n#define dig_UD  2\n#define key_INC 5\n#define key_UD 10\n\nint dig_UD_status = HIGH;\nint n;\n\nvoid setup()\n{\n  pinMode(dig_INC, OUTPUT);\n  pinMode(dig_UD, OUTPUT);\n  pinMode(key_INC, INPUT);\n  pinMode(key_UD, INPUT);\n  Serial.begin(9600);\n  init_digital_potentiometer(); //\u521d\u59cb\u5316\n}\n\n\nvoid loop()\n{\n  if (digitalRead(key_INC) == HIGH)\n  {\n    delay(10);\n    if (digitalRead(key_INC) == HIGH)\n    {\n      dig_UD_status = !dig_UD_status;\n      digitalWrite(dig_UD, dig_UD_status);\n      delay(1);\n      Serial.print(\"Status key pressed,\");\n      if (dig_UD_status == HIGH)\n      {\n        Serial.println(\"The current status is increased:\");\n      }\n      else\n      {\n        Serial.println(\"The current status is reduced:\");\n      }\n      while (digitalRead(key_INC) == HIGH);\n    }\n  }\n  if (digitalRead(key_UD) == HIGH)\n  {\n    delay(10);\n    if (digitalRead(key_UD) == HIGH)\n    {\n      for (n = 20; n &gt;= 0; n--)\n      {\n        digitalWrite(dig_INC, LOW);\n        delay(2);\n        digitalWrite(dig_INC, HIGH);\n        delay(2);\n      }\n      while (digitalRead(key_UD) == HIGH);\n    }\n  }\n}\n\nvoid init_digital_potentiometer()\n{\n  int i;\n  for (i = 100; i &gt;= 0; i--)\n  {\n    digitalWrite(dig_INC, LOW);\n    delay(1);\n    digitalWrite(dig_INC, HIGH);\n  }\n  digitalWrite(dig_UD, HIGH);\n  delay(1);\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600.</p> <ul> <li> <p>When you press the button connected to the D5 port, the current status of serial port printing is increased, and then press the button connected to the D10 port, the LED light will gradually turn on.</p> </li> <li> <p>When you press the button connected to the D5 port, the current status of the serial port printing is reduced, and then press the button connected to the D10 port, the LED light will gradually dim.</p> </li> </ul> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-eeprom.html","title":"Crowbits-EEPROM","text":""},{"location":"Products/Crowbits/crowbits-eeprom.html#description","title":"Description","text":"<p>If you need to do some data storage in Arduino but found that the EEPROM in ATmega chip too limited, then this Crowbits-EEPROM is your best choice. This module is based on the EEPROM chip AT24C256, which has 256k bit capacity. It communicates with Arduino with I2C bus, helps you do much more data storage easily.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-eeprom.html#features","title":"Features","text":"<ul> <li>Onboard chip AT24C256 chip</li> <li>Data is not lost when power off</li> </ul>"},{"location":"Products/Crowbits/crowbits-eeprom.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-eeprom.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;Wire.h&gt;\n#define EEPROM_ADDR 0x50           // I2C Buss address of 24LC256 256K EEPROM\n\nvoid setup()\n{\n  Wire.begin();                        // join I2C bus (address optional for master)\n  Serial.begin(9600);\n\n  // TESTS FOR EACH FUNCTION BEGIN HERE\n  Serial.println(\"Writing Test:\");\n  for (int i=0; i&lt;20; i++){            // loop for first 20 slots\n    i2c_eeprom_write_byte(EEPROM_ADDR,i,i+65);   // write address + 65 A or 97 a\n    Serial.print(\". \");\n    delay(10);                         // NEED THIS DELAY!\n  }\n  Serial.println(\"\");\n  delay(500);\n\n  Serial.println(\"Reading Test:\");\n  for (int i=0; i&lt;20; i++){            // loop for first 20 slots\n    Serial.write(i2c_eeprom_read_byte(EEPROM_ADDR, i));\n    Serial.print(\" \");\n  }\n\n  // setup for page tests . . .\n  byte PageData[30];                   // array that will hold test data for a page\n  byte PageRead[30];                   // array that will hold result of data for a page\n  for (int i=0; i&lt;30; i++){            // zero both arrays for next test\n    PageData[i] = 0;\n    PageRead[i] = 0;\n  }\n  Serial.println(\"\");\n  for (int i=0; i&lt;30; i++) PageData[i] = i+33;  // fill up array for next test char 33 =\u00a0!\n\n  Serial.println(\"Writing Page Test:\");\n  i2c_eeprom_write_page(EEPROM_ADDR, 100, PageData, 28 ); // 28 bytes/page is max\n\n  Serial.println(\"Reading Page Test:\");\n  i2c_eeprom_read_buffer( EEPROM_ADDR, 100, PageRead, 28);\n  for (int i=0; i&lt;28; i++){\n    Serial.write(PageRead[i]);    // display the array read\n    Serial.print(\" \");\n  }\n}\n\nvoid loop()\n{\n}\n\nvoid i2c_eeprom_write_byte( int deviceaddress, unsigned int eeaddress, byte data )\n{\n  int rdata = data;\n  Wire.beginTransmission(deviceaddress);\n  Wire.write((int)(eeaddress &gt;&gt; 8));    // Address High Byte\n  Wire.write((int)(eeaddress &amp; 0xFF));  // Address Low Byte\n  Wire.write(rdata);\n  Wire.endTransmission();\n}\n\n// Address is a page address, 6-bit (63). More and end will wrap around\n// But data can be maximum of 28 bytes, because the Wire library has a buffer of 32 bytes\nvoid i2c_eeprom_write_page\n( int deviceaddress, unsigned int eeaddresspage, byte* data, byte length )\n{\n  Wire.beginTransmission(deviceaddress);\n  Wire.write((int)(eeaddresspage &gt;&gt; 8)); // Address High Byte\n  Wire.write((int)(eeaddresspage &amp; 0xFF)); // Address Low Byte\n  byte c;\n  for ( c = 0; c &lt; length; c++)\n    Wire.write(data[c]);\n  Wire.endTransmission();\n  delay(10);                           // need some delay\n}\n\nbyte i2c_eeprom_read_byte( int deviceaddress, unsigned int eeaddress )\n{\n  byte rdata = 0xFF;\n  Wire.beginTransmission(deviceaddress);\n  Wire.write((int)(eeaddress &gt;&gt; 8));    // Address High Byte\n  Wire.write((int)(eeaddress &amp; 0xFF));  // Address Low Byte\n  Wire.endTransmission();\n  Wire.requestFrom(deviceaddress,1);\n  if (Wire.available()) rdata = Wire.read();\n  return rdata;\n}\n\n// should not read more than 28 bytes at a time!\nvoid i2c_eeprom_read_buffer( int deviceaddress, unsigned int eeaddress, byte *buffer, int length )\n{\n  Wire.beginTransmission(deviceaddress);\n  Wire.write((int)(eeaddress &gt;&gt; 8));    // Address High Byte\n  Wire.write((int)(eeaddress &amp; 0xFF));  // Address Low Byte\n  Wire.endTransmission();\n  Wire.requestFrom(deviceaddress,length);\n  //int c = 0;\n  for ( int c = 0; c &lt; length; c++ )\n    if (Wire.available()) buffer[c] = Wire.read();\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600, you can see the following print information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-electromagnet.html","title":"Crowbits-Electromagnet","text":""},{"location":"Products/Crowbits/crowbits-electromagnet.html#description","title":"Description","text":"<p>The electromagnet is a digital output module, it is a type of magnet in which the magnetic field is produced by an electric current. Equipped with this feature, you can make a mini device for picking up and moving magnetic material.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-electromagnet.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-electromagnet.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-electromagnet.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an input module, such as Crowbits-Switch.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Turn on the power. When you press the button of the self-locking switch, the LED of Crowbits-Electromagnet board will light up.</p> <p>4. Then let it absorb the magnetic screw, and you'll see that the screw attaches to the electromagnet. When you release the self-locking switch, the screw on the electromagnet will fall off.</p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-encoder.html","title":"Crowbits-Encoder","text":""},{"location":"Products/Crowbits/crowbits-encoder.html#description","title":"Description","text":"<p>The rotary encoder can convert the angular displacement and linear Displacement to the electrical signal, and then convert the electrical signal to the electrical pulse. The numbers of the pulse can be converted to the value of the angular displacement. There are two output pins of this module including signal A and signal B. We can determine the position of the detent and the direction of the rotation by sense the value of the output pins.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-encoder.html#features","title":"Features","text":"<ul> <li>Incremental encoder</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-encoder.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-encoder.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module. 1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board. 2.Connect the module to the D2 and D3 interface of the Crowbits-UNO board, as shown in the figure: 3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>#define ENCODER_A_PIN 2\n#define ENCODER_B_PIN 3\nlong position;\n\nvoid setup(){\n\n  pinMode(ENCODER_A_PIN, INPUT);\n  pinMode(ENCODER_B_PIN, INPUT);\n  attachInterrupt(0, read_quadrature, CHANGE);\n  Serial.begin(9600);\n}\n\nvoid loop(){\n   Serial.print(\"Position: \");\n   Serial.println(position, DEC);\n   delay(1000);\n}\n\nvoid read_quadrature(){  \n\n  if (digitalRead(ENCODER_A_PIN) == LOW){   \n    //Check clockwise or counterclockwise\n    if (digitalRead(ENCODER_B_PIN) == LOW)\n      position++;\n  }\n\n  else{ \n    if (digitalRead(ENCODER_B_PIN) == LOW)\n      position--;\n  }\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Rotate the encoder, the serial port will print out the position information, as shown in the figure:</p>"},{"location":"Products/Crowbits/crowbits-expansion.html","title":"Crowbits-Expansion","text":""},{"location":"Products/Crowbits/crowbits-expansion.html#description","title":"Description","text":"<p>The expansion module is used to expand the signal pins of other modules.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-expansion.html#features","title":"Features","text":"<ul> <li>Expand signal pin</li> </ul>"},{"location":"Products/Crowbits/crowbits-expansion.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-expansion.html#usage","title":"Usage","text":"<p>1.Control the motor forward and reverse through 2 buttons</p> <p>1)You also need to prepare a power module, such as Crowbits-Power Supply. An output module, such as Crowbits-DC Motor. Two input modules, such as Crowbits-Touch Sensor and Crowbits-Switch.</p> <p>2)The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3)Turn on the power. You could touch the touch sensor to control the motor to rotate forward, or press the self-locking switch to control the motor to reverse.</p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-flame-sensor.html","title":"Crowbits-Flame Sensor","text":""},{"location":"Products/Crowbits/crowbits-flame-sensor.html#description","title":"Description","text":"<p>The flame sensor is a digital input module, it\u2019s designed to detect the flame, which is widely used in a flame detection device.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-flame-sensor.html#features","title":"Features","text":"<ul> <li>Digital input module</li> <li>Easy to use</li> <li>High sensitivity</li> </ul>"},{"location":"Products/Crowbits/crowbits-flame-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-flame-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the sensor detects flame, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-g1-4-water-flow-sensor.html","title":"Crowbits-G1-4 Water Flow Sensor","text":""},{"location":"Products/Crowbits/crowbits-g1-4-water-flow-sensor.html#description","title":"Description","text":"<p>Water flow sensor consists of magnetic core, rotating impeller, external casing and sensor and a hall-effect sensor. When water flows through the rotor, rotor rolls, it activates the magnetic core to trigger switch action speed changes with different rate of flow. The hall-effect sensor outputs the corresponding pulse signals, users can get the flow speed via detecting the pulse. It is suitable to detect flow in water dispenser or coffee machine</p> <p></p>"},{"location":"Products/Crowbits/crowbits-g1-4-water-flow-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-g1-4-water-flow-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Operating Temperature: \u226480\u2103</li> <li>Liquid Temperature: \u2264120\u2103</li> <li>Operating Humidity: 35%\uff5e90%RH</li> <li>Water Pressure: \u22642.0MPa</li> <li>Storage Temperature: -25\uff5e+ 80\u2103</li> <li>Storage Humidity: 25%\uff5e95%RH</li> </ul>"},{"location":"Products/Crowbits/crowbits-g1-4-water-flow-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the D2 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>// reading liquid flow rate using Crowduino and Water Flow Sensor\n\nvolatile int NbTopsFan; //measuring the rising edges of the signal\nint Calc;                               \nint WaterFlowsensor = 2;    //The pin location of the sensor\n\nvoid rpm ()     //This is the function that the interupt calls \n{ \n  NbTopsFan++;  //This function measures the rising and falling edge of the hall effect sensors signal\n} \nvoid setup() \n{ \n  pinMode(WaterFlowsensor, INPUT); //initializes digital pin 2 as an input\n  Serial.begin(9600); //This is the setup function where the serial port is initialised,\n  attachInterrupt(0, rpm, RISING); //and the interrupt is attached\n} \n// the loop() method runs over and over again,\n// as long as the Arduino has power\nvoid loop ()    \n{\n  NbTopsFan = 0;   //Set NbTops to 0 ready for calculations\n  sei();          //Enables interrupts\n  delay (1000);   //Wait 1 second\n  cli();      //Disable interrupts\n  Calc = (NbTopsFan * 60 / 73); //(Pulse frequency x 60) / 73Q, = flow rate in L/hour \n  Serial.print (Calc, DEC); //Prints the number calculated above\n  Serial.print (\" L/hour\\r\\n\"); //Prints \"L/hour\" and returns a  new line\n}\n</code></pre> <p>4.After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The serial port will print out the current water flow.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-gas-sensor.html","title":"Crowbits-Gas Sensor","text":""},{"location":"Products/Crowbits/crowbits-gas-sensor.html#description","title":"Description","text":"<p>This module is a converter that converts a gas integral number into a corresponding electrical signal. It mainly uses the chemical potential difference between two electrodes. One electrode measures the gas concentration in the gas, and the other electrode is a fixed reference electrode When the concentration of a certain measured gas exceeds the standard, the concentration value will be higher than the electrical signal of the reference electrode, and the module will output the corresponding concentration value effect.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-gas-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-gas-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: Analog input</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-gas-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>void setup() \n{\n  Serial.begin(9600);\n}\n\nvoid loop() \n{\n  float sensor_volt;\n  float sensorValue;\n\n  sensorValue = analogRead(A2);\n  sensor_volt = sensorValue / 1024 * 5.0;\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n  delay(1000);\n}\n</code></pre> <p>4.After the upload is successful, open the serial port monitor, the baud rate is set to 9600.When gas is detected, the voltage value output by the serial port will change.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-gesture-sensor.html","title":"Crowbits-Gesture Sensor","text":""},{"location":"Products/Crowbits/crowbits-gesture-sensor.html#description","title":"Description","text":"<p>The sensor on Crowbits-Gesture is PAJ7620U2 that integrates gesture recognition function with general I2C interface into a single chip. It can recognize 9 basic gestures, and these gestures information can be simply accessed via the I2C bus. You can use Gesture as an input device to control another module, or a computer, mobile phone, smart car, robot, and more with a simple swipe of your hand.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-gesture-sensor.html#features","title":"Features","text":"<ul> <li>Built-in proximity detection</li> </ul>"},{"location":"Products/Crowbits/crowbits-gesture-sensor.html#specification","title":"Specification","text":"<ul> <li>Gesture speed in Normal Mode: 60\u00b0/s to 600\u00b0/s</li> <li>Ambient light immunity: &lt; 100k Lux</li> <li>Gesture speed in Gaming Mode: 60\u00b0/s to 1200\u00b0/s</li> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-gesture-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Download the library \u201cPaj7620\u201d. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4.Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*\n * Copyright (c) 2015 seeed technology inc.\n * Website    : www.seeed.cc\n * Author     : Wuruibin\n * Modified Time: June 2015\n * Description: This demo can recognize 9 gestures and output the result, including move up, move down, move left, move right,\n *              move forward, move backward, circle-clockwise, circle-counter clockwise, and wave.\n * \n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n#include &lt;Wire.h&gt;\n#include \"paj7620.h\"\n\n/* \nNotice: When you want to recognize the Forward/Backward gestures, your gestures' reaction time must less than GES_ENTRY_TIME(0.8s). \n        You also can adjust the reaction time according to the actual circumstance.\n*/\n#define GES_REACTION_TIME       500             // You can adjust the reaction time according to the actual circumstance.\n#define GES_ENTRY_TIME          800             // When you want to recognize the Forward/Backward gestures, your gestures' reaction time must less than GES_ENTRY_TIME(0.8s). \n#define GES_QUIT_TIME           1000\n\nvoid setup()\n{\n    uint8_t error = 0;\n\n    Serial.begin(9600);\n    Serial.println(\"\\nPAJ7620U2 TEST DEMO: Recognize 9 gestures.\");\n\n    error = paj7620Init();          // initialize Paj7620 registers\n    if (error) \n    {\n        Serial.print(\"INIT ERROR,CODE:\");\n        Serial.println(error);\n    }\n    else\n    {\n        Serial.println(\"INIT OK\");\n    }\n    Serial.println(\"Please input your gestures:\\n\");\n}\n\nvoid loop()\n{\n    uint8_t data = 0, data1 = 0, error;\n\n    error = paj7620ReadReg(0x43, 1, &amp;data);             // Read Bank_0_Reg_0x43/0x44 for gesture result.\n    if (!error) \n    {\n        switch (data)                                   // When different gestures be detected, the variable 'data' will be set to different values by paj7620ReadReg(0x43, 1, &amp;data).\n        {\n            case GES_RIGHT_FLAG:\n                delay(GES_ENTRY_TIME);\n                paj7620ReadReg(0x43, 1, &amp;data);\n                if(data == GES_FORWARD_FLAG) \n                {\n                    Serial.println(\"Forward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else if(data == GES_BACKWARD_FLAG) \n                {\n                    Serial.println(\"Backward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else\n                {\n                    Serial.println(\"Right\");\n                }          \n                break;\n            case GES_LEFT_FLAG: \n                delay(GES_ENTRY_TIME);\n                paj7620ReadReg(0x43, 1, &amp;data);\n                if(data == GES_FORWARD_FLAG) \n                {\n                    Serial.println(\"Forward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else if(data == GES_BACKWARD_FLAG) \n                {\n                    Serial.println(\"Backward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else\n                {\n                    Serial.println(\"Left\");\n                }          \n                break;\n            case GES_UP_FLAG:\n                delay(GES_ENTRY_TIME);\n                paj7620ReadReg(0x43, 1, &amp;data);\n                if(data == GES_FORWARD_FLAG) \n                {\n                    Serial.println(\"Forward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else if(data == GES_BACKWARD_FLAG) \n                {\n                    Serial.println(\"Backward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else\n                {\n                    Serial.println(\"Up\");\n                }          \n                break;\n            case GES_DOWN_FLAG:\n                delay(GES_ENTRY_TIME);\n                paj7620ReadReg(0x43, 1, &amp;data);\n                if(data == GES_FORWARD_FLAG) \n                {\n                    Serial.println(\"Forward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else if(data == GES_BACKWARD_FLAG) \n                {\n                    Serial.println(\"Backward\");\n                    delay(GES_QUIT_TIME);\n                }\n                else\n                {\n                    Serial.println(\"Down\");\n                }          \n                break;\n            case GES_FORWARD_FLAG:\n                Serial.println(\"Forward\");\n                delay(GES_QUIT_TIME);\n                break;\n            case GES_BACKWARD_FLAG:       \n                Serial.println(\"Backward\");\n                delay(GES_QUIT_TIME);\n                break;\n            case GES_CLOCKWISE_FLAG:\n                Serial.println(\"Clockwise\");\n                break;\n            case GES_COUNT_CLOCKWISE_FLAG:\n                Serial.println(\"anti-clockwise\");\n                break;  \n            default:\n                paj7620ReadReg(0x44, 1, &amp;data1);\n                if (data1 == GES_WAVE_FLAG) \n                {\n                    Serial.println(\"wave\");\n                }\n                break;\n        }\n    }\n    delay(100);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. When you gesture to the sensor, the serial port will print out the corresponding gesture, as shown in the figure.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-gps.html","title":"Crowbits-GPS","text":""},{"location":"Products/Crowbits/crowbits-gps.html#description","title":"Description","text":"<p>GPS is a high-precision radio navigation positioning system based on aerial satellites. It can provide accurate geographic location, vehicle speed and accurate time information anywhere in the world and near-Earth space.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-gps.html#features","title":"Features","text":"<ul> <li>Low power consumption</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-gps.html#specification","title":"Specification","text":"<ul> <li>Interface Type: UART</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-gps.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the D2 and D3 interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>//at 9600 bps 8-N-1\n//Computer is connected to Arduino/Crowduino\n//SoftSerial Shield is connected to the Software UART:D2&amp;D3 \n\n#include &lt;SoftwareSerial.h&gt;\n\nSoftwareSerial SoftSerial(2, 3);\nunsigned char buffer[256]; // buffer array for data recieve over serial port\nint count=0;     // counter for buffer array \nvoid setup()\n{\n  SoftSerial.begin(9600);               // the SoftSerial baud rate   \n  Serial.begin(9600);             // the Serial port of Arduino baud rate.\n\n}\n\nvoid loop()\n{\n  if (SoftSerial.available())              // if date is comming from softwareserial port ==&gt; data is comming from SoftSerial shield\n  {\n    while(SoftSerial.available())          // reading data into char array \n    {\n      buffer[count++]=SoftSerial.read();     // writing data into array\n      if(count == 256)break;\n  }\n    Serial.write(buffer,count);            // if no data transmission ends, write buffer to hardware serial port\n    clearBufferArray();              // call clearBufferArray function to clear the storaged data from the array\n    count = 0;                       // set counter of while loop to zero\n  }\n  if (Serial.available())            // if data is available on hardwareserial port ==&gt; data is comming from PC or notebook\n    SoftSerial.write(Serial.read());       // write it to the SoftSerial shield\n}\nvoid clearBufferArray()              // function to clear buffer array\n{\n  for (int i=0; i&lt;count;i++)\n    { buffer[i]=NULL;}                  // clear all index of array with command NULL\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The serial port will print the GPS address information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-grayscale-sensor.html","title":"Crowbits-Grayscale Sensor","text":""},{"location":"Products/Crowbits/crowbits-grayscale-sensor.html#description","title":"Description","text":"<p>The grayscale sensor is an analog sensor. The gray-scale sensor uses different detection colors to reflect different levels of light, and the photoresistor uses different principles to detect the color depth of light returned by different detection surfaces. It is used to distinguish black from other colors when the ambient light interference is not very serious.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-grayscale-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-grayscale-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: Analog input</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-grayscale-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A2 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>void setup()\n{\n  Serial.begin(9600); // open serial port, set the baud rate to 9600 bps\n}\nvoid loop()\n{\n      int val;\n      val=analogRead(A2);   //connect grayscale sensor to Analog 0\n      Serial.println(val,DEC);//print the value to serial        \n      delay(1000);\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. When you point the sensor at a white surface object and a black surface object, the value printed by the serial port is not different.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-hall-sensor.html","title":"Crowbits-Hall Sensor","text":""},{"location":"Products/Crowbits/crowbits-hall-sensor.html#description","title":"Description","text":"<p>The hall sensor is a digital input module that is used to measure the magnitude of a magnetic field, it converts the change of magnetic field into a change in output voltage.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-hall-sensor.html#features","title":"Features","text":"<ul> <li>Digital input module</li> <li>Easy to use</li> <li>High sensitivity</li> </ul>"},{"location":"Products/Crowbits/crowbits-hall-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-hall-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the sensor detects N polar magnetic field, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-htu21d-humiture-sensor.html","title":"Crowbits-HTU21D Humiture Sensor","text":""},{"location":"Products/Crowbits/crowbits-htu21d-humiture-sensor.html#description","title":"Description","text":"<p>Our Crowbits add a new sensor about environmental monitoring that called Crowbits-HTU21D Humiture Sensor, which is a low-cost, easy to use, highly accurate, digital humidity and temperature sensor. The sensor outputs the calibrated digital signal in standard I2C format. HTU21D series module designed for low-power/small-volume application design, with good quality, fast response speed, anti-interference ability, cost-effective advantages, very low power consumption. It\u2019s ideal for environmental sensing and data logging and perfect for a weather stations or humidor control systems.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-htu21d-humiture-sensor.html#features","title":"Features","text":"<ul> <li>Low-cost</li> <li>High precision</li> </ul>"},{"location":"Products/Crowbits/crowbits-htu21d-humiture-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-htu21d-humiture-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the I2C interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Download the library SparkFunHTU21D. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4.Upload the following code to the Crowbits-UNO board.</p> <pre><code>/* \n HTU21D Humidity Sensor Example Code\n By: Nathan Seidle\n SparkFun Electronics\n Date: September 15th, 2013\n License: This code is public domain but you buy me a beer if you use this and we meet someday (Beerware license).\n\n Uses the HTU21D library to display the current humidity and temperature\n\n Open serial monitor at 9600 baud to see readings. Errors 998 if not sensor is detected. Error 999 if CRC is bad.\n\n Hardware Connections (Breakoutboard to Arduino):\n -VCC = 3.3V\n -GND = GND\n -SDA = A4 (use inline 330 ohm resistor if your board is 5V)\n -SCL = A5 (use inline 330 ohm resistor if your board is 5V)\n\n */\n\n#include &lt;Wire.h&gt;\n#include \"SparkFunHTU21D.h\"\n\n//Create an instance of the object\nHTU21D myHumidity;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  Serial.println(\"HTU21D Example!\");\n\n  myHumidity.begin();\n}\n\nvoid loop()\n{\n  float humd = myHumidity.readHumidity();\n  float temp = myHumidity.readTemperature();\n\n  Serial.print(\"Time:\");\n  Serial.print(millis());\n  Serial.print(\" Temperature:\");\n  Serial.print(temp, 1);\n  Serial.print(\"C\");\n  Serial.print(\" Humidity:\");\n  Serial.print(humd, 1);\n  Serial.print(\"%\");\n\n  Serial.println();\n  delay(1000);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The serial port will print out the current temperature and humidity values.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ir-emitter.html","title":"Crowbits-IR Emitter","text":""},{"location":"Products/Crowbits/crowbits-ir-emitter.html#description","title":"Description","text":"<p>The Crowbits-IR Emitter is an LED make from gallium arsenide, with its color centered around 940nm. It's used to transmit infrared signals through an infrared LED, while there is an Infrared receiver to get the signals on the other side. We can not only use the emitter to transmit data or commands, but also to emulate remotes to control your home appliance using an Arduino.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ir-emitter.html#features","title":"Features","text":"<ul> <li>Remote controller system</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-emitter.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-emitter.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare two Crowbits motherboards, such as Crowbits-UNO board. And a Crowbits-IR Receiver board.</p> <p>2. Connect the Crowbits-IR Receiver board to the D2 interface of the Crowbits-UNO board. Connect the Crowbits-IR Emitter board to the D9 interface of another Crowbits-UNO board.</p> <p></p> <p>3. Download the library \u201cIRSendRev\u201d. Unzip and put it in the libraries file, for example C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4.Open the code directly by the path:File -&gt; Example -&gt;IRSendRev-&gt;sendTest. Download this program to the motherboard connected to the Crowbits-IR Emitter module.</p> <pre><code>//**************\n//IR sent demo v1.0\n//Connect the IR sent pins to D3 for this demo\n//******************************\n#include &lt;IRSendRev.h&gt;\n\nvoid setup()\n{\n    //enableIROut(38);\n}\n//unsigned char d[] = {9, 90, 91, 11, 31, 4, 1, 2, 3, 4};\nunsigned char d[] = {15, 70, 70, 20, 60, 10, 1, 2, 3, 4,5,6,7,8,9,10};\n//Very Important:\n//the first parameter(15): the data that needs to be sent;\n//the next 2 parameter(70,70): the logic high and low duration of \"Start\";\n//the next 2 parameter(20,60): the logic \"short\" and \"long\"duration in the communication\n//                             that to say:  if \"0\", the high duration is 20ms and  low is 20 ms; while logic \"1\",\n//                              the high duration is 20 ms and low is 60 ms;\n//the next 2 parameter(10): number of data you will sent;\n//the next parameter(1, 2, 3, 4,5,6,7,8,9,10): data you will sent\u00a0;\nvoid loop()\n{\n    IR.Send(d, 38);//sent the data via 38Kz IR\n    delay(1000);\n}\n</code></pre> <p>5.Open the code directly by the path:File -&gt; Example -&gt;IRSendRev-&gt;revTest. Download this program to the motherboard connected to the Crowbits-IR Receiver module.</p> <pre><code>//**************\n//IR receive demo v1.0\n//Connect the IR sent pins to D2 for this demo\n//******************************\n#include &lt;IRSendRev.h&gt;\n//#include &lt;IRSendRevInt.h&gt;\n\nvoid setup()\n{\n    Serial.begin(9600);\n    IR.Init(2);\n    Serial.println(\"init over\");\n}\n\nunsigned char dta[20];\n\nvoid loop()\n{\n    if(IR.IsDta())\n    {\n       // IR.Recv(dta);\n        int length= IR.Recv(dta);\n        for (int i =0;i&lt;length;i++)\n        {\n          Serial.print(dta[i]);\n          Serial.print(\"\\t\");\n        }\n        Serial.println();\n// Very Important:\n// the received data is comprised of the trsmission parameters , please refer to \n// the sendTest.ino in the library\u00a0;\n    }\n\n\n}\n</code></pre> <p>6. After downloading the two programs, open the serial port of the motherboard connected to the Crowbits of the Crowbits-IR Receiver module, the baud rate is set to 9600, and then you will receive the information sent by the transmitter module, as shown in the figure:</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ir-receiver.html","title":"Crowbits-IR Receiver","text":""},{"location":"Products/Crowbits/crowbits-ir-receiver.html#description","title":"Description","text":"<p>The Crowbits-IR Receiver module uses the HS0038B which is miniaturized receivers for infrared remote control system and it is the standard IR remote control receiver series, supporting all major transmission codes. The IR detector have a demodulator inside that looks for modulated IR at 38 KHz. We often use the two Crowbits-IR Receiver and the Crowbits-IR Emitter to work together.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ir-receiver.html#features","title":"Features","text":"<ul> <li>Remote controller system</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-receiver.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-receiver.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare two Crowbits motherboards, such as Crowbits-UNO board. And a Crowbits-IR Emitter board.</p> <p>2. Connect the Crowbits-IR Receiver board to the D2 interface of the Crowbits-UNO board. Connect the Crowbits-IR Emitter board to the D9 interface of another Crowbits-UNO board.</p> <p></p> <p>3. Download the library \u201cIRSendRev\u201d. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4.Open the code directly by the path:File -&gt; Example -&gt;IRSendRev-&gt;sendTest. Download this program to the motherboard connected to the Crowbits-IR Emitter module.</p> <pre><code>//**************\n//IR sent demo v1.0\n//Connect the IR sent pins to D3 for this demo\n//******************************\n#include &lt;IRSendRev.h&gt;\n\nvoid setup()\n{\n    //enableIROut(38);\n}\n//unsigned char d[] = {9, 90, 91, 11, 31, 4, 1, 2, 3, 4};\nunsigned char d[] = {15, 70, 70, 20, 60, 10, 1, 2, 3, 4,5,6,7,8,9,10};\n//Very Important:\n//the first parameter(15): the data that needs to be sent;\n//the next 2 parameter(70,70): the logic high and low duration of \"Start\";\n//the next 2 parameter(20,60): the logic \"short\" and \"long\"duration in the communication\n//                             that to say:  if \"0\", the high duration is 20ms and  low is 20 ms; while logic \"1\",\n//                              the high duration is 20 ms and low is 60 ms;\n//the next 2 parameter(10): number of data you will sent;\n//the next parameter(1, 2, 3, 4,5,6,7,8,9,10): data you will sent\u00a0;\nvoid loop()\n{\n    IR.Send(d, 38);//sent the data via 38Kz IR\n    delay(1000);\n}\n</code></pre> <p>5. Open the code directly by the path:File -&gt; Example -&gt;IRSendRev-&gt;revTest. Download this program to the motherboard connected to the Crowbits-IR Receiver module.</p> <pre><code>//**************\n//IR receive demo v1.0\n//Connect the IR sent pins to D2 for this demo\n//******************************\n#include &lt;IRSendRev.h&gt;\n//#include &lt;IRSendRevInt.h&gt;\n\nvoid setup()\n{\n    Serial.begin(9600);\n    IR.Init(2);\n    Serial.println(\"init over\");\n}\n\nunsigned char dta[20];\n\nvoid loop()\n{\n    if(IR.IsDta())\n    {\n       // IR.Recv(dta);\n        int length= IR.Recv(dta);\n        for (int i =0;i&lt;length;i++)\n        {\n          Serial.print(dta[i]);\n          Serial.print(\"\\t\");\n        }\n        Serial.println();\n// Very Important:\n// the received data is comprised of the trsmission parameters , please refer to \n// the sendTest.ino in the library\u00a0;\n    }\n\n\n}\n</code></pre> <p>6. After downloading the two programs, open the serial port of the motherboard connected to the Crowbits of the Crowbits-IR Receiver module, the baud rate is set to 9600, and then you will receive the information sent by the transmitter module, as shown in the figure:</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ir-reflective-sensor.html","title":"Crowbits-IR Reflective Sensor","text":""},{"location":"Products/Crowbits/crowbits-ir-reflective-sensor.html#description","title":"Description","text":"<p>The IR reflective sensor is a digital input module, it acts like a pair of eyes inside your circuit, it senses objects around it and takes action. In real life, the IR reflective sensor is often used as car tracking devices.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ir-reflective-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-reflective-sensor.html#application","title":"Application","text":"<ul> <li>Obstacle Detection</li> <li>Compact disk players, Copiers, Game machines</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-reflective-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-reflective-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the sensor detects an object, the LED behind it will light up.</p>"},{"location":"Products/Crowbits/crowbits-ir-temperature-sensor.html","title":"Crowbits-IR Temperature Sensor","text":""},{"location":"Products/Crowbits/crowbits-ir-temperature-sensor.html#description","title":"Description","text":"<p>This IR temperature sensor is a non-contact temperature measure model by using the MLX90614, which one is in small size and low cost with a measurement resolution of 0.02\u2103. Thanks to its low noise amplifier, 17-bit ADC and powerful DSP unit, high accuracy and resolution of the thermometer are achieved.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ir-temperature-sensor.html#features","title":"Features","text":"<ul> <li>High precision</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-temperature-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-ir-temperature-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cI2Cmaster\u201d. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;i2cmaster.h&gt;\n\n\nvoid setup(){\n    Serial.begin(9600);\n    Serial.println(\"Setup...\");\n\n    i2c_init(); //Initialise the i2c bus\n    PORTC = (1 &lt;&lt; PORTC4) | (1 &lt;&lt; PORTC5);//enable pullups\n}\n\nvoid loop(){\n    int dev = 0x5A&lt;&lt;1;\n    int data_low = 0;\n    int data_high = 0;\n    int pec = 0;\n\n    i2c_start_wait(dev+I2C_WRITE);\n    i2c_write(0x07);\n\n    // read\n    i2c_rep_start(dev+I2C_READ);\n    data_low = i2c_readAck(); //Read 1 byte and then send ack\n    data_high = i2c_readAck(); //Read 1 byte and then send ack\n    pec = i2c_readNak();\n    i2c_stop();\n\n    //This converts high and low bytes together and processes temperature, MSB is a error bit and is ignored for temps\n    double tempFactor = 0.02; // 0.02 degrees per LSB (measurement resolution of the MLX90614)\n    double tempData = 0x0000; // zero out the data\n    int frac; // data past the decimal point\n\n    // This masks off the error bit of the high byte, then moves it left 8 bits and adds the low byte.\n    tempData = (double)(((data_high &amp; 0x007F) &lt;&lt; 8) + data_low);\n    tempData = (tempData * tempFactor)-0.01;\n\n    float celcius = tempData - 273.15;\n    float fahrenheit = (celcius*1.8) + 32;\n\n    Serial.print(\"Celcius: \");\n    Serial.println(celcius);\n\n    Serial.print(\"Fahrenheit: \");\n    Serial.println(fahrenheit);\n\n    delay(1000); // wait a second before printing again\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. The serial port will print out temperature information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-keyboard.html","title":"Crowbits-Keyboard","text":""},{"location":"Products/Crowbits/crowbits-keyboard.html#description","title":"Description","text":"<p>Each key on the keyboard can input various numbers and symbols, which also integrated a microphone. You can use it for scenarios such as phone buttons. Add a lot of fun to your project.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-keyboard.html#features","title":"Features","text":"<ul> <li>SMD silicone silent keyboard</li> </ul>"},{"location":"Products/Crowbits/crowbits-keyboard.html#specification","title":"Specification","text":"<ul> <li>Interface Type: Analog input</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-keyboard.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A2 interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>int sensorPin = A2;\nint sensorValue = 0;\nint a = 0;\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"Please press a Key\");\n}\n\nvoid loop() \n{\n  sensorValue = analogRead(sensorPin);\n  a = sensorValue;\n  // a = sensorValue/10;\n  //Serial.println(sensorValue);\n  if (a &gt;= 0 &amp;&amp; a &lt;= 40 ) {\n    Serial.println(\"7\");\n   // Serial.println(a);\n    delay(500);\n  }\n\n  if (a &gt;= 50 &amp;&amp; a &lt;= 90 ) {\n    Serial.println(\"8\");\n   // Serial.println(a);\n    delay(500);\n  }\n\n  if (a &gt;= 100 &amp;&amp; a &lt;= 150 ) {\n    Serial.println(\"9\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 160 &amp;&amp; a &lt;= 200 ) {\n    Serial.println(\"+\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 230 &amp;&amp; a &lt;= 270 ) {\n    Serial.println(\"4\");\n    delay(500);\n  }\n  if (a &gt;= 290 &amp;&amp; a &lt;= 330 ) {\n    Serial.println(\"5\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 350 &amp;&amp; a &lt;= 390 ) {\n    Serial.println(\"6\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 420 &amp;&amp; a &lt;= 460 ) {\n    Serial.println(\"-\");\n    //Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 480 &amp;&amp; a &lt;= 520 ) {\n    Serial.println(\"1\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 545 &amp;&amp; a &lt;= 585 ) {\n    Serial.println(\"2\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 600 &amp;&amp; a &lt;= 640 ) {\n    Serial.println(\"3\");\n    //Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 670 &amp;&amp; a &lt;= 710 ) {\n    Serial.println(\"*\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 735 &amp;&amp; a &lt;= 775 ) {\n    Serial.println(\".\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 790 &amp;&amp; a &lt;= 835 ) {\n    Serial.println(\"0\");\n   // Serial.println(a);\n    delay(500);\n  }\n  if (a &gt;= 860 &amp;&amp; a &lt;= 900 ) {\n    Serial.println(\"=\");\n    //Serial.println(a);\n    delay(500);\n  }\n  if (a &gt; 900 &amp;&amp; a &lt;= 945 ) {\n    Serial.println(\"/\");\n   // Serial.println(a);\n    delay(500);\n  }\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Press the keys on the keyboard, the serial port will output the corresponding numbers and symbols.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-laser-ranging-sensor.html","title":"Crowbits-Laser Ranging Sensor","text":""},{"location":"Products/Crowbits/crowbits-laser-ranging-sensor.html#description","title":"Description","text":"<p>If you want to measure something more accurate and faster. This module fully meets the requirements. And the specific crowtail interface will provide convenience for us to use it with Arduino. The VL53L0X is a new generation Time-of-Flight (ToF) laser-ranging module housed in the smallest package on the market today, providing accurate distance measurement whatever the target reflectances unlike conventional technologies. It can measure absolute distances up to 2m, setting a new benchmark in ranging performance levels, opening the door to various new applications. The VL53L0X integrates a leading-edge SPAD array (Single Photon Avalanche Diodes) and embeds ST\u2019s second generation FlightSenseTM patented technology. The VL53L0X\u2019s 940nm VCSEL emitter (Vertical Cavity Surface-Emitting Laser), is totally invisible to the human eye, coupled with internal physical infrared filters, it enables longer ranging distance, higher immunity to ambient light and better robustness to cover-glass optical cross-talk.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-laser-ranging-sensor.html#features","title":"Features","text":"<ul> <li>Fully integrated miniature module</li> <li>Advanced embedded optical cross-talk compensation to simplify cover glass selection</li> <li>Class 1 laser device compliant with latest standard IEC 60825-1:2014 - 3<sup>rd</sup> edition</li> </ul>"},{"location":"Products/Crowbits/crowbits-laser-ranging-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-laser-ranging-sensor.html#applications","title":"Applications","text":"<ul> <li>User detection for Personal Computers/ Laptops/Tablets and IoT (Energy saving)</li> <li>Robotics (obstacle detection).</li> </ul>"},{"location":"Products/Crowbits/crowbits-laser-ranging-sensor.html#usage","title":"Usage","text":"<p>Usage The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>//the original code by Ted Meyers\n//posted here: https://groups.google.com/d/msg/diyrovers/lc7NUZYuJOg/ICPrYNJGBgAJ\n\n#include &lt;Wire.h&gt;\n\n#define VL53L0X_REG_IDENTIFICATION_MODEL_ID         0xc0\n#define VL53L0X_REG_IDENTIFICATION_REVISION_ID      0xc2\n#define VL53L0X_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD   0x50\n#define VL53L0X_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD 0x70\n#define VL53L0X_REG_SYSRANGE_START                  0x00\n#define VL53L0X_REG_RESULT_INTERRUPT_STATUS         0x13\n#define VL53L0X_REG_RESULT_RANGE_STATUS             0x14\n#define address 0x29\n\nbyte gbuf[16];\n\nvoid setup() {\n  // put your setup code here, to run once:\n  Wire.begin();        // join i2c bus (address optional for master)\n  Serial.begin(9600);  // start serial for output\n  Serial.println(\"VLX53LOX test started.\");\n}\n\nvoid loop() {\n  Serial.println(\"----- START TEST ----\");\n  test();\n  Serial.println(\"----- END TEST ----\");\n  Serial.println(\"\");\n  delay(1000);\n}\n\nvoid test() {\n  byte val1 = read_byte_data_at(VL53L0X_REG_IDENTIFICATION_REVISION_ID);\n  Serial.print(\"Revision ID: \"); Serial.println(val1);\ndelay(1000);\n  val1 = read_byte_data_at(VL53L0X_REG_IDENTIFICATION_MODEL_ID);\n  Serial.print(\"Device ID: \"); Serial.println(val1);\ndelay(1000);\n  val1 = read_byte_data_at(VL53L0X_REG_PRE_RANGE_CONFIG_VCSEL_PERIOD);\n  Serial.print(\"PRE_RANGE_CONFIG_VCSEL_PERIOD=\"); Serial.println(val1); \n  Serial.print(\" decode: \"); Serial.println(VL53L0X_decode_vcsel_period(val1));\ndelay(1000);\n  val1 = read_byte_data_at(VL53L0X_REG_FINAL_RANGE_CONFIG_VCSEL_PERIOD);\n  Serial.print(\"FINAL_RANGE_CONFIG_VCSEL_PERIOD=\"); Serial.println(val1);\n  Serial.print(\" decode: \"); Serial.println(VL53L0X_decode_vcsel_period(val1));\ndelay(1000);\n  write_byte_data_at(VL53L0X_REG_SYSRANGE_START, 0x01);\n\n  byte val = 0;\n  int cnt = 0;\n  while (cnt &lt; 100) { // 1 second waiting time max\n    delay(10);\n    val = read_byte_data_at(VL53L0X_REG_RESULT_RANGE_STATUS);\n    if (val &amp; 0x01) break;\n    cnt++;\n  }\n  if (val &amp; 0x01) Serial.println(\"ready\"); else Serial.println(\"not ready\");\n\n  read_block_data_at(0x14, 12);\n  uint16_t acnt = makeuint16(gbuf[7], gbuf[6]);\n  uint16_t scnt = makeuint16(gbuf[9], gbuf[8]);\n  uint16_t dist = makeuint16(gbuf[11], gbuf[10]);\n  byte DeviceRangeStatusInternal = ((gbuf[0] &amp; 0x78) &gt;&gt; 3);\n\n  Serial.print(\"ambient count: \"); Serial.println(acnt);\n  delay(1000);\n  Serial.print(\"signal count: \");  Serial.println(scnt);\n  delay(1000);\n  Serial.print(\"distance \");       Serial.println(dist);\n  delay(1000);\n  Serial.print(\"status: \");        Serial.println(DeviceRangeStatusInternal);\n  delay(1000);\n}\n\nuint16_t bswap(byte b[]) {\n  // Big Endian unsigned short to little endian unsigned short\n  uint16_t val = ((b[0] &lt;&lt; 8) &amp; b[1]);\n  return val;\n}\n\nuint16_t makeuint16(int lsb, int msb) {\n    return ((msb &amp; 0xFF) &lt;&lt; 8) | (lsb &amp; 0xFF);\n}\n\nvoid write_byte_data(byte data) {\n  Wire.beginTransmission(address);\n  Wire.write(data);\n  Wire.endTransmission();\n}\n\nvoid write_byte_data_at(byte reg, byte data) {\n  // write data word at address and register\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  Wire.write(data);\n  Wire.endTransmission();\n}\n\nvoid write_word_data_at(byte reg, uint16_t data) {\n  // write data word at address and register\n  byte b0 = (data &amp;0xFF);\n  byte b1 = ((data &gt;&gt; 8) &amp;&amp; 0xFF);\n\n  Wire.beginTransmission(address);\n  Wire.write(reg);\n  Wire.write(b0);\n  Wire.write(b1);\n  Wire.endTransmission();\n}\n\nbyte read_byte_data() {\n  Wire.requestFrom(address, 1);\n  while (Wire.available() &lt; 1) delay(1);\n  byte b = Wire.read();\n  return b;\n}\n\nbyte read_byte_data_at(byte reg) {\n  //write_byte_data((byte)0x00);\n  write_byte_data(reg);\n  Wire.requestFrom(address, 1);\n  while (Wire.available() &lt; 1) delay(1);\n  byte b = Wire.read();\n  return b;\n}\n\nuint16_t read_word_data_at(byte reg) {\n  write_byte_data(reg);\n  Wire.requestFrom(address, 2);\n  while (Wire.available() &lt; 2) delay(1);\n  gbuf[0] = Wire.read();\n  gbuf[1] = Wire.read();\n  return bswap(gbuf); \n}\n\nvoid read_block_data_at(byte reg, int sz) {\n  int i = 0;\n  write_byte_data(reg);\n  Wire.requestFrom(address, sz);\n  for (i=0; i&lt;sz; i++) {\n    while (Wire.available() &lt; 1) delay(1);\n    gbuf[i] = Wire.read();\n  }\n}\n\n\nuint16_t VL53L0X_decode_vcsel_period(short vcsel_period_reg) {\n  // Converts the encoded VCSEL period register value into the real\n  // period in PLL clocks\n  uint16_t vcsel_period_pclks = (vcsel_period_reg + 1) &lt;&lt; 1;\n  return vcsel_period_pclks;\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Place an object in front of the sensor, the serial port will show the distance of the object, as shown in the figure:</p> <p></p>"},{"location":"Products/Crowbits/crowbits-led-bar.html","title":"Crowbits-LED Bar","text":""},{"location":"Products/Crowbits/crowbits-led-bar.html#description","title":"Description","text":"<p>The LED light bar is a digital output module. Through the light bar, you can display the battery power, voltage value, water depth, sound size, and any other scene that needs to represent the gradient value.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-led-bar.html#features","title":"Features","text":"<ul> <li>Detect various signals</li> </ul>"},{"location":"Products/Crowbits/crowbits-led-bar.html#specification","title":"Specification","text":"<ul> <li>Interface Type\uff1aGPIO</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-led-bar.html#application-ideas","title":"Application Ideas","text":"<ul> <li>Display test information</li> </ul>"},{"location":"Products/Crowbits/crowbits-led-bar.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of digital display.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the D2 and D3 interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Download the library Crowbits-LED Bar library. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4.Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*\n  Crowtai LED Bar - Level Example\n  This example will show you how to use setLevel() function of this library.\n  The setLevel() function illuminates the given number of LEDs from either side.\n\n  Syntax setLevel(level)\n  0  = all LEDs off\n  5  = 5 LEDs on\n  10 = all LEDs on\n*/\n\n#include &lt;Grove_LED_Bar.h&gt;\nGrove_LED_Bar bar(2, 3, 0);  // Clock pin, Data pin, Orientation\n\nvoid setup()\n{\n  // nothing to initialize\n  Serial.begin(9600);\n  bar.begin();\n}\n\nvoid loop()\n{\n  // Walk through the levels\n  for (int i = 0; i &lt;= 10; i++)\n  {\n    bar.setLevel(i);\n    delay(1000);\n  }\n\n}\n</code></pre> <p>5. After the code is uploaded successfully, you will see the light bar change.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-led-matrix.html","title":"Crowbits-LED Matrix","text":""},{"location":"Products/Crowbits/crowbits-led-matrix.html#description","title":"Description","text":"<p>The I2C communication protocol uses only 2 pins, and you can have up to 8 selectable I2C addresses so thats a total of 8 matrices, each one controlling 8x8 LEDs for 64 total LEDs. We offer three LED matrix to you-red ,blue and green. You need to pay attention to that the driver can turn LEDs on and off but does not have the ability to individually PWM dim them. This chip is rock solid, has Arduino &amp; Pi example code written for it and is easy to use.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-led-matrix.html#features","title":"Features","text":"<ul> <li>8*8 LED matrix</li> </ul>"},{"location":"Products/Crowbits/crowbits-led-matrix.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-led-matrix.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cAdafruit_GFX\u201d and \u201cAdafruit_LEDBackpack\u201d. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*************************************************** \n  This is a library for our I2C LED Backpacks\n\n  Designed specifically to work with the Adafruit LED Matrix backpacks \n  ----&gt; http://www.adafruit.com/products/872\n  ----&gt; http://www.adafruit.com/products/871\n  ----&gt; http://www.adafruit.com/products/870\n\n  These displays use I2C to communicate, 2 pins are required to \n  interface. There are multiple selectable I2C addresses. For backpacks\n  with 2 Address Select pins: 0x70, 0x71, 0x72 or 0x73. For backpacks\n  with 3 Address Select pins: 0x70 thru 0x77\n\n  Adafruit invests time and resources providing this open source code, \n  please support Adafruit and open-source hardware by purchasing \n  products from Adafruit!\n\n  Written by Limor Fried/Ladyada for Adafruit Industries.  \n  BSD license, all text above must be included in any redistribution\n ****************************************************/\n\n#include &lt;Wire.h&gt;\n#include &lt;Adafruit_GFX.h&gt;\n#include \"Adafruit_LEDBackpack.h\"\n\nAdafruit_8x8matrix matrix = Adafruit_8x8matrix();\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(\"8x8 LED Matrix Test\");\n\n  matrix.begin(0x70);  // pass in the address\n}\n\nstatic const uint8_t PROGMEM\n  smile_bmp[] =\n  { B00111100,\n    B01000010,\n    B10100101,\n    B10000001,\n    B10100101,\n    B10011001,\n    B01000010,\n    B00111100 },\n  neutral_bmp[] =\n  { B00111100,\n    B01000010,\n    B10100101,\n    B10000001,\n    B10111101,\n    B10000001,\n    B01000010,\n    B00111100 },\n  frown_bmp[] =\n  { B00111100,\n    B01000010,\n    B10100101,\n    B10000001,\n    B10011001,\n    B10100101,\n    B01000010,\n    B00111100 };\n\nvoid loop() {\n  matrix.clear();\n  matrix.drawBitmap(0, 0, smile_bmp, 8, 8, LED_ON);\n  matrix.writeDisplay();\n  delay(500);\n\n  matrix.clear();\n  matrix.drawBitmap(0, 0, neutral_bmp, 8, 8, LED_ON);\n  matrix.writeDisplay();\n  delay(500);\n\n  matrix.clear();\n  matrix.drawBitmap(0, 0, frown_bmp, 8, 8, LED_ON);\n  matrix.writeDisplay();\n  delay(500);\n\n  matrix.clear();      // clear display\n  matrix.drawPixel(0, 0, LED_ON);  \n  matrix.writeDisplay();  // write the changes we just made to the display\n  delay(500);\n\n  matrix.clear();\n  matrix.drawLine(0,0, 7,7, LED_ON);\n  matrix.writeDisplay();  // write the changes we just made to the display\n  delay(500);\n\n  matrix.clear();\n  matrix.drawRect(0,0, 8,8, LED_ON);\n  matrix.fillRect(2,2, 4,4, LED_ON);\n  matrix.writeDisplay();  // write the changes we just made to the display\n  delay(500);\n\n  matrix.clear();\n  matrix.drawCircle(3,3, 3, LED_ON);\n  matrix.writeDisplay();  // write the changes we just made to the display\n  delay(500);\n\n  matrix.setTextSize(1);\n  matrix.setTextWrap(false);  // we dont want text to wrap so it scrolls nicely\n  matrix.setTextColor(LED_ON);\n  for (int8_t x=0; x&gt;=-36; x--) {\n    matrix.clear();\n    matrix.setCursor(x,0);\n    matrix.print(\"Hello\");\n    matrix.writeDisplay();\n    delay(100);\n  }\n  matrix.setRotation(3);\n  for (int8_t x=7; x&gt;=-36; x--) {\n    matrix.clear();\n    matrix.setCursor(x,0);\n    matrix.print(\"World\");\n    matrix.writeDisplay();\n    delay(100);\n  }\n  matrix.setRotation(0);\n}\n</code></pre> <p>5. After the code is uploaded successfully, you can see the patterns and words displayed on the 8 * 8 dot matrix.</p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-led-red-green-yellow.html","title":"Crowbits-LED (Red Green Yellow)","text":""},{"location":"Products/Crowbits/crowbits-led-red-green-yellow.html#description","title":"Description","text":"<p>The LED is a digital output module, it will bring light to your project. Crowbits includes 3 different type of LED colors, all are the same except the color. The kit includes: Red LED, Green LED and Yellow LED.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-led-red-green-yellow.html#features","title":"Features","text":"<ul> <li>5mm LED</li> <li>Digital output module</li> </ul>"},{"location":"Products/Crowbits/crowbits-led-red-green-yellow.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-led-red-green-yellow.html#usage","title":"Usage","text":"<p>1.You also need to prepare a power module, such as Crowbits-Power Supply, and an input module, such as Crowbits-Touch Sensor.</p> <p>2.The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3.Then, turn on the power. When you touch the sensor with your hand, the LED light will light up; Otherwise, the LED will be off.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-light-sensor.html","title":"Crowbits-Light Sensor","text":""},{"location":"Products/Crowbits/crowbits-light-sensor.html#description","title":"Description","text":"<p>The light sensor is an analog input module, it controls your circuit with light. The light sensor measures the light intensity to know how dark or bright the environment is to activate your circuit.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-light-sensor.html#features","title":"Features","text":"<ul> <li>Light-control switch</li> <li>Analog input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-light-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-light-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power.</p> <ul> <li> <p>When you place the sensor in a place with strong light, the LED connected behind will not light.</p> </li> <li> <p>when you place the sensor in a place with weak light, the LED connected behind will light up.</p> </li> </ul> <p></p>"},{"location":"Products/Crowbits/crowbits-linear-potentiometer.html","title":"Crowbits-Linear Potentiometer","text":""},{"location":"Products/Crowbits/crowbits-linear-potentiometer.html#description","title":"Description","text":"<p>The linear potentiometer is an analog input module, it changes the resistance of the whole circuit to control your circuit.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-linear-potentiometer.html#features","title":"Features","text":"<ul> <li>Analog input module</li> <li>Linear resistance taper</li> </ul>"},{"location":"Products/Crowbits/crowbits-linear-potentiometer.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>The range of resistance of the potentiometer: 0~5K\u03a9</li> <li>18mm long slide length</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-linear-potentiometer.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. Sliding the rheostat, you can see that the LED will have a progressive effect of darkening or brightening.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-and.html","title":"Crowbits-Logic AND","text":""},{"location":"Products/Crowbits/crowbits-logic-and.html#description","title":"Description","text":"<p>The logic AND is a logic gate that creates rules for your circuit, gives you more ability to create interesting and complex interactions..The logic AND has two inputs and one output, only both of the inputs are true, the output is true. The interface of the logic AND is a digital interface, it will output a logic-high/low (1/0) signal.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-and.html#features","title":"Features","text":"<ul> <li>Dual input port.</li> <li>Single output port.</li> <li>Output indicator.</li> </ul>"},{"location":"Products/Crowbits/crowbits-logic-and.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 56(L)*31(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-logic-and.html#usage","title":"Usage","text":"<p>1) You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Switch and Crowbits-Touch Sensor; An extension module, such as Crowbits-LED.</p> <p>2) The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3) Then, turn on the power. When you press the self-locking switch and press the Touch Sensor, the LED light.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-input.html","title":"Crowbits-Logic Input","text":""},{"location":"Products/Crowbits/crowbits-logic-input.html#description","title":"Description","text":"<p>The logic Input is a small and convenient way to input digital logic commands (high or low) into your circuit. The logic input has two states, logic low and logic high (1 and 0). The number 0 on the board means logic low-level, the number 1 means logic high-level. When sliding the switch to 1, it will output a logic high-level signal. Otherwise, slide the switch to 0, it will output a logic low-level signal.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-input.html#features","title":"Features","text":"<ul> <li>Single input port.</li> <li>Single output port.</li> <li>Output indicator.</li> </ul>"},{"location":"Products/Crowbits/crowbits-logic-input.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-logic-input.html#usage","title":"Usage","text":"<p>1. You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Logic input; An extension module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p>3. Turn on the power. When sliding the switch to 0, the LED lights off.</p> <p></p> <p>4. When sliding the switch to 1, the LED light.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-not.html","title":"Crowbits-Logic NOT","text":""},{"location":"Products/Crowbits/crowbits-logic-not.html#description","title":"Description","text":"<p>The logic NOT is a logic gate that uses one input signal to control one output signal, it creates rules for your circuit. The interface of the logic NOT is a digital interface, it will output a logic-high or low (1 or 0) signal.The logic NOT has one input and one output, the output does a reverse operation on the input, which means if you send a logic-high signal to the input, the logic NOT will output a logic-low signal.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-not.html#features","title":"Features","text":"<ul> <li>Single input port.</li> <li>Single output port.</li> <li>Output indicator.</li> </ul>"},{"location":"Products/Crowbits/crowbits-logic-not.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-logic-not.html#usage","title":"Usage","text":"<p>1)You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Touch Sensor and Crowbits-Logic NOT; An extension module, such as Crowbits-LED.</p> <p>2)The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3)Then, turn on the power. the LED light.</p> <p></p> <p>4)When you press the Touch Sensor, the LED lights off.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-or.html","title":"Crowbits-Logic OR","text":""},{"location":"Products/Crowbits/crowbits-logic-or.html#description","title":"Description","text":"<p>The logic OR is a logic gate that creates an OR rule for your circuit. But unlike AND, the logic OR is a good option for projects where you want to detect two inputs but don't care which input is activated.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-logic-or.html#features","title":"Features","text":"<ul> <li>Single output port.</li> </ul> <pre><code>*Output indicator.\n</code></pre>"},{"location":"Products/Crowbits/crowbits-logic-or.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 56(L)*31(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-logic-or.html#usage","title":"Usage","text":"<p>1)You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Switch and Crowbits-Touch Sensor; An extension module, such as Crowbits-LED.</p> <p>2)The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3)Then, turn on the power. When you press the self-locking switch or press the Touch Sensor, the LED light.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-magnetic-switch.html","title":"Crowbits-Magnetic Switch","text":""},{"location":"Products/Crowbits/crowbits-magnetic-switch.html#description","title":"Description","text":"<p>The magnetic is a digital input module, it is an electrical switch activated by the magnetic field, it can be used to detect the magnetic field.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-magnetic-switch.html#features","title":"Features","text":"<ul> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-magnetic-switch.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-magnetic-switch.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. When the sensor detects the presence of a magnet, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-microbit-compatible.html","title":"Crowbits-Microbit Compatible","text":""},{"location":"Products/Crowbits/crowbits-microbit-compatible.html#description","title":"Description","text":"<p>The main controller expansion board can input and output various data, various digital quantities, and module quantities. Through the 40Pin micro: bit golden finger slot, the function pins of Crowbits-Microbit are led out, which is convenient for docking with other functional modules and becomes a communication bridge between each module and the main control, so as to realize the data reception of each module and the main control board And send to realize data feedback and control of each module.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-microbit-compatible.html#features","title":"Features","text":"<ul> <li>Strong driving force</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-microbit-compatible.html#specification","title":"Specification","text":"<ul> <li>Output Voltage: 3.3V DC</li> <li>Charging method: DC 5V Micro USB</li> <li>Battery capacity: 650mAh</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-microbit-compatible.html#usage","title":"Usage","text":"<p>The micro: bit motherboard needs to be inserted into the main control board before it can be used. The leads can be connected to other input and output magnetic suction modules. These modules can be controlled by programming the micro: bit.</p>"},{"location":"Products/Crowbits/crowbits-microphone.html","title":"Crowbits-Microphone","text":""},{"location":"Products/Crowbits/crowbits-microphone.html#description","title":"Description","text":"<p>The microphone is an analog input module that can be used as an ear for your circuit, it detects the sound from the environment.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-microphone.html#features","title":"Features","text":"<ul> <li>Low-power, omnidirectional microphone</li> <li>Analog input module</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-microphone.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-microphone.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-Buzzer.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When a sound is detected around, the buzzer connected behind will make a sound.</p>"},{"location":"Products/Crowbits/crowbits-moisture-sensor.html","title":"Crowbits-Moisture Sensor","text":""},{"location":"Products/Crowbits/crowbits-moisture-sensor.html#description","title":"Description","text":"<p>This is a capacitive soil moisture sensor, it can measure the soil moisture level of your plant by capacitive sensing. Compared with other types of moisture sensor, the capacitive soil moisture sensor is made of a corrosion resistant material, which will provide a long service life. This moisture sensor can be used to detect the moisture of soil to monitor if the plants need water.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-moisture-sensor.html#features","title":"Features","text":"<ul> <li>Corrosion resistant</li> <li>Soil moisture sensor based on soil capacitive measurement</li> <li>Easy to use</li> <li>High sensitivity</li> </ul>"},{"location":"Products/Crowbits/crowbits-moisture-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating voltage: 3.3V</li> <li>Size: 20 (W)*92.5(L)</li> </ul>"},{"location":"Products/Crowbits/crowbits-moisture-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the A3 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>void setup() {                \n // initialize the digital pin5 as an output.\n Serial.begin(9600); // open serial port, set the baud rate to 9600 bps\n}\n\nint val0=A3;\n\nint SensorValue0=0;\n\nvoid loop() {\n\n    SensorValue0 = analogRead(val0); //connect sensor to Analog 0\n\n  Serial.print(\"SensorValue0:\"); //print the value to serial\n  Serial.println(SensorValue0); //print the value to serial\n\n  delay(100);\n}\n</code></pre> <p>4.After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Put the sensor in the soil, the serial port will output the corresponding voltage value.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-mosfet.html","title":"Crowbits-MOSFET","text":""},{"location":"Products/Crowbits/crowbits-mosfet.html#description","title":"Description","text":"<p>The MOSFET is a digital output module, it\u2019s a kind of switch that enables you to control large current with small current.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-mosfet.html#features","title":"Features","text":"<ul> <li>A small current to control large currents</li> </ul>"},{"location":"Products/Crowbits/crowbits-mosfet.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-mosfet.html#usage","title":"Usage","text":"<p>1.Control fan with relay</p> <p>1)You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Switch; An extension module, such as Crowbits-Terminal.</p> <p>2)The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3)We need to connect the S_IN interface on the Crowbits-MOSFET board to a 3.3V power supply. So, we connect the VCC interface on Crowbits-terminal board to the S_IN Interface on Crowbits-MOSFET board with Dupont line.</p> <p>4)We need to connect the fan's negative pole on the GND interface on the Crowbits-MOSFET board, the positive pole of the fan on the D_OUT Interface on Crowbits-MOSFET board.</p> <p></p> <p>5)Then, turn on the power. When you press the self-locking switch, the small fan starts to turn. When you release the self-locking switch, the small fan stops to turn.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-mp3.html","title":"Crowbits-MP3","text":""},{"location":"Products/Crowbits/crowbits-mp3.html#description","title":"Description","text":"<p>MP3 is a tiny-size and compact audio module. This module also supports general file systems like FAT16 and FAT32.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-mp3.html#features","title":"Features","text":"<ul> <li>Easy to use</li> <li>MP3, WMV and WAV audio format supported</li> <li>FAT16, FAT32 files system supported</li> </ul>"},{"location":"Products/Crowbits/crowbits-mp3.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-mp3.html#usage","title":"Usage","text":""},{"location":"Products/Crowbits/crowbits-mp3.html#1playing-music","title":"1.Playing music","text":"<p>1)You also need a power module, such as Crowbits-Power Supply; A SD card containing songs in mp3 format; A 2PIn interface speaker.</p> <p>2)Insert the SD card into the holder and connect the speaker to the \u201cSpeaker seat\".</p> <p>3)Turn the toggle switch on the Crowbits-MP3 board to the \"Audio\" position.</p> <p>4)The connection mode is shown in the figure.</p> <p></p> <p>5)Turn on the power.</p> <ul> <li> <p>You could press the \u201cPLAY\u201d button on the Crowbits-MP3 board, which can play and pause songs.</p> </li> <li> <p>You could press the \u201cUP\u201d button on the Crowbits-MP3 board, which can switch to the next song.</p> </li> <li> <p>You could press the \u201cDOWN\u201d button on the Crowbits-MP3 board, which can switch to the previous song.</p> </li> <li> <p>You could long-press the \"UP\" button on the Crowbits-MP3 board, which can increase the volume.</p> </li> <li> <p>You could long-press the \"DOWN\" button on the Crowbits-MP3 board, which can lower the volume.</p> </li> </ul>"},{"location":"Products/Crowbits/crowbits-nfc.html","title":"Crowbits-NFC","text":""},{"location":"Products/Crowbits/crowbits-nfc.html#description","title":"Description","text":"<p>The Crowbits-NFC module (Near Field Communications) uses a highly integrated transceiver module PN532 which handles contactless communication at 13.56MHz. It is designed to use IIC (default) communication protocols. You can read and write a 13.56MHz tag with this module or implement point to point data exchange with two NFC Shields.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-nfc.html#features","title":"Features","text":"<ul> <li>Uses as a PFID reader with Mifare one tags and cards(13.56 MHz).</li> </ul>"},{"location":"Products/Crowbits/crowbits-nfc.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-nfc.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cCrowbits-NFC\u201d. Unzip it and copy the folder inside to the libraries file of the Arduino IDE, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#if 0\n#include &lt;SPI.h&gt;\n#include &lt;PN532_SPI.h&gt;\n#include &lt;PN532.h&gt;\n#include &lt;NfcAdapter.h&gt;\n\nPN532_SPI pn532spi(SPI, 10);\nNfcAdapter nfc = NfcAdapter(pn532spi);\n#else\n\n#include &lt;Wire.h&gt;\n#include &lt;PN532_I2C.h&gt;\n#include &lt;PN532.h&gt;\n#include &lt;NfcAdapter.h&gt;\n\nPN532_I2C pn532_i2c(Wire);\nNfcAdapter nfc = NfcAdapter(pn532_i2c);\n#endif\n\nvoid setup(void) {\n    Serial.begin(9600);\n    Serial.println(\"NDEF Reader\");\n    nfc.begin();\n}\n\nvoid loop(void) {\n    Serial.println(\"\\nScan a NFC tag\\n\");\n    if (nfc.tagPresent())\n    {\n        NfcTag tag = nfc.read();\n        tag.print();\n    }\n    delay(5000);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Put the NFC card in the detection area, the serial port will print out the corresponding information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-non-contact-liquid-level-sensor.html","title":"Crowbits-Non-Contact Liquid Level Sensor","text":""},{"location":"Products/Crowbits/crowbits-non-contact-liquid-level-sensor.html#description","title":"Description","text":"<p>Intelligent non-contact liquid level sensor (here in after referred to as the liquid level sensor) adopted the advanced signal processing technology and high-speed signal processing chip, broke through the vessel wall thickness, the influence of realized in an airtight container level of real non-contact detection. Liquid level sensor (probe) installed on the outer wall of the container to be tested on the lower part (level of high and low), non-metallic containers without the hole, easy to install, do not affect production. Can realize various toxic substances of high pressure airtight container, strong acid, strong alkali and all kinds of liquid level detection. The material of liquid level sensor for liquid medium and container no special requirements, can be widely used.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-non-contact-liquid-level-sensor.html#features","title":"Features","text":"<ul> <li>No direct contact with liquid</li> <li>Working Voltage: 3.3V</li> <li>Induction distance can reach more than 12 mm</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-non-contact-liquid-level-sensor.html#specification","title":"Specification","text":"<ul> <li>The thickness of the induction (sensitivity) 0 \uff5e 20 mm</li> <li>humidity 5% \uff5e 100%</li> <li>The material ABS.</li> <li>Waterproof properties IP67</li> <li>Sensor dimensions(mm):28.3(L)x28.3(W)x17.0(H)</li> <li>Cable length:58.5cm</li> </ul>"},{"location":"Products/Crowbits/crowbits-non-contact-liquid-level-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board. And an output module, such as Crowbits-LED.</p> <p>2.Connect the Crowbits-Non-Contact Liquid Level Sensor to the D2 interface of the Crowbits-UNO board, and Crowbits-LED to the D9 Interface.</p> <p>3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>int liquid_level=2;\nint buzzer=9;\nint liquid_state=0;\n\nvoid setup()\n{\n   pinMode( liquid_level,INPUT);\n   pinMode(buzzer,OUTPUT);\n}\n\nvoid loop()\n{\n liquid_state=digitalRead(liquid_level);\n if(liquid_state==HIGH)\n {\n digitalWrite(buzzer,HIGH);\n }\n else\n {\n  digitalWrite(buzzer,LOW);\n }\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Then send a command to call.</p>"},{"location":"Products/Crowbits/crowbits-oled.html","title":"Crowbits-OLED","text":""},{"location":"Products/Crowbits/crowbits-oled.html#description","title":"Description","text":"<p>Crowbits- OLED is constructed from 128 x 64 dot matrix OLED module. The display offers high brightness, self-emission, high contrast ratio, slim/thin outline, wide viewing angle, wide temperature range and low power consumption.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-oled.html#features","title":"Features","text":"<ul> <li>Low power consumption</li> </ul>"},{"location":"Products/Crowbits/crowbits-oled.html#specification","title":"Specification","text":"<ul> <li>Display Color: Blue</li> <li>Resolution: 128x64</li> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-oled.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. The following sketch demonstrates a simple application of the module.</p> <p>4.Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <pre><code>#include \"U8glib.h\"\nU8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE);  \n\nvoid drawURL(void)\n{\n   u8g.setFont(u8g_font_9x18);\n   u8g.drawStr(25,10,\"Elecrow\");\n   u8g.setFont(u8g_font_7x14);\n   u8g.drawStr(5,35,\"www.elecrow.com\");\n\n}\nvoid setup(void) {\n}\n\nvoid loop(void) {\n  // picture loop\n  u8g.firstPage();  \n  do {\n    drawURL();\n  u8g.setColorIndex(1);\n  } while( u8g.nextPage() );  \n  // rebuild the picture after some delay\n  delay(200);  \n}\n</code></pre> <p>5. After the code is uploaded successfully, you will see the following words displayed on the OLED screen.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-one-wire-waterproof-temperature-sensor.html","title":"Crowbits-One Wire Waterproof Temperature Sensor","text":""},{"location":"Products/Crowbits/crowbits-one-wire-waterproof-temperature-sensor.html#description","title":"Description","text":"<p>This is a waterproofed version of the DS18B20 Temperature sensor. Handy for when you need to measure something far away, or in wet conditions. While the sensor is good up to 125 degree, the cable is jacketed in PVC so we suggest keeping it under 100 degree. Because they are digital, you don't get any signal degradation even over long distances! The DS18B20 provides 9 to 12-bit (configurable) temperature readings over a 1-Wire interface, so that only one wire (and ground) needs to be connected from a central microprocessor. It Usable with 3.0-5.5V systems. Because each DS18B20 contains a unique silicon serial number, multiple DS18B20s can exist on the same 1-Wire bus. This allows for placing temperature sensors in many different places. Applications where this feature is useful include HVAC environmental controls, sensing temperatures inside buildings, equipment or machinery, and process monitoring and control. </p>"},{"location":"Products/Crowbits/crowbits-one-wire-waterproof-temperature-sensor.html#features","title":"Features","text":"<ul> <li>9 to 12bit selectable resolution</li> <li>one digital pin for communication</li> <li>Multiple sensors can share one pin</li> <li>Query time is less than 750ms</li> </ul>"},{"location":"Products/Crowbits/crowbits-one-wire-waterproof-temperature-sensor.html#specification","title":"Specification","text":"<ul> <li>3.0V to 5.5V input</li> <li>Temperature range: -55 to +125 degree</li> <li>0.5degree Accuracy from -10 to +85 degree</li> <li>Stainless steel tube 6mm diameter by 30mm long</li> <li>Cable length: 90cm</li> </ul>"},{"location":"Products/Crowbits/crowbits-one-wire-waterproof-temperature-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the D2 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Download the library \u201cDS18B20\u201d. Unzip and put it in the libraries file of the Arduino IDE, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4.Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;OneWire.h&gt;\nOneWire  ds(2);  // on pin 10\n\nvoid setup(void) {\n  Serial.begin(9600);\n}\n\nvoid loop(void) {\n  byte i;\n  byte present = 0;\n  byte type_s;\n  byte data[12];\n  byte addr[8];\n  float celsius, fahrenheit;\n\n  if ( !ds.search(addr)) {\n    Serial.println(\"No more addresses.\");\n    Serial.println();\n    ds.reset_search();\n    delay(250);\n    return;\n  }\n\n  Serial.print(\"ROM =\");\n  for( i = 0; i &lt; 8; i++) {\n    Serial.write(' ');\n    Serial.print(addr[i], HEX);\n  }\n\n  if (OneWire::crc8(addr, 7)\u00a0!= addr[7]) {\n      Serial.println(\"CRC is not valid!\");\n      return;\n  }\n  Serial.println();\n\n  // the first ROM byte indicates which chip\n  switch (addr[0]) {\n    case 0x10:\n      Serial.println(\"  Chip = DS18S20\");  // or old DS1820\n      type_s = 1;\n      break;\n    case 0x28:\n      Serial.println(\"  Chip = DS18B20\");\n      type_s = 0;\n      break;\n    case 0x22:\n      Serial.println(\"  Chip = DS1822\");\n      type_s = 0;\n      break;\n    default:\n      Serial.println(\"Device is not a DS18x20 family device.\");\n      return;\n  } \n\n  ds.reset();\n  ds.select(addr);\n  ds.write(0x44,1);         // start conversion, with parasite power on at the end\n\n  delay(1000);     // maybe 750ms is enough, maybe not\n  // we might do a ds.depower() here, but the reset will take care of it.\n\n  present = ds.reset();\n  ds.select(addr);    \n  ds.write(0xBE);         // Read Scratchpad\n\n  Serial.print(\"  Data = \");\n  Serial.print(present,HEX);\n  Serial.print(\" \");\n  for ( i = 0; i &lt; 9; i++) {           // we need 9 bytes\n    data[i] = ds.read();\n    Serial.print(data[i], HEX);\n    Serial.print(\" \");\n  }\n  Serial.print(\" CRC=\");\n  Serial.print(OneWire::crc8(data, 8), HEX);\n  Serial.println();\n\n  // convert the data to actual temperature\n\n  unsigned int raw = (data[1] &lt;&lt; 8) | data[0];\n  if (type_s) {\n    raw = raw &lt;&lt; 3; // 9 bit resolution default\n    if (data[7] == 0x10) {\n      // count remain gives full 12 bit resolution\n      raw = (raw &amp; 0xFFF0) + 12 - data[6];\n    }\n  } else {\n    byte cfg = (data[4] &amp; 0x60);\n    if (cfg == 0x00) raw = raw &lt;&lt; 3;  // 9 bit resolution, 93.75 ms\n    else if (cfg == 0x20) raw = raw &lt;&lt; 2; // 10 bit res, 187.5 ms\n    else if (cfg == 0x40) raw = raw &lt;&lt; 1; // 11 bit res, 375 ms\n    // default is 12 bit resolution, 750 ms conversion time\n  }\n  celsius = (float)raw / 16.0;\n  fahrenheit = celsius * 1.8 + 32.0;\n  Serial.print(\"  Temperature = \");\n  Serial.print(celsius);\n  Serial.print(\" Celsius, \");\n  Serial.print(fahrenheit);\n  Serial.println(\" Fahrenheit\");\n}\n</code></pre> <p>5.After the upload is successful, open the serial port monitor, the baud rate is set to 9600. You can see the temperature value printed out.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-photo-electric-counter.html","title":"Crowbits-Photo Electric Counter","text":""},{"location":"Products/Crowbits/crowbits-photo-electric-counter.html#description","title":"Description","text":"<p>The Photo Electric Counter is a digital input module, it converts the optical signal into the electric signal. Due to the U-shaped design of the photoelectric sensor, it can be used as a mini door with a counting function for your circuit.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-photo-electric-counter.html#features","title":"Features","text":"<ul> <li>Digital input module</li> <li>Easy to use</li> <li>High sensitivity</li> </ul>"},{"location":"Products/Crowbits/crowbits-photo-electric-counter.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-photo-electric-counter.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When an object is detected in the U-shaped slot, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-pir-sensor.html","title":"Crowbits-PIR Sensor","text":""},{"location":"Products/Crowbits/crowbits-pir-sensor.html#description","title":"Description","text":"<p>The PIR sensor is a digital input module, it's an electronic sensor that measures infrared light radiating from objects in its field of view. It's often used in PIR-based motion detectors.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-pir-sensor.html#features","title":"Features","text":"<ul> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-pir-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-pir-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the sensor detects someone moving, the LED behind it lights up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-potentiometer.html","title":"Crowbits-Potentiometer","text":""},{"location":"Products/Crowbits/crowbits-potentiometer.html#description","title":"Description","text":"<p>The potentiometer is an analog input module, it acts like a variable resistor, it controls your circuit through adjusting the resistance in the whole circuit.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-potentiometer.html#features","title":"Features","text":"<ul> <li>Analog input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-potentiometer.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>The range of resistance of the potentiometer: 0~5K\u03a9</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-potentiometer.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. Rotate the rheostat, you can see that the LED will have a progressive effect of darkening or brightening.</p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-power-supply.html","title":"Crowbits-Power Supply","text":""},{"location":"Products/Crowbits/crowbits-power-supply.html#description","title":"Description","text":"<p>The power supply is the heart of the Crowbits, The power supply is the power source of the entire Crowbits eco-system and modules, allowing to power them both by battery and power cord connection. On the technical side, the battery is a Lithium battery, the same battery that most of us have inside our phone these days. The voltage of the battery is 3.7V, 3.7 is a bit too much for our use case and the CrowBits, in order to protect them we step down using a module called DC-DC regulator from 3.7V to 3.3V - this allows us to power on the Crowbits safety. The power supply module is rechargeable, it can be charged by a 5V/1A power adapter through a micro USB interface.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-power-supply.html#features","title":"Features","text":"<ul> <li>Single output port.</li> <li>Output indicator.</li> </ul>"},{"location":"Products/Crowbits/crowbits-power-supply.html#specification","title":"Specification","text":"<ul> <li>Output Voltage: 3.3V DC</li> <li>Charging method: Micro USB 5V DC</li> <li>Dimensions: 56(L)*31(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-power-supply.html#usage","title":"Usage","text":"<p>1. You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Switch; An extension module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When you press the self-locking switch, the LED light.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-power-supplys.html","title":"Crowbits-Power Supply(S)","text":""},{"location":"Products/Crowbits/crowbits-power-supplys.html#description","title":"Description","text":"<p>The power supply is the heart of the Crowbits, The power supply is the power source of the entire Crowbits eco-system and modules, allowing to power them both by battery and power cord connection. On the technical side, the battery is a Lithium battery, the same battery that most of us have inside our phone these days. The voltage of the battery is 3.7V, 3.7 is a bit too much for our use case and the CrowBits, in order to protect them we step down using a module called DC-DC regulator from 3.7V to 3.3V - this allows us to power on the Crowbits safety. The power supply module is rechargeable, it can be charged by a 5V/1A power adapter through a micro USB interface.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-power-supplys.html#features","title":"Features","text":"<ul> <li>Single output port.</li> <li>Output indicator.</li> </ul>"},{"location":"Products/Crowbits/crowbits-power-supplys.html#specification","title":"Specification","text":"<ul> <li>Output Voltage: 3.3V DC</li> <li>Charging method: Micro USB 5V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-power-supplys.html#usage","title":"Usage","text":"<p>1. You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Switch; An extension module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When you press the self-locking switch, the LED light.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-pressure-sensor.html","title":"Crowbits-Pressure Sensor","text":""},{"location":"Products/Crowbits/crowbits-pressure-sensor.html#description","title":"Description","text":"<p>The pressure sensor is an analog input module, it is a touch-activated sensor. The pressure sensor controls your circuit by how much pressure you put on it.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-pressure-sensor.html#features","title":"Features","text":"<ul> <li>Analog input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-pressure-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Range of forces: 0.2N to 20N (100g~10KG)</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-pressure-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Turn on the power. Press the sensor slowly and you will see that the LED behind it will gradually light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-protoboard.html","title":"Crowbits-Protoboard","text":""},{"location":"Products/Crowbits/crowbits-protoboard.html#description","title":"Description","text":"<p>Protoboard is a module with a breadboard, you can build all kinds of circuits you want, and lead out 16 interfaces.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-protoboard.html#features","title":"Features","text":"<ul> <li>Easy to use</li> <li>Breadboard style</li> </ul>"},{"location":"Products/Crowbits/crowbits-protoboard.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 56(L)*56(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-protoboard.html#usage","title":"Usage","text":"<p>1. You can connect any position on the breadboard to the female connector with a DuPont cable, and you can output the signal to other modules.</p> <p>2. For example, I want to connect a position on the breadboard to the fourth output port, which can be connected as follows.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-pulse-sensor.html","title":"Crowbits-Pulse Sensor","text":""},{"location":"Products/Crowbits/crowbits-pulse-sensor.html#description","title":"Description","text":"<p>The Pulse Sensor is used to measure the heart rate of the human. Heart rate data can be really useful whether you\u2019re designing an exercise routine, studying your activity or anxiety levels or just want your shirt to blink with your heart beat. The problem is that heart rate can be difficult to measure. Luckily, the Pulse Sensor Amped can solve that problem! The Pulse Sensor Amped is a plug-and-play heart-rate sensor for Arduino.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-pulse-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-pulse-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: Analog input</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-pulse-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A2 interface o the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>/*\n&gt;&gt; Pulse Sensor Amped 1.2 &lt;&lt;\nThis code is for Pulse Sensor Amped by Joel Murphy and Yury Gitman\n    www.pulsesensor.com \n    &gt;&gt;&gt; Pulse Sensor purple wire goes to Analog Pin 0 &lt;&lt;&lt;\nPulse Sensor sample aquisition and processing happens in the background via Timer 2 interrupt. 2mS sample rate.\nPWM on pins 3 and 11 will not work when using this code, because we are using Timer 2!\nThe following variables are automatically updated:\nSignal\u00a0:    int that holds the analog signal data straight from the sensor. updated every 2mS.\nIBI  :      int that holds the time interval between beats. 2mS resolution.\nBPM  :      int that holds the heart rate value, derived every beat, from averaging previous 10 IBI values.\nQS  :       boolean that is made true whenever Pulse is found and BPM is updated. User must reset.\nPulse\u00a0:     boolean that is true when a heartbeat is sensed then false in time with pin13 LED going out.\n\nThis code is designed with output serial data to Processing sketch \"PulseSensorAmped_Processing-xx\"\nThe Processing sketch is a simple data visualizer. \nAll the work to find the heartbeat and determine the heartrate happens in the code below.\nPin 13 LED will blink with heartbeat.\nIf you want to use pin 13 for something else, adjust the interrupt handler\nIt will also fade an LED on pin fadePin with every beat. Put an LED and series resistor from fadePin to GND.\nCheck here for detailed code walkthrough:\nhttp://pulsesensor.myshopify.com/pages/pulse-sensor-amped-arduino-v1dot1\n\nCode Version 1.2 by Joel Murphy &amp; Yury Gitman  Spring 2013\nThis update fixes the firstBeat and secondBeat flag usage so that realistic BPM is reported.\n\n*/\n\n\n//  VARIABLES\nint pulsePin = 2;                 // Pulse Sensor purple wire connected to analog pin 0\nint blinkPin = 13;                // pin to blink led at each beat\nint fadePin = 5;                  // pin to do fancy classy fading blink at each beat\nint fadeRate = 0;                 // used to fade LED on with PWM on fadePin\n\n\n// these variables are volatile because they are used during the interrupt service routine!\nvolatile int BPM;                   // used to hold the pulse rate\nvolatile int Signal;                // holds the incoming raw data\nvolatile int IBI = 600;             // holds the time between beats, must be seeded! \nvolatile boolean Pulse = false;     // true when pulse wave is high, false when it's low\nvolatile boolean QS = false;        // becomes true when Arduoino finds a beat.\n\n\nvoid setup(){\n  pinMode(blinkPin,OUTPUT);         // pin that will blink to your heartbeat!\n  pinMode(fadePin,OUTPUT);          // pin that will fade to your heartbeat!\n  Serial.begin(115200);             // we agree to talk fast!\n  interruptSetup();                 // sets up to read Pulse Sensor signal every 2mS \n   // UN-COMMENT THE NEXT LINE IF YOU ARE POWERING The Pulse Sensor AT LOW VOLTAGE, \n   // AND APPLY THAT VOLTAGE TO THE A-REF PIN\n   //analogReference(EXTERNAL);   \n}\n\n\n\nvoid loop(){\n  sendDataToProcessing('S', Signal);     // send Processing the raw Pulse Sensor data\n  if (QS == true){                       // Quantified Self flag is true when arduino finds a heartbeat\n        fadeRate = 255;                  // Set 'fadeRate' Variable to 255 to fade LED with pulse\n        sendDataToProcessing('B',BPM);   // send heart rate with a 'B' prefix\n        sendDataToProcessing('Q',IBI);   // send time between beats with a 'Q' prefix\n        QS = false;                      // reset the Quantified Self flag for next time    \n     }\n\n  ledFadeToBeat();\n\n  delay(20);                             //  take a break\n}\n\n\nvoid ledFadeToBeat(){\n    fadeRate -= 15;                         //  set LED fade value\n    fadeRate = constrain(fadeRate,0,255);   //  keep LED fade value from going into negative numbers!\n    analogWrite(fadePin,fadeRate);          //  fade LED\n  }\n\n\nvoid sendDataToProcessing(char symbol, int data ){\n    Serial.print(symbol);                // symbol prefix tells Processing what type of data is coming\n    Serial.println(data);                // the data to send culminating in a carriage return\n  }\n</code></pre> <p>4.Unzip the compressed processing file and run the processing software inside.</p> <p>5.Open the sample code PulseSensorAmpd_Processing_1dot1 in the folder, and then run the program.</p> <pre><code>//**************\n//IR receive demo v1.0\n//Connect the IR sent pins to D2 for this demo\n//******************************\n#include &lt;IRSendRev.h&gt;\n//#include &lt;IRSendRevInt.h&gt;\n\nvoid setup()\n{\n    Serial.begin(9600);\n    IR.Init(2);\n    Serial.println(\"init over\");\n}\n\nunsigned char dta[20];\n\nvoid loop()\n{\n    if(IR.IsDta())\n    {\n       // IR.Recv(dta);\n        int length= IR.Recv(dta);\n        for (int i =0;i&lt;length;i++)\n        {\n          Serial.print(dta[i]);\n          Serial.print(\"\\t\");\n        }\n        Serial.println();\n// Very Important:\n// the received data is comprised of the trsmission parameters , please refer to \n// the sendTest.ino in the library\u00a0;\n    }\n\n\n}\n</code></pre> <p>6. After downloading the two programs, open the serial port of the motherboard connected to the Crowbits of the Crowbits-IR Receiver module, the baud rate is set to 9600, and then you will receive the information sent by the transmitter module, as shown in the figure:</p> <p></p>"},{"location":"Products/Crowbits/crowbits-reaction.html","title":"Crowbits-Reaction","text":""},{"location":"Products/Crowbits/crowbits-reaction.html#description","title":"Description","text":"<p>The reaction sensor is a digital input module.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-reaction.html#features","title":"Features","text":"<ul> <li>Low power consumption</li> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-reaction.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-reaction.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the sensor detects a hand is approaching, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-recorder.html","title":"Crowbits-Recorder","text":""},{"location":"Products/Crowbits/crowbits-recorder.html#description","title":"Description","text":"<p>The recording module can record your voice, and is easy to store and read.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-recorder.html#features","title":"Features","text":"<ul> <li>Low power consumption</li> <li>User-friendly operation</li> </ul>"},{"location":"Products/Crowbits/crowbits-recorder.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-recorder.html#usage","title":"Usage","text":"<p>1. You also need a power module, such as Crowbits-Power Supply; A 2 Pin interface speaker.</p> <p>2. Connect the speaker to the seat, the connection mode is shown in the figure.</p> <p></p> <p>3. Turn on the power.</p> <ul> <li> <p>When you record, you need to press the \u201cRecord\u201d button, the LED on the board will light up until you finish recording.</p> </li> <li> <p>You could press the \u201cPlay2\u201d button to play your recording.</p> </li> <li> <p>You could press the \u201cPlay1\u201d button to pause your recording</p> </li> </ul>"},{"location":"Products/Crowbits/crowbits-relay.html","title":"Crowbits-Relay","text":""},{"location":"Products/Crowbits/crowbits-relay.html#description","title":"Description","text":"<p>The relay is a digital output module, it's an electronic control device that has a control system (also known as an input circuit) and a controlled system (also known as an output circuit), which is usually used in automatic control circuits.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-relay.html#features","title":"Features","text":"<ul> <li>A small current to control large currents</li> </ul>"},{"location":"Products/Crowbits/crowbits-relay.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-relay.html#usage","title":"Usage","text":""},{"location":"Products/Crowbits/crowbits-relay.html#1control-fan-with-relay","title":"1.Control fan with relay","text":"<p>1)You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Switch; An extension module, such as Crowbits-Terminal.</p> <p>2)The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p>3)We need to connect the COM interface on the Crowbits-relay board to a 3.3V power supply. So, we connect the VCC interface on Crowbits-terminal board to the COM port on Crowbits-Relay board with Dupont line.</p> <p>4)We need to connect the fan's negative pole on the GND interface on the Crowbits-terminal board, the positive pole of the fan on the NC Interface or NO Interface on Crowbits-Relay board. For example, I'm connecting to the NO interface.</p>"},{"location":"Products/Crowbits/crowbits-rgb-led.html","title":"Crowbits-RGB LED","text":""},{"location":"Products/Crowbits/crowbits-rgb-led.html#description","title":"Description","text":"<p>It is composed of two RGB lamp beads and can display various colors. Respond to changes in input signals in monochrome, full-color, and gradual manner. Users can control all the LED with only one microcontroller pin! Besides, the LED bar can be also chainable, that is, you can connect more than one LED bar together to make your project more dreamful. In this module , you can control every LED whit different color at the same time.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-rgb-led.html#features","title":"Features","text":"<ul> <li>Can achieve 256-level brightness display</li> </ul>"},{"location":"Products/Crowbits/crowbits-rgb-led.html#specification","title":"Specification","text":"<ul> <li>Interface Type\uff1aGPIO</li> <li>Operating Voltage: 3.3V DC</li> <li>imensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-rgb-led.html#application-ideas","title":"Application Ideas","text":"<ul> <li>Display test information</li> </ul>"},{"location":"Products/Crowbits/crowbits-rgb-led.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the D4 interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library Crowbits-RGB LED library. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Open the code directly by the path: File-&gt; Example-&gt; Adafruit_NeoPixel-&gt; strandtest.Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;Adafruit_NeoPixel.h&gt;\n\n#define PIN 4\n\n// Parameter 1 = number of pixels in strip\n// Parameter 2 = pin number (most are valid)\n// Parameter 3 = pixel type flags, add together as needed:\n//   NEO_KHZ800  800 KHz bitstream (most NeoPixel products w/WS2812 LEDs)\n//   NEO_KHZ400  400 KHz (classic 'v1' (not v2) FLORA pixels, WS2811 drivers)\n//   NEO_GRB     Pixels are wired for GRB bitstream (most NeoPixel products)\n//   NEO_RGB     Pixels are wired for RGB bitstream (v1 FLORA pixels, not v2)\nAdafruit_NeoPixel strip = Adafruit_NeoPixel(60, PIN, NEO_GRB + NEO_KHZ800);\n\nvoid setup() {\n  strip.begin();\n  strip.show(); // Initialize all pixels to 'off'\n}\n\nvoid loop() {\n  // Some example procedures showing how to display to the pixels:\n  colorWipe(strip.Color(255, 0, 0), 50); // Red\n  colorWipe(strip.Color(0, 255, 0), 50); // Green\n  colorWipe(strip.Color(0, 0, 255), 50); // Blue\n  // Send a theater pixel chase in...\n  theaterChase(strip.Color(127, 127, 127), 50); // White\n  theaterChase(strip.Color(127,   0,   0), 50); // Red\n  theaterChase(strip.Color(  0,   0, 127), 50); // Blue\n\n  rainbow(20);\n  rainbowCycle(20);\n  theaterChaseRainbow(50);\n}\n\n// Fill the dots one after the other with a color\nvoid colorWipe(uint32_t c, uint8_t wait) {\n  for(uint16_t i=0; i&lt;strip.numPixels(); i++) {\n      strip.setPixelColor(i, c);\n      strip.show();\n      delay(wait);\n  }\n}\n\nvoid rainbow(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j&lt;256; j++) {\n    for(i=0; i&lt;strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel((i+j) &amp; 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\n// Slightly different, this makes the rainbow equally distributed throughout\nvoid rainbowCycle(uint8_t wait) {\n  uint16_t i, j;\n\n  for(j=0; j&lt;256*5; j++) { // 5 cycles of all colors on wheel\n    for(i=0; i&lt; strip.numPixels(); i++) {\n      strip.setPixelColor(i, Wheel(((i * 256 / strip.numPixels()) + j) &amp; 255));\n    }\n    strip.show();\n    delay(wait);\n  }\n}\n\n//Theatre-style crawling lights.\nvoid theaterChase(uint32_t c, uint8_t wait) {\n  for (int j=0; j&lt;10; j++) {  //do 10 cycles of chasing\n    for (int q=0; q &lt; 3; q++) {\n      for (int i=0; i &lt; strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, c);    //turn every third pixel on\n      }\n      strip.show();\n\n      delay(wait);\n\n      for (int i=0; i &lt; strip.numPixels(); i=i+3) {\n        strip.setPixelColor(i+q, 0);        //turn every third pixel off\n      }\n    }\n  }\n}\n\n//Theatre-style crawling lights with rainbow effect\nvoid theaterChaseRainbow(uint8_t wait) {\n  for (int j=0; j &lt; 256; j++) {     // cycle all 256 colors in the wheel\n    for (int q=0; q &lt; 3; q++) {\n        for (int i=0; i &lt; strip.numPixels(); i=i+3) {\n          strip.setPixelColor(i+q, Wheel( (i+j)\u00a0% 255));    //turn every third pixel on\n        }\n        strip.show();\n\n        delay(wait);\n\n        for (int i=0; i &lt; strip.numPixels(); i=i+3) {\n          strip.setPixelColor(i+q, 0);        //turn every third pixel off\n        }\n    }\n  }\n}\n\n// Input a value 0 to 255 to get a color value.\n// The colours are a transition r - g - b - back to r.\nuint32_t Wheel(byte WheelPos) {\n  if(WheelPos &lt; 85) {\n   return strip.Color(WheelPos * 3, 255 - WheelPos * 3, 0);\n  } else if(WheelPos &lt; 170) {\n   WheelPos -= 85;\n   return strip.Color(255 - WheelPos * 3, 0, WheelPos * 3);\n  } else {\n   WheelPos -= 170;\n   return strip.Color(0, WheelPos * 3, 255 - WheelPos * 3);\n  }\n}\n</code></pre> <p>5. After successfully uploading the code, you will see the color of the light change.</p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-rgb-matrix.html","title":"Crowbits-RGB Matrix","text":""},{"location":"Products/Crowbits/crowbits-rgb-matrix.html#description","title":"Description","text":"<p>The RGB Matrix module is an 8 * 8 matrix display module composed of 64 rgb led lamp beads. It can respond to changes in input signals in monochrome, full-color, gradual, and horse racing modes, and can also display simple graphics.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-rgb-matrix.html#features","title":"Features","text":"<ul> <li>Low power consumption</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-rgb-matrix.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-rgb-matrix.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the D11 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library FastLED-3.2.10. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;FastLED.h&gt;\n#define NUM_LEDS 64\n\nCRGBArray&lt;NUM_LEDS&gt; leds;\n\nvoid setup() { FastLED.addLeds&lt;WS2812B,11,GRB&gt;(leds, NUM_LEDS); }\n\nvoid loop(){ \n  static uint8_t hue;\n  for(int i = 0; i &lt; NUM_LEDS/2; i++) {   \n    // fade everything out\n    leds.fadeToBlackBy(40);\n\n    // let's set an led value\n    leds[i] = CHSV(hue++,255,255);\n\n    // now, let's first 20 leds to the top 20 leds, \n    leds(NUM_LEDS/2,NUM_LEDS-1) = leds(NUM_LEDS/2 - 1 ,0);\n    FastLED.delay(33);\n  }\n}\n</code></pre> <p>5. After the upload is successful, you can see the phenomenon that the RGB lights alternate from red, green and blue.</p> <p></p> <p></p>"},{"location":"Products/Crowbits/crowbits-rtc.html","title":"Crowbits-RTC","text":""},{"location":"Products/Crowbits/crowbits-rtc.html#description","title":"Description","text":"<p>If you want to make your own electronic watch, an RTC module is needed to generate you the right timer, with low power consumption. Crowbits-RTC module is based on the clock chip DS1307 which communicate with microcontrollers with I2C protocol. The clock/calendar provides seconds, minutes, hours, day, date, month, and year information. The end of the month date is automatically adjusted for months with fewer than 31 days, including corrections for leap year.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-rtc.html#features","title":"Features","text":"<ul> <li>Low power consumption</li> </ul>"},{"location":"Products/Crowbits/crowbits-rtc.html#specification","title":"Specification","text":"<ul> <li>Interface Type: I2C</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-rtc.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the I2C interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cRTC\u201d. Unzip and put it in the libraries file of the Arduino IDE, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;Wire.h&gt;\n#include \"RTClib.h\"\nRTC_DS1307 RTC;\n\nvoid setup () {\n    Serial.begin(9600);\n    Wire.begin();\n    RTC.begin();\n  if (! RTC.isrunning()) {\n    Serial.println(\"RTC is NOT running!\");\n    // following line sets the RTC to the date &amp; time this sketch was compiled\n    RTC.adjust(DateTime(__DATE__, __TIME__));\n  }\n}\nvoid loop () {\n    DateTime now = RTC.now(); \n    Serial.print(now.year(), DEC);\n    Serial.print('/');\n    Serial.print(now.month(), DEC);\n    Serial.print('/');\n    Serial.print(now.day(), DEC);\n    Serial.print(' ');\n    Serial.print(now.hour(), DEC);\n    Serial.print(':');\n    Serial.print(now.minute(), DEC);\n    Serial.print(':');\n    Serial.print(now.second(), DEC);\n    Serial.println(); \n    delay(1000);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. You can see the time when the serial port is printed out.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-servo-control.html","title":"Crowbits-Servo Control","text":""},{"location":"Products/Crowbits/crowbits-servo-control.html#description","title":"Description","text":"<p>The servo control is a digital input module that used to control the servo. The servo is a type of motor that can rotate at a certain angle, the rotation direction and angle can be controlled by the servo control.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-servo-control.html#features","title":"Features","text":"<ul> <li>Digital input module</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-servo-control.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Angle range: -90 degrees to 90 degrees</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-servo-control.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and a servo.</p> <p>2. The connection mode is shown in the figure.</p> <p>3. Turn on the power. You could press \"Mode\" key to select the working mode.</p> <ul> <li>Manual: This is a manual mode, you could turn the rheostat to control the rotation of the servo.</li> <li>Origin: This is back to the origin mode. When you switch this mode, the servo will return to the origin.</li> <li>Auto: This is an automatic mode, which automatically controls the rotation of the servo.</li> </ul>"},{"location":"Products/Crowbits/crowbits-switch.html","title":"Crowbits-Switch","text":""},{"location":"Products/Crowbits/crowbits-switch.html#description","title":"Description","text":"<p>The switch is a digital input module, it comes with its own mechanical locking function. It is useful in controlling power connections most of the time.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-switch.html#features","title":"Features","text":"<ul> <li>Own mechanical locking function</li> <li>Digital input module</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-switch.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-switch.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power, press the button of the self-locking switch, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-terminal.html","title":"Crowbits-Terminal","text":""},{"location":"Products/Crowbits/crowbits-terminal.html#description","title":"Description","text":"<p>The terminal is a transfer module, it allows you to connect output modules with Crowbits by jumper wire. Compared with traditional screw terminals, our screw terminal module doesn\u2019t require a screwdriver or other tools to operate, the jumper wire can be directly inserted into the terminal by hand.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-terminal.html#features","title":"Features","text":"<ul> <li>3.3V/5V Compatible</li> <li>High current/voltage adaptable</li> </ul>"},{"location":"Products/Crowbits/crowbits-terminal.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-terminal.html#usage","title":"Usage","text":"<p>The Crowbits-Terminal has four ports including GND, VCC and two other ports. It usually be used to interface Crowtail wires(signals) with other external non-Crowtail modules</p> <p></p>"},{"location":"Products/Crowbits/crowbits-thumb-joystick.html","title":"Crowbits-Thumb Joystick","text":""},{"location":"Products/Crowbits/crowbits-thumb-joystick.html#description","title":"Description","text":"<p>It is composed of two sliding rheostats of X-axis and Y-axis, which can control the operated object or object to move left, right, up and down. There is a sliding resistor on the left and bottom of the rocker. When there is no sliding, the rocker is at the middle 0 point. When the rocker is moved up and down, the sliding resistance in the left direction starts to move, and the resistance value changes When the joystick is moved to the left and right, the resistance value of the lower sliding resistance changes. The main control device will read these two values to judge the change of the joystick, and you can determine in which direction the joystick moves.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-thumb-joystick.html#features","title":"Features","text":"<ul> <li>Analog output (Maximal value will be got when the button is pushed)</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-thumb-joystick.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 56(L)*31(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-thumb-joystick.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A2 and A3 interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board</p> <pre><code>int joystick_x = 0;\nint joystick_y = 0;\nint key_value = 0;\n\nvoid setup()\n{\n  Serial.begin(9600);\n}\n\n\nvoid loop()\n{\n  joystick_scan();\n  key_scan();\n  delay(200);\n}\n\nvoid joystick_scan()\n{\n  joystick_x = analogRead(A3);\n  joystick_y = analogRead(A2);\n  Serial.println(joystick_x);\n  Serial.println(joystick_y);\n  if ((joystick_x &lt; 535) &amp;&amp; (joystick_y &gt; 760))\n  {\n    Serial.println(\"UP\");\n  }\n  if ((joystick_x &lt; 535) &amp;&amp; (joystick_y &lt; 260))\n  {\n    Serial.println(\"DOWN\");\n  }\n  if ((joystick_x &gt; 760) &amp;&amp; (joystick_y &lt; 535))\n  {\n    Serial.println(\"LEFT\");\n  }\n  if ((joystick_x &lt; 280) &amp;&amp; (joystick_y &lt; 535))\n  {\n    Serial.println(\"RIGHT\");\n  }\n}\n\nvoid key_scan()\n{\n  key_value = analogRead(A0);\n  //Serial.println(key_value);\n  if ((key_value &lt; 890) &amp;&amp; (key_value &gt; 850))\n  {\n    Serial.println(\"K1 Button press\");\n  }\n  if ((key_value &lt; 365) &amp;&amp; (key_value &gt; 325))\n  {\n    Serial.println(\"K2 Button press\");\n  }\n  if ((key_value &lt; 60) &amp;&amp; (key_value &gt; 20))\n  {\n    Serial.println(\"K3 Button press\");\n  }\n  if ((key_value &lt; 540) &amp;&amp; (key_value &gt; 500))\n  {\n    Serial.println(\"K4 Button press\");\n  }\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. By shaking the remote sensing, you can see the direction and position information of the serial port printing.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-tilt-switch.html","title":"Crowbits-Tilt Switch","text":""},{"location":"Products/Crowbits/crowbits-tilt-switch.html#description","title":"Description","text":"<p>The tilt switch is a digital input module, it turns on and off depending on the tilt direction, it can be used to detect the tilt orientation.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-tilt-switch.html#features","title":"Features","text":"<ul> <li>Digital input module</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-tilt-switch.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-tilt-switch.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the tilt switch is tilted, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-touch-sensor.html","title":"Crowbits-Touch Sensor","text":""},{"location":"Products/Crowbits/crowbits-touch-sensor.html#description","title":"Description","text":"<p>The touch sensor is a digital input module, it\u2019s a capacitive touch sensor. The touch sensor only has to be touched by an object to operate, it can be used as a touch switch.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-touch-sensor.html#features","title":"Features","text":"<ul> <li>Low power consumption</li> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-touch-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-touch-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p>3. Then, turn on the power. When the sensor detects a hand touch, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-tpl5111-timer.html","title":"Crowbits-TPL5111 Timer","text":""},{"location":"Products/Crowbits/crowbits-tpl5111-timer.html#description","title":"Description","text":"<p>TPL5111 Timer is a stand-alone breakout that will turn any electronics into low-power electronics. It can be used to activate or deactivate your electronic device via internal time (The timing time can be up to 1 hour).</p> <p></p>"},{"location":"Products/Crowbits/crowbits-tpl5111-timer.html#features","title":"Features","text":"<ul> <li>6 kinds of timing time</li> <li>Timer accuracy: 1% (typical)</li> <li>Timing mode: manual</li> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-tpl5111-timer.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-tpl5111-timer.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Turn on the power. Toggle a time on the DIP switch (for example, I set it to 10s), press the \"Start\" button, the LED light behind it will turn on after 10s.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-trigger-delay.html","title":"Crowbits-Trigger Delay","text":""},{"location":"Products/Crowbits/crowbits-trigger-delay.html#description","title":"Description","text":"<p>The trigger delay can keep the signal outputs by input module for a certain period of time. The trigger delay is based on an RC circuit, an RC circuit (resistor-capacitor circuit) is an electric circuit composed of resistors and capacitor, which is a way to create a time delay in your circuit. The RC delay circuit works on the principle of the RC charging and discharging. We know that the capacitor is able to store electrical energy they act like small batteries and can store or release the energy as required. When power for the delay module, the capacitor will be charged, and when the voltage of the capacitor reaches a certain value, the capacitor will discharge. The charging and discharging of the energy of a capacitor takes a certain time that we called time delay.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-trigger-delay.html#features","title":"Features","text":"<ul> <li>Single input port.</li> <li>Single output port.</li> <li>Output indicator.</li> </ul>"},{"location":"Products/Crowbits/crowbits-trigger-delay.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-trigger-delay.html#usage","title":"Usage","text":"<p>1)You also need a power module, such as Crowbits-Power Supply; An input module, such as Crowbits-Touch Sensor and Crowbits-Trigger delay; An extension module, such as Crowbits-LED.</p> <p>2)The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3)Then, press the Touch Sensor. the LED light.</p> <p></p> <p>4)Let go of Touch Sensor\uff0cthe LED slowly goes out.</p> <p></p> <p>5)Rotate the knob to adjust the speed of the LED light off.</p>"},{"location":"Products/Crowbits/crowbits-ultrasonic-ranging-sensor.html","title":"Crowbits-Ultrasonic Ranging Sensor","text":""},{"location":"Products/Crowbits/crowbits-ultrasonic-ranging-sensor.html#description","title":"Description","text":"<p>This HC-SR04 Ultrasonic Ranging Sensor is a non-contact distance measurement module with stable performance and high ranging accuracy, with the inexpensive price. The measurement range can be up to 5M, which would be helpful for your project such as robotic Obstacle Avoidance and so on.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-ultrasonic-ranging-sensor.html#features","title":"Features","text":"<ul> <li>High precision</li> <li>Stable</li> </ul>"},{"location":"Products/Crowbits/crowbits-ultrasonic-ranging-sensor.html#specification","title":"Specification","text":"<ul> <li>Ranging distance: 2cm to 500 cm</li> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-ultrasonic-ranging-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of digital display.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the D4 and D5 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Download the library \u201cUltrasonic\u201d. Unzip and put it in the libraries file, for example: C:\\Program Files (x86)\\Arduino\\libraries.</p> <p>4. Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;Ultrasonic.h&gt;\nUltrasonic ultrasonic(4,5);//Init an Ultrasonic object\nint Distance;\nvoid setup() {\nSerial.begin(9600);\n}\n\nvoid loop()\n{\n Distance=ultrasonic.Ranging(CM);//get the current result;\n delay(100);\n Serial.print(\"the distance is \");\n Serial.println(Distance);\n delay(1000);\n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. Put an object in front of the sensor, the serial port will print the corresponding distance, as shown in the figure:</p> <p></p>"},{"location":"Products/Crowbits/crowbits-uno.html","title":"Crowbits-UNO","text":""},{"location":"Products/Crowbits/crowbits-uno.html#description","title":"Description","text":"<p>The Crowbits-UNO mainboard is a microcontroller board that completely compatible with the Arduino UNO. It is based on the Atmega328P, which is widely also used in the Arduino Uno.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-uno.html#features","title":"Features","text":"<ul> <li>Wireless programming</li> <li>With Bluetooth module</li> <li>Battery powered</li> </ul>"},{"location":"Products/Crowbits/crowbits-uno.html#specification","title":"Specification","text":"<ul> <li>Output Voltage: 3.3V DC</li> <li>Charging method: DC 5V Micro USB</li> <li>Battery capacity: 650mAh</li> <li>Dimensions: 56(L)*56(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-uno.html#usage","title":"Usage","text":"<p>The interface design is compatible with any module in the Crowbits suite.</p>"},{"location":"Products/Crowbits/crowbits-uv-sensor.html","title":"Crowbits-UV Sensor","text":""},{"location":"Products/Crowbits/crowbits-uv-sensor.html#description","title":"Description","text":"<p>The Crowbits-UV Sensor is easy to use the ultraviolet light sensor. The MP8511 UV (ultraviolet) Sensor works by outputting an analog signal in relation to the amount of UV light that's detected. This breakout can be very handy in creating devices that warn the user of sunburn or detect the UV index as it relates to weather conditions.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-uv-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-uv-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-uv-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2. Connect the module to the A2 and A3 interface of the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3. Upload the following code to the Crowbits-UNO board.</p> <pre><code>/* \nMP8511 UV Sensor Read Example\nThe MP8511 UV Sensor outputs an analog signal in relation to the amount of UV light it detects.\nThis sensor detects 280-390nm light most effectively. This is categorized as part of the UVB (burning rays)\nspectrum and most of the UVA (tanning rays) spectrum.\nThere's lots of good UV radiation reading out there: \n*/\n//Hardware pin definitions\nint UVOUT = A3; //Output from the sensor\nint REF_3V3 = A2; //3.3V power on the Arduino board\nvoid setup()\n{\n Serial.begin(9600);\n pinMode(UVOUT, INPUT);\n pinMode(REF_3V3, INPUT);\n Serial.println(\"MP8511 example\");\n}\nvoid loop()\n{\n int uvLevel = averageAnalogRead(UVOUT);\n int refLevel = averageAnalogRead(REF_3V3);\n //Use the 3.3V power pin as a reference to get a very accurate output value from sensor\n float outputVoltage = 3.3 / refLevel * uvLevel;  \n float uvIntensity = mapfloat(outputVoltage, 0.99, 2.9, 0.0, 15.0);\n Serial.print(\"MP8511 output: \");\n Serial.print(uvLevel);\n Serial.print(\" MP8511 voltage: \");\n Serial.print(outputVoltage);\n Serial.print(\" UV Intensity (mW/cm^2): \");\n Serial.print(uvIntensity);  \n Serial.println();  \n delay(100);\n}\n//Takes an average of readings on a given pin\n//Returns the average\nint averageAnalogRead(int pinToRead)\n{\n  byte numberOfReadings = 8;\n  unsigned int runningValue = 0; \n  for(int x = 0\u00a0; x &lt; numberOfReadings\u00a0; x++)\n    runningValue += analogRead(pinToRead);\n  runningValue /= numberOfReadings;\n  return(runningValue);  \n}\n//The Arduino Map function but for floats\nfloat mapfloat(float x, float in_min, float in_max, float out_min, float out_max)\n{\n  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;\n}\n</code></pre> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 9600, you can see the following print information.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-vibration-motor.html","title":"Crowbits-Vibration Motor","text":""},{"location":"Products/Crowbits/crowbits-vibration-motor.html#description","title":"Description","text":"<p>The vibration motor is a digital output module, it's similar to the device that makes your cellphone shake when you get a message or call. You can make your projects vibrate with this vibration motor.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-vibration-motor.html#features","title":"Features","text":"<ul> <li>High reliability</li> <li>Strengthen Vibration</li> </ul>"},{"location":"Products/Crowbits/crowbits-vibration-motor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-vibration-motor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an input module, such as Crowbits-Switch.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When you press the button of the self-locking switch, the vibration motor will vibrate.</p>"},{"location":"Products/Crowbits/crowbits-vibration-sensor.html","title":"Crowbits-Vibration Sensor","text":""},{"location":"Products/Crowbits/crowbits-vibration-sensor.html#description","title":"Description","text":"<p>The vibration sensor is a digital input module, it senses the vibration from the environment, then transfers the vibration signal to the output module, it can be used as a vibrate switch.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-vibration-sensor.html#features","title":"Features","text":"<ul> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-vibration-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-vibration-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the vibration sensor detects a vibration, the LED will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-voltage-sensor.html","title":"Crowbits-Voltage Sensor","text":""},{"location":"Products/Crowbits/crowbits-voltage-sensor.html#description","title":"Description","text":"<p>This module can detect the voltage in the circuit, which is very convenient for your design.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-voltage-sensor.html#features","title":"Features","text":"<ul> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-voltage-sensor.html#specification","title":"Specification","text":"<ul> <li>Interface Type: Analog input</li> <li>Operating Voltage: 3.3V DC</li> <li>Measuring voltage range: DC 0-15V</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-voltage-sensor.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1. You need to prepare a Crowbits motherboard, such as Crowbits-UNO board. You also need an expansion board, such as Crowbits-Terminal board.</p> <p>2. Connect the module to the A2 interface on the Crowbits-UNO board. Crowbits-Terminal board is behind it.</p> <p>3. Connect the positive pole of the power supply to be tested to the positive terminal on the Crowbits-Voltage Sensor board, and the negative terminal to the negative terminal on the Crowbits-Voltage Sensor board.</p> <p></p> <p>4.Upload the following code to the Crowbits-UNO board.</p> <pre><code>float val11; \nint pin = A2;\nvoid setup() \n{    \n Serial.begin(9600);   \n pinMode(pin,INPUT);\n Serial.println(\"Emartee.Com\");   \n Serial.println(\"Voltage: \");   \n Serial.print(\"V  \"); \n} \nvoid loop() \n{       \n float temp;       \n val11=analogRead(pin);       \n// temp=(val11/1024*3.3)*2;   \n  temp=(val11/1024*3.3)*4;            //temp=(val11/1024*3.3)*((R101+R102)/R102);   \n Serial.println(temp);        \n// Serial.println(val11);   \n delay(1000); \n}\n</code></pre> <p>5. After the upload is successful, open the serial port monitor, the baud rate is set to 9600. You can see that the serial port will print out the corresponding voltage value.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-water-sensor.html","title":"Crowbits-Water Sensor","text":""},{"location":"Products/Crowbits/crowbits-water-sensor.html#description","title":"Description","text":"<p>The water sensor is a digital input module, it is sensitive to the water, which can be used to detect the presence of water.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-water-sensor.html#features","title":"Features","text":"<ul> <li>High sensitivity</li> <li>Digital input module</li> </ul>"},{"location":"Products/Crowbits/crowbits-water-sensor.html#specification","title":"Specification","text":"<ul> <li>Operating Voltage: 3.3V DC</li> <li>Supply mode: Crowbits Power Module</li> <li>Dimensions: 31.5(L)*24.5(W)*13(H) mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-water-sensor.html#usage","title":"Usage","text":"<p>1. You also need to prepare a power module, such as Crowbits-Power Supply, and an output module, such as Crowbits-LED.</p> <p>2. The connection mode is shown in the figure, but the signal feet of the input module and the output module must be connected.</p> <p></p> <p>3. Then, turn on the power. When the sensor detects the presence of water, the LED behind it will light up.</p> <p></p>"},{"location":"Products/Crowbits/crowbits-wifi.html","title":"Crowbits-WiFi","text":""},{"location":"Products/Crowbits/crowbits-wifi.html#description","title":"Description","text":"<p>The Crowbits-WiFi module based on ESP-12, which is an ultra-low power UART-WiFi module. It has excellent dimensions and ULP technology compared to other similar modules. The module is a special design for mobile devices and the Internet of things. For example, you can use this module transmit date with its serial port. It is easy to communicate with others device</p> <p></p>"},{"location":"Products/Crowbits/crowbits-wifi.html#features","title":"Features","text":"<ul> <li>WiFi module</li> <li>Easy to use</li> </ul>"},{"location":"Products/Crowbits/crowbits-wifi.html#specification","title":"Specification","text":"<ul> <li>Interface Type: UART</li> <li>Operating Voltage: 3.3V DC</li> <li>imensions: 31.5(L)*24.5(W)*13(H)mm</li> </ul>"},{"location":"Products/Crowbits/crowbits-wifi.html#usage","title":"Usage","text":"<p>The following sketch demonstrates a simple application of the module.</p> <p>1.You need to prepare a Crowbits motherboard, such as Crowbits-UNO board.</p> <p>2.Connect the module to the D2 and D3 interface on the Crowbits-UNO board, as shown in the figure:</p> <p></p> <p>3.Upload the following code to the Crowbits-UNO board.</p> <pre><code>#include &lt;SoftwareSerial.h&gt;\n\n#define DEBUG true\n\nSoftwareSerial esp8266(2,3); // make RX Arduino line is pin 2, make TX Arduino line is pin 3.\n                             // This means that you need to connect the TX line from the esp to the Arduino's pin 2\n                             // and the RX line from the esp to the Arduino's pin 3\nvoid setup()\n{\n  Serial.begin(115200);\n  esp8266.begin(115200); // your esp's baud rate might be different\n  sendData(\"AT+RST\\r\\n\",2000,DEBUG); // reset module\n  sendData(\"AT+CWMODE=2\\r\\n\",1000,DEBUG); // configure as access point\n  sendData(\"AT+CIFSR\\r\\n\",1000,DEBUG); // get ip address\n  sendData(\"AT+CIPMUX=1\\r\\n\",1000,DEBUG); // configure for multiple connections\n  sendData(\"AT+CIPSERVER=1,80\\r\\n\",1000,DEBUG); // turn on server on port 80\n}\n\nvoid loop()\n{\n  if(esp8266.available()) // check if the esp is sending a message \n  {\n    /*\n    while(esp8266.available())\n    {\n      // The esp has data so display its output to the serial window \n      char c = esp8266.read(); // read the next character.\n      Serial.write(c);\n    } */\n\n    if(esp8266.find(\"+IPD,\"))\n    {\n     delay(1000);\n\n     int connectionId = esp8266.read()-48; // subtract 48 because the read() function returns \n                                           // the ASCII decimal value and 0 (the first decimal number) starts at 48\n\n     String webpage = \"&lt;h1&gt;Hello World!&lt;/h1&gt;\";\n     String cipSend = \"AT+CIPSEND=\";\n     cipSend += connectionId;\n     cipSend += \",\";\n     cipSend +=webpage.length();\n     cipSend +=\"\\r\\n\";\n\n     sendData(cipSend,1000,DEBUG);\n     sendData(webpage,1000,DEBUG);\n\n     String closeCommand = \"AT+CIPCLOSE=\"; \n     closeCommand+=5; // append connection id\n     closeCommand+=\"\\r\\n\";    \n     sendData(closeCommand,3000,DEBUG);\n    }\n  }\n}\n\n\nString sendData(String command, const int timeout, boolean debug)\n{\n    String response = \"\";\n\n    esp8266.print(command); // send the read character to the esp8266\n\n    long int time = millis();\n\n    while( (time+timeout) &gt; millis())\n    {\n      while(esp8266.available())\n      {      \n        // The esp has data so display its output to the serial window \n        char c = esp8266.read(); // read the next character.\n        response+=c;\n      }  \n    }\n\n    if(debug)\n    {\n      Serial.print(response);\n    }    \n    return response;\n}\n</code></pre> <p></p> <p>4. After the upload is successful, open the serial port monitor, the baud rate is set to 115200. The serial port will display wireless network related information.</p> <p></p>"},{"location":"Products/Display/09622-oled-128x64--blue.html","title":"0.96\" OLED 128x64- Blue","text":""},{"location":"Products/Display/09622-oled-128x64--blue.html#introduction","title":"Introduction","text":"<p>This OLED display module is small, only 0.96\u201d diagonal, it is made of 128x64 individual blue OLED pixels, each one is turn on or off by the controller chip. It works without backlight, that is, in a dark environment, OLED display is higher compared to that of LCD display, you will like the miniature for its crispness. The Driver chip of this OLED is SSD1306, which is compatible with IIC or SPI communication. So this module can be controlled by SPI or I2C. There are 2 resistors at the back of the module and sick-screen to remind you how to set the communication mode, the default mode is 4-wires SPI mode. That is, except the VCC and GND, 4 wires would be needed when using 4-wires SPI mode. You can also set to the I2C mode, in which mode 2 control wires is needed. There is also a simple switch-cap charge pump that turns 5v into a high voltage drive for the OLEDs, making this module the easiest ways to get an OLED into your project. Model: DOL12864O </p> <p> </p>"},{"location":"Products/Display/09622-oled-128x64--blue.html#specification","title":"Specification","text":"<ul> <li>Diagonal Screen Size\uff1a0.96\"</li> <li>Number of Pixels\uff1a128 \u00d7 64</li> <li>Color Depth\uff1aMonochrome (Blue)</li> <li>Dimension\uff1a27.8 x27.3x 4.3 mm</li> <li>Working Voltage: 3.3~ 5V DC</li> <li>Power: 0.06W Max</li> <li>Viewing Angle: &gt;160 Degree</li> <li>Duty\uff1a1/32</li> <li>Brightness ( cd/m2)\uff1a150 (Typ) @ 5V</li> <li>Interface\uff1a4-wire SPI/3-wire SPI/I2C Selectable</li> </ul>"},{"location":"Products/Display/09622-oled-128x64--blue.html#usage","title":"Usage","text":"<p>1.Hardware connection</p> <p>Connect the OLED to the Crowduino.</p> <p></p> <p>2.Connect the board to PC using USB cable.</p> <p>3.Download the library OLED library;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.</p> <p>4.Open the code directly by the path:File -&gt; Example -&gt;SSD1306-&gt;OLED.</p> <p></p> <p>5.Upload the Code,you shoule see the display of OLED.</p> <p></p>"},{"location":"Products/Display/09622-oled-128x64--blue.html#resource","title":"Resource","text":"<ul> <li>OLED Demo code</li> </ul>"},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html","title":"1.3 inch IPS TFT LCD Display ST7789","text":""},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html#discription","title":"Discription","text":"<p>This is a 1.3 inch display screen with a resolution of 240 (RGB) x240. It is an IPS full view LCD display panel so the color looks great in any direction. The drive IC is ST7789, and the universal 7-pin SPI interface is used.</p> <p>The bottom has an SD card slot, which makes it easy to load full-color bitmaps from the MicroSD card in FAT16/FAT32 format.</p> <p>Support the main control MCU such as ESP32/ESP8266/Arduino/STM32.</p>"},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html#specification","title":"Specification","text":"<ul> <li>1.3 inch TFT LCD Display</li> <li>Built-in microSD slot</li> <li>Operating Voltage: 3.3V</li> <li>Backlight: 2-Chip white LED, Vf=3.2V(If=20mA)</li> <li>Resolution: 240 (RGB) x240</li> <li>Interface: SPI serial</li> <li>Drive IC: ST7789</li> <li>Operating Temperature: -20\u2103~+70\u2103</li> <li>Storage Temperature: -30\u2103~+80\u2103</li> <li>Dimension: 35.8mm x 35.8mm x 5.3mm</li> <li>Weight: 7.6g</li> </ul>"},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html#pin-discription","title":"Pin Discription","text":""},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html#usage","title":"Usage","text":""},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html#hardware-connection","title":"Hardware Connection","text":"<p>STEP1 Prepare the below stuffs:  </p> Crowduino Uno 1.3 inch IPS TFT LCD Display [[File:|300px] Get one now [Get one now] <p>STEP2 Connect wires according to the following wiring diagram </p>"},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html#software","title":"Software","text":"<p>STEP1 Download Adafruit-ST7735-Library and Adafruit-GFX-Library STEP2 Configure controller board&amp;communication port On top of the Arduino IDE, click \u201cTools&gt;Board&gt;\u201d and select \u201cArduino Uno\u201d from the available options  Select the COM port that indicates Arduino Uno. Please note that the actual numbers after the \u201cCOM\u201d word will vary from computer to computer, so they could be different from the ones shown in the figure.  STEP3 Install Library: Unzip the files and copy them to the Libraries directory under the Arduino installation directory Note: Please change \"-\" in the folder name to \"_\", and delete\"_ master\" </p> <p>STEP4 Open Arduino IDE, click \"File\"--&gt;\"Example\"--&gt;\"Adafruit ST7735 and ST7789 Library\"--&gt;\"graphicstest_st7789\" to load the code  </p> <p>STEP5 Click the  to upload the code to the Crowduino board </p> <p>STEP6 The graphs will show on display </p>"},{"location":"Products/Display/13-inch-ips-tft-lcd-display-st7789.html#faqs","title":"FAQS","text":"<p>You can list you question here or contact with techsupport@elecrow.com for technology support.</p>"},{"location":"Products/Display/1442727-128x-128-tft-lcd-with-spi-interface.html","title":"1.44'' 128x 128 TFT LCD with SPI Interface","text":""},{"location":"Products/Display/1442727-128x-128-tft-lcd-with-spi-interface.html#introduction","title":"Introduction","text":"<p>This Color TFT LCD display has 128 x 128 resolution and 262 color, it uses SPI interface to communicate with controller such Arduino, it is the best upgrading of the Nokia5110. Model: DL144128TF </p> <p></p> <p></p>"},{"location":"Products/Display/1442727-128x-128-tft-lcd-with-spi-interface.html#features","title":"Features","text":"<ul> <li>Size: 1.44 inch</li> <li>Interface:SPI</li> <li>Resolution: 128*128</li> <li>Visual area: 1:1 square</li> <li>TFT color screen, the effect is far better than other small CSTN screen</li> <li>Drive IC: ILI9163</li> <li>Fully compatible and alternative 5110 interface</li> <li>Onboard LDO, support 5V/3.3V input voltage, the LED backlight, 3.3V input</li> </ul>"},{"location":"Products/Display/1442727-128x-128-tft-lcd-with-spi-interface.html#usage","title":"Usage","text":"<p>1.Hardware connection</p> <p> </p> <p>2.Connect the board to PC using USB cable.</p> <p>3.Download the library TFT_ILI9163C library;Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries.</p> <p>4.Open the code directly by the path:File -&gt; Example -&gt;TFT_ILI9163C-&gt;test.</p> <pre><code>#include &lt;SPI.h&gt;\n#include &lt;Adafruit_GFX.h&gt;\n#include &lt;TFT_ILI9163C.h&gt;\n\n// All wiring required, only 3 defines for hardware SPI on 328P\n#define __DC 9\n#define __CS 10\n// MOSI --&gt; (SDA) --&gt; D11\n#define __RST 12\n// SCLK --&gt; (SCK) --&gt; D13\n\n// Color definitions\n#define BLACK   0x0000\n#define BLUE    0x001F\n#define RED     0xF800\n#define GREEN   0x07E0\n#define CYAN    0x07FF\n#define MAGENTA 0xF81F\n#define YELLOW  0xFFE0  \n#define WHITE   0xFFFF\n\nTFT_ILI9163C tft = TFT_ILI9163C(__CS, __DC, __RST);\n\nvoid setup() {\n  tft.begin();\n}\n\nvoid loop(){\n  testLines(random(0x00ff,0xffff));\n  delay(100);\n  testText();\n  delay(500);\n}\n\n\nunsigned long testText() {\n  tft.fillScreen();\n  unsigned long start = micros();\n  tft.setCursor(0, 0);\n  tft.setTextColor(WHITE);  \n  tft.setTextSize(1);\n  tft.println(\"Hello World!\");\n  tft.setTextColor(YELLOW); \n  tft.setTextSize(2);\n  tft.println(1234.56);\n  tft.setTextColor(RED);    \n  tft.setTextSize(3);\n  tft.println(0xDEAD, HEX);\n  tft.println();\n  tft.setTextColor(GREEN);\n  tft.setTextSize(4);\n  tft.println(\"Hello\");\n  return micros() - start;\n}\n\nunsigned long testLines(uint16_t color) {\n  tft.fillScreen();\n  unsigned long start, t;\n  int           x1, y1, x2, y2,\n  w = tft.width(),\n  h = tft.height();\n  tft.fillScreen();\n  x1 = y1 = 0;\n  y2    = h - 1;\n  start = micros();\n  for(x2=0; x2&lt;w; x2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  x2    = w - 1;\n  for(y2=0; y2&lt;h; y2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  t     = micros() - start; // fillScreen doesn't count against timing\n  tft.fillScreen();\n  x1    = w - 1;\n  y1    = 0;\n  y2    = h - 1;\n  start = micros();\n  for(x2=0; x2&lt;w; x2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  x2    = 0;\n  for(y2=0; y2&lt;h; y2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  t    += micros() - start;\n  tft.fillScreen();\n  x1    = 0;\n  y1    = h - 1;\n  y2    = 0;\n  start = micros();\n  for(x2=0; x2&lt;w; x2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  x2    = w - 1;\n  for(y2=0; y2&lt;h; y2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  t    += micros() - start;\n  tft.fillScreen();\n  x1    = w - 1;\n  y1    = h - 1;\n  y2    = 0;\n  start = micros();\n  for(x2=0; x2&lt;w; x2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  x2    = 0;\n  for(y2=0; y2&lt;h; y2+=6) tft.drawLine(x1, y1, x2, y2, color);\n  return micros() - start;\n}\n</code></pre> <p>5.Upload the Code,you shoule see the display of LCD.</p> <p></p>"},{"location":"Products/Display/1442727-128x-128-tft-lcd-with-spi-interface.html#resource","title":"Resource","text":"<ul> <li>TFT_ILI9163C library</li> </ul>"},{"location":"Products/Display/1602-lcd-display-module.html","title":"1602 LCD Display Module","text":""},{"location":"Products/Display/1602-lcd-display-module.html#description","title":"Description","text":"<p>This is a basic 16 character by 2 line display. Black text on Green/Blue background. Interface code is freely available. You will need 7 or 11 general I/O pins to interface to this LCD screen. Includes LED backlight.</p> <p>Model:CT0001BS Model:DLC01602B </p>"},{"location":"Products/Display/1602-lcd-display-module.html#pin-mapping-of-lcd-module","title":"pin mapping of LCD module","text":"Pin Number Sign Remark Pin Number Sign Remark 1 VSS GND 9 D2 Data I/O 2 VDD VCC 10 D3 Data I/O 3 VL Contrast ratio 11 D4 Data I/O 4 RS Data/Command Choice 12 D5 Data I/O 5 R/W Write/Read Choice 13 D6 Data I/O 6 E Enble 14 D7 Data I/O 7 D0 Data I/O 15 BLA Back light anode 8 D1 Data I/O 16 BLK Back light cathanode"},{"location":"Products/Display/1602-lcd-display-module.html#how-to-control","title":"How to control","text":""},{"location":"Products/Display/1602-lcd-display-module.html#hardware-install","title":"Hardware Install","text":"<p>Connect the LCD module with Arduino following picture.</p> <p></p>"},{"location":"Products/Display/1602-lcd-display-module.html#software-upload","title":"Software upload","text":"<p>Upload the following code to the Arduino or download the Arduino library</p> <pre><code>int LCD1602_RS=12;   \nint LCD1602_RW=11;   \nint LCD1602_EN=10;   \nint DB[] = { 6, 7, 8, 9};\nchar str1[]=\"Welcome to\";\nchar str2[]=\"Elecrow\";\nchar str3[]=\"this is the\";\nchar str4[]=\"4-bit interface\";\n\nvoid LCD_Command_Write(int command)\n{\n int i,temp;\n digitalWrite( LCD1602_RS,LOW);\n digitalWrite( LCD1602_RW,LOW);\n digitalWrite( LCD1602_EN,LOW);\n\n temp=command &amp; 0xf0;\n for (i=DB[0]; i &lt;= 9; i++)\n {\n   digitalWrite(i,temp &amp; 0x80);\n   temp &lt;&lt;= 1;\n }\n\n digitalWrite( LCD1602_EN,HIGH);\n delayMicroseconds(1);\n digitalWrite( LCD1602_EN,LOW);\n\n temp=(command &amp; 0x0f)&lt;&lt;4;\n for (i=DB[0]; i &lt;= 9; i++)\n {\n   digitalWrite(i,temp &amp; 0x80);\n   temp &lt;&lt;= 1;\n }\n\n digitalWrite( LCD1602_EN,HIGH);\n delayMicroseconds(1); \n digitalWrite( LCD1602_EN,LOW);\n}\n\nvoid LCD_Data_Write(int dat)\n{\n int i=0,temp;\n digitalWrite( LCD1602_RS,HIGH);\n digitalWrite( LCD1602_RW,LOW);\n digitalWrite( LCD1602_EN,LOW);\n\n temp=dat &amp; 0xf0;\n for (i=DB[0]; i &lt;= 9; i++)\n {\n   digitalWrite(i,temp &amp; 0x80);\n   temp &lt;&lt;= 1;\n }\n\n digitalWrite( LCD1602_EN,HIGH);\n delayMicroseconds(1);\n digitalWrite( LCD1602_EN,LOW);\n\n temp=(dat &amp; 0x0f)&lt;&lt;4;\n for (i=DB[0]; i &lt;= 9; i++)\n {\n   digitalWrite(i,temp &amp; 0x80);\n   temp &lt;&lt;= 1;\n }\n\n digitalWrite( LCD1602_EN,HIGH);\n delayMicroseconds(1); \n digitalWrite( LCD1602_EN,LOW);\n}\n\nvoid LCD_SET_XY( int x, int y )\n{\n  int address;\n  if (y ==0)    address = 0x80 + x;\n  else          address = 0xC0 + x;\n  LCD_Command_Write(address); \n}\n\nvoid LCD_Write_Char( int x,int y,int dat)\n{\n  LCD_SET_XY( x, y ); \n  LCD_Data_Write(dat);\n}\n\nvoid LCD_Write_String(int X,int Y,char *s)\n{\n    LCD_SET_XY( X, Y );    //\u8bbe\u7f6e\u5730\u5740 \n    while (*s)             //\u5199\u5b57\u7b26\u4e32\n    {\n      LCD_Data_Write(*s);   \n      s ++;\n    }\n}\n\nvoid setup (void) \n{\n  int i = 0;\n  for (i=6; i &lt;= 12; i++) \n   {\n     pinMode(i,OUTPUT);\n   }\n  delay(100);\n  LCD_Command_Write(0x28);//4\u7ebf 2\u884c 5x7\n  delay(50); \n  LCD_Command_Write(0x06);\n  delay(50); \n  LCD_Command_Write(0x0c);\n  delay(50); \n  LCD_Command_Write(0x80);\n  delay(50); \n  LCD_Command_Write(0x01);\n  delay(50); \n\n}\n\nvoid loop (void)\n{\n   LCD_Command_Write(0x01);\n   delay(50);\n   LCD_Write_String(3,0,str1);//\u7b2c1\u884c\uff0c\u7b2c4\u4e2a\u5730\u5740\u8d77\n   delay(50);\n   LCD_Write_String(4,1,str2);//\u7b2c2\u884c\uff0c\u7b2c2\u4e2a\u5730\u5740\u8d77\n   delay(5000);\n   LCD_Command_Write(0x01);\n   delay(50);\n   LCD_Write_String(0,0,str3);\n   delay(50);\n   LCD_Write_String(0,1,str4);\n   delay(5000);\n\n}\n</code></pre>"},{"location":"Products/Display/1602-lcd-display-module.html#resource","title":"Resource","text":"<p>Arduino library</p>"},{"location":"Products/Display/16x16-led-display-module.html","title":"16x16 LED Display Module","text":""},{"location":"Products/Display/16x16-led-display-module.html#description","title":"Description","text":"<p>This 16x16 Display module uses the 74HC138 and 74HC595 to decode and drive 4 8x8 LED modules to create an even bigger 16x16 LED display module. Detailed Demos based on Arduino help you understanding and learning how to use this module and thus to integrate it to your own applications\u3002</p> <p>Model:DLD1616LED</p> <p></p>"},{"location":"Products/Display/16x16-led-display-module.html#features","title":"Features","text":"<ul> <li>16x16 LED Display</li> <li>Color: Red</li> <li>Support the 128x64 LCD Display</li> <li>Cascadable</li> </ul>"},{"location":"Products/Display/16x16-led-display-module.html#usage","title":"Usage","text":"<p>1.Hardware connection</p> <p> </p> <p>2.Connect the board to PC using USB cable.</p> <p>3.Copy the below code to you new skecth,then upload it.</p> <pre><code>#include &lt;Arduino.h&gt;\n\n//IO    \n#define LEDARRAY_D 2\n#define LEDARRAY_C 3\n#define LEDARRAY_B 4\n#define LEDARRAY_A 5\n#define LEDARRAY_G 6\n#define LEDARRAY_DI 7\n#define LEDARRAY_CLK 8\n#define LEDARRAY_LAT 9\n\n\nunsigned char Display_Buffer[2];\nconst unsigned char  Word1[1][32] = \n{\n\n0xFF,0xFF,0xFF,0xE1,0xC0,0x80,0x80,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0xFF,0xFF,\n0xFF,0xFF,0xFF,0x87,0x03,0x01,0x01,0x01,0x03,0x07,0x0F,0x1F,0x3F,0x7F,0xFF,0xFF,//heart-shaped\n\n};\n\nconst unsigned char  Init_Display[1][32] = \n{\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,\n};\n\nvoid setup()\n{\n    pinMode(LEDARRAY_D, OUTPUT); \n    pinMode(LEDARRAY_C, OUTPUT);\n    pinMode(LEDARRAY_B, OUTPUT);\n    pinMode(LEDARRAY_A, OUTPUT);\n    pinMode(LEDARRAY_G, OUTPUT);\n    pinMode(LEDARRAY_DI, OUTPUT);\n    pinMode(LEDARRAY_CLK, OUTPUT);\n    pinMode(LEDARRAY_LAT, OUTPUT);\n\n    Display(Init_Display);\n}\n\nvoid loop()\n{\n    Display(Word1); \n}\n\n\n\n//************************************************************\n//num is number  dat[][32] is the name of the font\n//*************************************************************\nvoid Display(const unsigned char dat[][32])                 \n{\n    unsigned char i;\n\n    for( i = 0\u00a0; i &lt; 16\u00a0; i++ )\n    {\n        digitalWrite(LEDARRAY_G, HIGH);     \n\n        Display_Buffer[0] = dat[0][i];      \n        Display_Buffer[1] = dat[0][i+16];\n\n        Send(Display_Buffer[1]);\n        Send(Display_Buffer[0]);\n\n        digitalWrite(LEDARRAY_LAT, HIGH);                   \n\n        digitalWrite(LEDARRAY_LAT, LOW);\n        delayMicroseconds(1);\n\n        Scan_Line(i);                           \n\n        digitalWrite(LEDARRAY_G, LOW);\n\n        delayMicroseconds(100);;                            \n    }   \n}\n\n\nvoid Scan_Line( unsigned char m)\n{   \n    switch(m)\n    {\n        case 0:         \n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, LOW);                    \n            break;\n        case 1:                 \n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, HIGH);       \n            break;\n        case 2:                 \n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, LOW);       \n            break;\n        case 3:                 \n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, HIGH);      \n            break;\n        case 4:\n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, LOW);       \n            break;\n        case 5:\n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, HIGH);      \n            break;\n        case 6:\n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, LOW);      \n            break;\n        case 7:\n            digitalWrite(LEDARRAY_D, LOW);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, HIGH);         \n            break;\n        case 8:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, LOW);       \n            break;\n        case 9:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, HIGH);      \n            break;  \n        case 10:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, LOW);      \n            break;\n        case 11:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, LOW);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, HIGH);         \n            break;\n        case 12:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, LOW);      \n            break;\n        case 13:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, LOW);digitalWrite(LEDARRAY_A, HIGH);         \n            break;\n        case 14:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, LOW);         \n            break;\n        case 15:\n            digitalWrite(LEDARRAY_D, HIGH);digitalWrite(LEDARRAY_C, HIGH);digitalWrite(LEDARRAY_B, HIGH);digitalWrite(LEDARRAY_A, HIGH);        \n            break;\n        default\u00a0: break;    \n    }\n}\n\n\nvoid Send( unsigned char dat)\n{\n    unsigned char i;\n    digitalWrite(LEDARRAY_CLK, LOW);\n    delayMicroseconds(1);;  \n    digitalWrite(LEDARRAY_LAT, LOW);\n    delayMicroseconds(1);;\n\n    for( i = 0\u00a0; i &lt; 8\u00a0; i++ )\n    {\n        if( dat&amp;0x01 )\n        {\n            digitalWrite(LEDARRAY_DI, HIGH);    \n        }\n        else\n        {\n            digitalWrite(LEDARRAY_DI, LOW);\n        }\n\n        delayMicroseconds(1);\n        digitalWrite(LEDARRAY_CLK, HIGH);               \n            delayMicroseconds(1);\n        digitalWrite(LEDARRAY_CLK, LOW);\n            delayMicroseconds(1);       \n        dat &gt;&gt;= 1;\n\n    }           \n}\n</code></pre> <p>4.Upload the Code,then you shoule see the 16x16 LED display.</p> <p></p>"},{"location":"Products/Display/16x16-led-display-module.html#resource","title":"Resource","text":"<ul> <li>16x_16_LED library</li> </ul>"},{"location":"Products/Display/2-inch-ips-module.html","title":"2 inch IPS Module","text":""},{"location":"Products/Display/2-inch-ips-module.html#description","title":"Description","text":"<p>This product is a 2.0inch IPS display module,it has a resolution of 320x240.it uses a 4-wire SPI communication method and the inner IC is ST7789.The module contains an LCD display and PCB backboard. </p>"},{"location":"Products/Display/2-inch-ips-module.html#features","title":"Features","text":"<ul> <li>2.0-inch color screen,support 65K color display,display rich colors</li> <li>320X240 resolution, clear display</li> <li>IPS full view panel, super wide visual range</li> <li>Using the 4-line-SPI serial bus, it only takes a few IOs to illuminate the display</li> <li>Provide a rich STM32, C51 and MSP430 sample program</li> <li>Military-grade process standards, long-term stable work</li> <li>Provide underlying driver technical support</li> </ul>"},{"location":"Products/Display/2-inch-ips-module.html#specifications","title":"Specifications","text":"Item Value Display Color RGB 65K color Size 291(Length)*190(Width)*46(Height)mm Screen Size 2.0(inch) Type IPS Driver IC ST7789 Power Supply DC 12V 2A Resolution 320*240 (Pixel) Module Interface 4-line SPI interface Active Area (AA area) 30.60x40.80 (mm) Touch Screen Unsupport Module PCB Size 36.48x61.12 (mm) Angle of view all angle Operating Temperature -10\u2103~60\u2103 Storage Temperature -20\u2103~70\u2103 VCC power voltage 3.3V Rough Weight(Package containing) 15g"},{"location":"Products/Display/2-inch-ips-module.html#interface","title":"Interface","text":""},{"location":"Products/Display/2-inch-ips-module.html#pin-map","title":"Pin Map","text":"Number Pin Name Description 1 GND LCD Power ground 2 VCC LCD power supply(3.3V) 3 SCL LCD SPI bus clock signal 4 SDA LCD SPI bus write data signal 5 RES LCD reset control signal(Low level reset) 6 DC LCD register / data selection control signal (Low level: register, high level: data) 7 CS LCD chip select control signal (low level enable) 8 BLK LCD backlight control signal (high level lighting, if you do not need control, please connect 3.3V)"},{"location":"Products/Display/2-inch-ips-module.html#hardware-configuration","title":"Hardware Configuration","text":"<p>The LCD module hardware circuit comprises two parts: an LCD display control circuit and a backlight control circuit. The LCD display control circuit is used to control the pins of the LCD, including control pins and data transfer pins. if the backlight is not required to be be on and off, can be directly connected to the 3.3V if the backlight is not required to be be on and off, can be directly connected to the 3.3V power supply.   </p>"},{"location":"Products/Display/2-inch-ips-module.html#usage","title":"Usage","text":""},{"location":"Products/Display/2-inch-ips-module.html#hardware-connection","title":"Hardware Connection","text":"Crowduino Uno 2 inch IPS Module GND GND 5V VCC 13 SCL 11 SDA A4 RES A3 DC A2 CS A0 BLK"},{"location":"Products/Display/2-inch-ips-module.html#software","title":"Software","text":"<p>STEP1 Download 2.0inch_SPI_Arduino_Demo.zip STEP2 Configure controller board&amp;communication port On top of the Arduino IDE, click \u201cTools&gt;Board&gt;\u201d and select \u201cArduino Uno\u201d from the available options  Select the COM port that indicates Arduino Uno. Please note that the actual numbers after the \u201cCOM\u201d word will vary from computer to computer, so they could be different from the ones shown in the figure. </p> <p>STEP3 Install libraries :Unzip Install libraries.zip and copy folder \"LCDWIKI_GUI\" and \"LCDWIKI_SPI\" to the libraries directory under the Arduino installation directory  STEP4 Load the program to Arduino IDE   STEP5 Click the  to upload the code to the Crowduino board</p> <p>STEP6 After the program is downloaded, run it directly and observe the running status. If it can be displayed normally, the program runs successfully. </p>"},{"location":"Products/Display/2-inch-ips-module.html#faqs","title":"FAQS","text":"<p>You can list you question here or contact with techsupport@elecrow.com for technology support.</p>"},{"location":"Products/Display/2-inch-ips-module.html#resources","title":"Resources","text":"<p>ST7789VW_datasheet.pdf  2.0inch_SPI_Arduino_Demo.zip </p>"},{"location":"Products/Display/29-inch-e-paper-module-three-color-red-black-white.html","title":"2.9 inch e-Paper Module Three Color-Red Black White","text":""},{"location":"Products/Display/29-inch-e-paper-module-three-color-red-black-white.html#introduction","title":"Introduction","text":"<p>Note: The raw panel require a driver board, If you are the first time use this e-Paper, we recommend you to buy the HAT version or buy more one driver hat for easy use, otherwise you need to make the driver board yourself. And this instruction is based on the version with PCB or driver board.</p> <p>296x128, 2.9inch E-Ink display module, three-color, SPI interface</p> <p>Model: RAP20129H</p>"},{"location":"Products/Display/29-inch-e-paper-module-three-color-red-black-white.html#interface","title":"Interface","text":""},{"location":"Products/Display/29-inch-e-paper-module-three-color-red-black-white.html#working-principle","title":"Working principle","text":"<p>1.Introduction</p> <p>This product is an E-paper device adopting the image display technology of Microencapsulated Electrophoretic Display, MED. The initial approach is to create tiny spheres, in which the charged color pigments are suspending in the transparent oil and would move depending on the electronic charge. The E-paper screen display patterns by reflecting the ambient light, so it has no background light requirement. (Note that the e-Paper cannot support updating directly under sunlight)</p> <p>2.Communication protocol</p> <p></p> <p>Note: Different from the traditional SPI protocol, the data line from the slave to the master is hidden since the device only has display requirement.</p> <ul> <li>CS is slave chip select, when CS is low, the chip is enabled.</li> <li>DC is data/command control pin, when DC = 0, write command, when DC = 1, write data.</li> <li>SCLK is the SPI communication clock.</li> <li>SDIN is the data line from the master to the slave in SPI communication.</li> </ul> <p>SPI communication has data transfer timing, which is combined by CPHA and CPOL.</p> <p>1.CPOL determines the level of the serial synchronous clock at idle state. When CPOL = 0, the level is Low. However, CPOL has little effect to the transmission.</p> <p>2.CPHA determines whether data is collected at the first clock edge or at the second clock edge of serial synchronous clock; when CPHL = 0, data is collected at the first clock edge.</p> <ul> <li>There are 4 SPI communication modes. SPI0 is commonly used, in which CPHL = 0, CPOL = 0.</li> </ul> <p>As you can see from the figure above, data transmission starts at the first falling edge of SCLK, and 8 bits of data are transferred in one clock cycle. In here, SPI0 is in used, and data is transferred by bits, MSB first.</p>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html","title":"3.5 Inch 480x320 TFT Display with Touch Screen for Raspberry Pi","text":""},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#description","title":"Description","text":"<p>It is the cutest, little display for the Raspberry Pi. It features a 3.5\" display with 480x320 16-bit color pixels and a resistive touch overlay. It's designed to fit nicely not only to the Pi Model A or B but also works perfectly fine with the Model B+.</p> <p>Model:RPA03510R</p> <p></p> <p></p>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#features","title":"Features","text":"<ul> <li>480x320 resolution</li> <li>Universal 3.5\u201d Display for the Raspberry Pi</li> <li>Compatible with Raspberry Pi A, B, A+, B+, and Pi2 versions</li> <li>Powered not only from your computer, but also from your portable power</li> <li>Adapt for Raspbian system</li> </ul>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#specifications","title":"Specifications","text":"<ul> <li>LCD Type:TFT</li> <li>LCD Interface:SPI</li> <li>Touch Screen Type:Resistive</li> <li>Touch Screen Controller:XPT2046</li> <li>Colors:65536</li> <li>Backlight:LED</li> <li>Resolution:480*320 (Pixel)</li> </ul>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#interface-function","title":"Interface Function","text":""},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#usage","title":"Usage","text":"<p>When users connect the Raspberry Pi to use, they need to configure the official system. Or you can also burn the configured system image directly. Tips:Basic for Raspbian Jessie with PIXEL (2017-04-10-raspbian-jessie.img)</p>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#step-1download-the-raspbian-img-httpswwwraspberrypiorgdownloadsraspbian","title":"Step 1\uff1aDownload the Raspbian IMG https://www.raspberrypi.org/downloads/raspbian/","text":""},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#step-2-burn-the-system-image-if-you-dont-know-how-to-do-thatyou-can-refer-to-the-raspberry-pi-office-tutorial","title":"Step 2: Burn the system image If you don't know how to do that,you can refer to the Raspberry Pi office tutorial","text":""},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#step-3-open-terminal-and-download-the-driver-on-rpi","title":"Step 3: Open terminal and Download the driver on RPI","text":"<p>Run:</p> <pre><code>sudo git clone https://github.com/goodtft/LCD-show.git\n</code></pre>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#step-4-install-driver","title":"Step 4: Install driver","text":"<p>Run:</p> <pre><code>cd LCD-show/\nsudo chmod +x LCD35-show\nsudo ./LCD35-show\n</code></pre>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#touch-screen-calibration","title":"Touch screen calibration","text":"<ul> <li>This LCD can be calibrated using a program called xinput_calibrator</li> <li>**Install it with the commands: ** <pre><code>cd Elecrow-LCD35&lt;br&gt;&lt;/br&gt;\nsudo dpkg -i -B xinput-calibrator_0.7.5-1_armhf.deb\n</code></pre></li> <li>Click the Men button on the task bar, choose Preference -&gt; Calibrate Touchscreen.</li> <li>Finish the touch calibration following the prompts. Maybe rebooting is required to make calibration active.</li> <li>You can create a 99-calibration.conf file to save the touch parameters (not necessary if file exists). <pre><code>/ect/X11/xorg.conf.d/99-calibration.conf\n</code></pre></li> <li>Save the touch parameters (may differ depending on LCD) to 99-calibration.conf, as shown in the picture: </li> </ul>"},{"location":"Products/Display/35-inch-480x320-tft-display-with-touch-screen-for-raspberry-pi.html#install-soft-keyboard","title":"Install Soft Keyboard","text":"<ul> <li>Install the reference link\uff1ahttps://github.com/Elecrow-keen/Elecrow-LCD5/wiki/How-to-Install-Soft-Keyboard</li> </ul>"},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html","title":"3.5inch 480x320 MCU SPI Serial TFT LCD Module Display","text":""},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#description","title":"Description","text":"<p>It is the cutest, little display for the Raspberry Pi. It features a 3.5\" display with 480x320, support 65K color display.</p> <p>Model:DIS03501R</p> <p></p>"},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#features","title":"Features","text":"<ul> <li>3.5-inch color screen,support 65K color display,display rich colors</li> <li>480X320 resolution, optional touch function</li> <li>Using the SPI serial bus, it only takes a few IOs to illuminate the display</li> <li>Easy to expand the experiment with SD card slot</li> <li>Provide a rich sample program</li> <li>Military-grade process standards, long-term stable work</li> <li>Provide underlying driver technical support</li> </ul>"},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#specifications","title":"Specifications","text":"<ul> <li>Display Color: RGB 65K color</li> <li>Screen Size: 3.5(inch)</li> <li>Type: TFT</li> <li>Driver IC: ILI9488</li> <li>Resolution: 480*320 (Pixel)</li> <li>Module Interface: 4-wire SPI interface</li> <li>Active Area (AA area): 48.96x73.44(mm)</li> <li>Module PCB Size: 56.34x98(mm)</li> <li>Operating Temperature: -20\u2103~60\u2103</li> <li>Storage Temperature: -30\u2103~70\u2103</li> <li>VCC power voltage: 3.3V~5V</li> <li>Logic IO port voltage: 3.3V(TTL)</li> <li>Power Consumption: TBD</li> <li>Rough Weight: 45 (g)</li> </ul>"},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#interface-definition","title":"Interface Definition","text":"<p> 650px</p>"},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#how-to-use-with-arduino","title":"How to use with Arduino","text":""},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#1-run-arduino-demo-in-spi-model","title":"1: Run Arduino Demo in SPI model","text":"<p>When we directly connected the SPI display module without the on-board level conversion module to the Arduino, we found that it could not run at all. This is because the SPI module's pin can only input a 3.3V high level, while the Arduino output has a high level of 5V. To run successfully, there are two Method: short circuit method and external level conversion module method. The short-circuit method has the advantages of simple operation, short wiring, and no need for external devices. The disadvantage is that the module generates a large amount of heat during operation.Will affect the life of the module. The external level conversion module method is a normal operation, and the advantage is that the module generatesless heat and runs stably during operation, and the disadvantage is that the operation is slightly complicated. (An external level shifting module is required) to increase the cost (additional level conversion module is required). In summary, it is recommended to use the external level shifting module method.</p> <p>Step 1: Short-Circuit Method The short-circuit method is to short the J1 component position (shown below) with solder on the back of the module.After shorting, the runtime module VCC The pin must be connected to a 5V power supply (not connected to 3.3V).  </p> <p>Step 2: External Level Conversion Module Method The so-called external level conversion module method is to connect the Arduino and the display module through an external level conversion module, so that The 5V high level of the Arduino output is converted to 3.3V by the level conversion module and then input to the display module. As shown below:  </p>"},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#2-first-download-the-sample-code-then-copy-the-libraries-that-the-examples-depend-on-to-the-libraries-folder-of-the-arduino-project-file-directory","title":"2: First download the sample code. Then copy the libraries that the examples depend on to the libraries folder of the Arduino project file directory.","text":""},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#3-select-the-example-you-want-to-test-open-it-and-click-tools-button-to-select-the-board-model-and-port-number-as-shown-below","title":"3: Select the example you want to test, open it and click Tools button to select the board model and port number, as shown below:","text":""},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#4-connect-the-pins-with-the-arduino-pins-with-dupont-wires-according-to-the-pin-definitions-in-the-program-the-example-is-a-short-circuit-method","title":"4: Connect the pins with the Arduino pins with Dupont wires according to the pin definitions in the program. (The example is a short-circuit method)","text":""},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#5-click-the-upload-button-to-compile-and-download-when-done-uploading-is-displayed-the-program-had-been-successfully-downloaded-to-the-development-board-as-shown-below","title":"5: Click the Upload button to compile and download. When \u201cDone Uploading\u201d is displayed, the program had been successfully downloaded to the development board, as shown below:","text":""},{"location":"Products/Display/35inch-480x320-mcu-spi-serial-tft-lcd-module-display.html#6-if-the-module-can-display-normally-the-program-runs-successfully","title":"6: If the module can display normally, the program runs successfully:","text":""},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html","title":"3.95 Inch TFT Display for Raspberry Pi","text":""},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#description","title":"Description","text":"<p>This TFT LCD is designed for RPI B and B+, you can design it for many other things. It is play and plug, very easy and good item for your raspberry pi project and just simple connect to Raspberry Pi, you can start you Raspberry pi experience.</p> <p>Model:RPA29501R</p> <p></p>"},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#features","title":"Features","text":"<ul> <li>Resolution: 320 x 480</li> <li>Universal 3.95\u201d Display for the Raspberry Pi</li> <li>Compatible with Raspberry Pi B, B+</li> <li>Adapt for Raspbian system </li> </ul>"},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#specifications","title":"Specifications","text":"<ul> <li>LCD Type:TFT</li> <li>LCD Interface:SPI</li> <li>LCD IC: ILI9488</li> <li>Size: 3.95 inch</li> <li>Weight:175g </li> </ul>"},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#interface-function","title":"Interface Function","text":""},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#usage","title":"Usage","text":"<p>When users connect the Raspberry Pi to use, they need to configure the official system. Or you can also burn the configured system image directly.</p> <p>Tips:Basic for Raspbian Jessie with PIXEL (2017-04-10-raspbian-jessie.img)</p>"},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#step-1download-the-raspbian-img-httpswwwraspberrypiorgdownloadsraspbian","title":"Step 1\uff1aDownload the Raspbian IMG https://www.raspberrypi.org/downloads/raspbian/","text":""},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#step-2-burn-the-system-image-if-you-dont-know-how-to-do-thatyou-can-refer-to-the-5-inch-800x480-tft-display","title":"Step 2: Burn the system image If you don't know how to do that,you can refer to the :5 Inch 800x480 TFT Display","text":""},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#step-3-open-terminal-and-download-the-driver-on-rpi","title":"Step 3: Open terminal and Download the driver on RPI","text":"<p>Run:</p> <pre><code>git clone https://github.com/Elecrow-keen/Elecrow-LCD395.git\n</code></pre>"},{"location":"Products/Display/395-inch-tft-display-for-raspberry-pi.html#step-4-install-driver","title":"Step 4: Install driver","text":"<p>Run:</p> <p><pre><code>cd Elecrow-LCD395\nsudo ./Elecrow-LCD395\n</code></pre> Wait A Few Minutes, when the system reboot ok, you can see that. </p>"},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html","title":"4 Inch HD 480x320 TFT Display with Touch Screen for Rapberry Pi","text":""},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#description","title":"Description","text":"<p>This 4 inch TFT Display with Touch Screen is a mini panel-mountable monitor. So small and simple, and the shape makes it easy to attach to a electronic product. Although the 480*320 common display is made for Raspberry Pi, we can use it for other where not only for Raspberry Pi.</p> <p>Model:RPD48320D </p>"},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#features","title":"Features","text":"<ul> <li>A good solution for those seeking for a bigger resolution display</li> <li>Good touch response</li> <li>Fast response time</li> <li>For Raspberry Pi B+/2B /3B</li> </ul>"},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#specifications","title":"Specifications","text":"<ul> <li>Display type: TFT</li> <li>Interface: SPI</li> <li>Touch panel control chip: XPT2046</li> <li>Index Levels\uff1a65536</li> <li>Backlit\uff1a LED</li> <li>Size ratio: 4:3</li> <li>Working Temperature (\u2103): -20 \u00b0 to 70 \u00b0</li> </ul>"},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#interface-function","title":"Interface Function","text":""},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#usage","title":"Usage","text":""},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#a-use-with-raspbian","title":"A. Use with Raspbian","text":"<p>Step 1\uff1aInstall Raspbian official image</p> <p>1)Please download the image of the latest version from Raspberry Pi's website\uff1ahttps://www.raspberrypi.org/downloads/raspbian/</p> <p>2)Download the compressed file to your PC and unpack it to get the .Img file.</p> <p>3)The TF card is connected to the PC and formatted using the \u201cSDFormatter\u201d software.</p> <p>4)Open the \u201cWin32DiskImager\u201d software, select the system image prepared in step 1), and click write to burn the system image.</p> <p>5)Insert the TF card into the Raspberry Pi.</p> <p>6)Connect to Raspberry Pi</p> <p>Step 2: Install the LCD driver</p> <p>Install drivers in the Raspbian system (Raspberry Pi requires Internet connection)</p> <p>1)Log on to the Raspberry Pi terminal (User: pi; Password: raspberry)</p> <p>2)Execute the following command (copy and paste it by right-clicking on the Putty window):</p> <p>sudo rm -rf LCD-show</p> <p>git clone https://github.com/goodtft/LCD-show.git</p> <p>chmod -R 755 LCD-show</p> <p>cd LCD-show/</p> <p>sudo ./MHS40-show</p> <p>3)Wait for a moment after executing, the system will restart automatically. If the LCD can be normally displayed and touched, the installation of the driver is successful.</p>"},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#binstall-the-lcd-driver","title":"B.Install the LCD driver","text":"<p>Install drivers in the Raspbian system (Raspberry Pi requires Internet connection)</p> <p>1)Log on to the Raspberry Pi terminal (User: pi; Password: raspberry)</p> <p>2)Execute the following command (copy and paste it by right-clicking on the Putty window):</p> <p>sudo rm -rf LCD-show</p> <p>git clone https://github.com/goodtft/LCD-show.git</p> <p>chmod -R 755 LCD-show</p> <p>cd LCD-show/</p> <p>sudo ./MHS40-show</p> <p>3)Wait for a moment after executing, the system will restart automatically. If the LCD can be normally displayed and touched, the installation of the driver is successful.</p>"},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#touch-screen-calibration","title":"Touch screen calibration","text":"<ul> <li>This LCD can be calibrated using a program called xinput_calibrator</li> <li>Install it with the commands:</li> </ul> <pre><code>cd Elecrow-LCD4&lt;br&gt;&lt;/br&gt;\nsudo dpkg -i -B xinput-calibrator_0.7.5-1_armhf.deb\n</code></pre> <ul> <li>Click the Men button on the task bar, choose Preference -&gt; Calibrate Touchscreen.</li> <li>Finish the touch calibration following the prompts. Maybe rebooting is required to make calibration active.</li> <li>You can create a 99-calibration.conf file to save the touch parameters (not necessary if file exists).</li> </ul> <pre><code>/ect/X11/xorg.conf.d/99-calibration.conf\n</code></pre> <ul> <li>Save the touch parameters (may differ depending on LCD) to 99-calibration.conf, as shown in the picture:</li> </ul>"},{"location":"Products/Display/4-inch-hd-480x320-tft-display-with-touch-screen-for-rapberry-pi.html#install-soft-keyboard","title":"Install Soft Keyboard","text":"<ul> <li>Install the reference link\uff1ahttps://github.com/Elecrow-keen/Elecrow-LCD5/wiki/How-to-Install-Soft-Keyboard</li> </ul>"},{"location":"Products/Display/50-inch-hdmi-compatible-display-for-raspberry-pi-compatible-with-jetson-nano-beaglebone.html","title":"5.0 Inch HDMI-Compatible Display for Raspberry Pi Compatible with Jetson Nano, Beaglebone","text":""},{"location":"Products/Display/50-inch-hdmi-compatible-display-for-raspberry-pi-compatible-with-jetson-nano-beaglebone.html#description","title":"Description","text":"<p>This is a 5-inch monitor with 800*480 resolution and four corner holes that allow you to mount the monitor to other devices. The back of the monitor is also equipped with 4 nut seats for mounting and fixing the Raspberry Pi. Comes with headphone port and speaker jack. Using a capacitive USB touch screen, you only need to power on the USB touch port to realize the touch function without installing a driver. Plug and play. The signal goes through the hdmi port. Compatible with multiple devices.</p> <p>Model: DIS05490T</p> <p></p> <p></p>"},{"location":"Products/Display/50-inch-hdmi-compatible-display-for-raspberry-pi-compatible-with-jetson-nano-beaglebone.html#features","title":"Features","text":"<ul> <li>5.0inch lcd screen with 800*480 resolution</li> <li>Capacitive touch operation</li> <li>Speaker and headphone jacks</li> <li>Compatible with multiple operating systems (Raspbian, Ubuntu, Windows, Android, MAC OS and Chrome OS)</li> <li>Plug and play, no driver installation required</li> <li>Four nut mounts on the back for easy Raspberry Pi installation</li> </ul>"},{"location":"Products/Display/50-inch-hdmi-compatible-display-for-raspberry-pi-compatible-with-jetson-nano-beaglebone.html#specification","title":"Specification","text":"<ul> <li>Touch type: 5-point capacitive touch</li> <li>Resolution: 800*480</li> <li>Brightness: 300cd/m\u00b2</li> <li>Display Type: TN Panel</li> <li>Screen: TFT-LCD screen</li> <li>Display Driver IC: ILI6122 &amp; ILI5960</li> <li>External Power Supply: DC5V-2A</li> <li>Switch: Toggle Up/Down/Switch</li> <li>Interface\uff1aPower Input &amp; USB Touch Port, 4P Port Speaker, 3.5MM Headphone Port</li> <li>Product Size: 137*80*14mm</li> <li>Weight: 140g</li> </ul>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html","title":"7 Inch 1024*600 HDMI LCD Display with Touch Screen","text":""},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#description","title":"Description","text":"<p>This 7 inch HDMI LCD supports various systems like Raspberry Pi,Banana Pi,Banana Pro,BB Black to provide Lubuntu\uff0cRaspbian with and Angstrom images with high resolution of 1024\u00d7600 and capacitive Touch Screen. Besides it upgrades to IPS screen with larger visible angle and more clear display effect. Broadly you can apply it to raspberry pi, HDMI display screen and other mini PC or even computer display.</p> <p>Model:RPD10246D</p> <p></p> <p></p>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#features","title":"Features","text":"<ul> <li>A good solution for those seeking for a bigger resolution display</li> <li>Good touch response</li> <li>Supports Banana Pi / Banana Pro, comes with Lubuntu, Raspbian images</li> <li>Supports BB Black, comes with Angstrom image</li> <li>Supports Raspberry Pi, comes with Raspbian driver (works with your Raspbian directly), and Ubuntu image</li> <li>Not only for mini-PCs, it can work as a computer monitor just like any other general HDMI screen (touch function is unavailable in this case)</li> <li>Back light control to lower power consumption</li> <li>HDMI interface for displaying, USB interface for touch control</li> </ul>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#specifications","title":"Specifications","text":"<ul> <li>LCD Type:TFT</li> <li>7 inch TFT Capacitive touch screen display, 1024x600 Resolution</li> <li>HDMI input</li> <li>Usb touch and power, 5V@1A</li> <li>Lcd Size \uff1a164.7mm*107.1mm</li> <li>Weight:360g</li> </ul>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#usage","title":"Usage","text":"<p>When users connect the Raspberry Pi to use, they need to configure the official system. Or you can also burn the configured system image directly.</p>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#hardware-connection","title":"Hardware Connection","text":"<p>1. Connect the HDMI Connector to both the HDMI interfaces on the LCD and the Pi. 2. LCD and Pi connect power. 3.Turn on the \"backlight\" switch on the back of the LCD. </p>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#bruning-the-image","title":"Bruning the Image","text":""},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#method-1-using-ready-to-use-image","title":"Method 1. Using Ready-to-use image","text":"<p>The image file with pre-installed driver is located in the IMAGE directory of the DVD. Extract the IMAGE file and you will get an .img file. you can refer to the :5 Inch 800x480 TFT Display</p>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#method-2-driver-installation","title":"Method 2. Driver installation","text":""},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#step1-download-the-latest-system-and-unzip-the-image","title":"Step1: Download the latest system and unzip the image","text":"<p>For Raspbian: (Not LITE version) https://www.raspberrypi.org/downloads/raspbian/ For Ubuntu Mate: https://ubuntu-mate.org/download/#xenial For Kali: https://www.offensive-security.com/kali-linux-arm-images/ For Retropie: https://retropie.org.uk/download/ And then unzip the image file.(Next step will use it.)</p>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#step2-bruning-the-image-to-sd-card","title":"Step2: Bruning the Image to SD Card","text":"<p>How to bruning an image to a micro SD card for your Pi? you can refer to the :5 Inch 800x480 TFT Display</p>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#step3-find-the-configtxt-in-the-sds-root-and-open-it-then-add-the-following-code-in-the-end-according-to-resolution","title":"Step3: Find the config.txt in the SD`s root and open it. Then add the following code in the end according to resolution.","text":"<pre><code>hdmi_force_hotplug=1\nmax_usb_current=1\nhdmi_group=2\nhdmi_mode=1\nhdmi_mode=87\nhdmi_cvt 1024 600 60 6 0 0 0\nhdmi_drive=1\n</code></pre>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#step2-insert-sd-card-and-power-on","title":"Step2: Insert SD card and Power ON","text":"<p>The screen should be working now. </p>"},{"location":"Products/Display/7-inch-1024600-hdmi-lcd-display-with-touch-screen.html#install-soft-keyboard","title":"Install Soft Keyboard","text":"<ul> <li>Install the reference link\uff1ahttps://github.com/Elecrow-keen/Elecrow-LCD5/wiki/How-to-Install-Soft-Keyboard</li> </ul>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html","title":"7 Inch 1024x600 TFT Display for Raspberry Pi B+ Pcduino Banana Pi","text":""},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#description","title":"Description","text":"<p>This LCD module is 1024x600 dots 7 \" color TFT LCD module display with HDMI, VGA, Video, AV signal driver board, superior display quality, super wide view angle. It can be used in any embedded system, car, industrial device, security and hand-held equipment which requires display in high quality and colorful video. Its HDMI interface is fully compatible with Raspberry Pi, pcduino and Banana Pi platform.</p> <p>Model:RPA07800R</p> <pre><code>==Interface Function ==\n</code></pre> <p></p>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#features","title":"Features","text":"<ul> <li>A good solution for those seeking for a bigger resolution display</li> <li>Good touch response</li> <li>Supports Banana Pi / Banana Pro, comes with Lubuntu, Raspbian images</li> <li>Supports BB Black, comes with Angstrom image</li> <li>Supports Raspberry Pi, comes with Raspbian driver (works with your Raspbian directly), and Ubuntu image</li> <li>Not only for mini-PCs, it can work as a computer monitor just like any other general HDMI screen (touch function is unavailable in this case)</li> <li>Backlight control to lower power consumption</li> <li>HDMI interface for displaying, USB interface for touch control</li> </ul>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#specifications","title":"Specifications","text":"<ul> <li>LCD Type:TFT</li> <li>7 inch TFT Capacitive touch screen display, 1024x600 Resolution</li> <li>HDMI input</li> <li>USB touch and power, 5V@1A</li> <li>Lcd Size\uff1a164.7mm*107.1mm</li> <li>Weight:360g</li> </ul>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#usage","title":"Usage","text":"<p>When users connect the Raspberry Pi to use, they need to configure the official system. Or you can also burn the configured system image directly.</p>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#hardware-connection","title":"Hardware Connection","text":"<p>1. Connect the HDMI Connector to both the HDMI interfaces on the LCD and the Pi. 2. LCD and Pi connect power. 3. Turn on the \"backlight\" switch on the back of the LCD. </p>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#bruning-the-image","title":"Bruning the Image","text":""},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#method-1-using-ready-to-use-image","title":"Method 1. Using Ready-to-use image","text":"<p>The image file with pre-installed driver is located in the IMAGE directory of the DVD. Extract the IMAGE file and you will get an .img file. you can refer to the :5 Inch 800x480 TFT Display</p>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#method-2-driver-installation","title":"Method 2. Driver installation","text":""},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#step1-download-the-latest-system-and-unzip-the-image","title":"Step1: Download the latest system and unzip the image","text":"<p>For Raspbian: (Not LITE version) https://www.raspberrypi.org/downloads/raspbian/ For Ubuntu Mate: https://ubuntu-mate.org/download/#xenial For Kali: https://www.offensive-security.com/kali-linux-arm-images/ For Retropie: https://retropie.org.uk/download/ And then unzip the image file.(Next step will use it.)  </p>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#step2-bruning-the-image-to-sd-card","title":"Step2: Bruning the Image to SD Card","text":"<p>How to bruning an image to a micro SD card for your Pi? you can refer to the :5 Inch 800x480 TFT Display</p>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#step3-find-the-configtxt-in-the-sds-root-and-open-it-then-add-the-following-code-in-the-end-according-to-resolution","title":"Step3: Find the config.txt in the SD`s root and open it. Then add the following code in the end according to resolution.","text":"<pre><code>hdmi_force_hotplug=1\nmax_usb_current=1\nhdmi_group=2\nhdmi_mode=1\nhdmi_mode=87\nhdmi_cvt 1024 600 60 6 0 0 0\nhdmi_drive=1\n</code></pre>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#step2-insert-sd-card-and-power-on","title":"Step2: Insert SD card and Power ON","text":"<p>The screen should be working now. </p>"},{"location":"Products/Display/7-inch-1024x600-tft-display-for-raspberry-pi-b2b-pcduino-banana-pi.html#install-soft-keyboard","title":"Install Soft Keyboard","text":"<ul> <li>Install the reference link\uff1ahttps://github.com/Elecrow-keen/Elecrow-LCD5/wiki/How-to-Install-Soft-Keyboard</li> </ul>"},{"location":"Products/Display/7-inch-tft-display-for-raspberry-pi-b2b-banana-pi-bb-black.html","title":"7 Inch TFT Display for Raspberry Pi B+ Banana Pi BB BLACK","text":""},{"location":"Products/Display/7-inch-tft-display-for-raspberry-pi-b2b-banana-pi-bb-black.html#description","title":"Description","text":"<p>This LCD module is 800x480 dots 7 \" color TFT LCD module display with HDMI signal driver board, superior display quality, super wide view angle. It can be used in any embedded system, car, industrial device, security and hand-held equipment which requires display in high quality and colorful video. Its HDMI interface is fully compatible with Raspberry PI, and Banana Pi platform.</p> <p>Model:7inch</p> <p></p>"},{"location":"Products/Display/7-inch-tft-display-for-raspberry-pi-b2b-banana-pi-bb-black.html#features","title":"Features","text":"<ul> <li>Resolution: 800*480</li> <li>Touch Control: Capacitive</li> <li>Raspberry Pi: Support Raspberry Pi 2 B/ B+/A+</li> <li>Banana Pi / Banana Pro: Support, comes with related images like : Lubuntu, Raspbian</li> <li>BB Black: Support, comes with related images like : Angstrom</li> <li>HDMI interface: For Displaying</li> <li>USB Interface: For touch control</li> <li>Back light control to lower power consumption</li> <li>Sizes:165 x 107mm</li> </ul>"},{"location":"Products/Display/7-inch-tft-display-for-raspberry-pi-b2b-banana-pi-bb-black.html#usage","title":"Usage","text":""},{"location":"Products/Display/7-inch-tft-display-for-raspberry-pi-b2b-banana-pi-bb-black.html#1-connect-raspberry-pi-to-use","title":"1: Connect Raspberry Pi to use","text":"<ul> <li>Step 1: 1)Please download the image of the latest version from Raspberry Pi's website.</li> </ul> <p>https://www.raspberrypi.org/downloads/raspbian/</p> <ul> <li>Step 2: Download the compressed file to your PC and unpack it to get the .Img file.</li> <li>Step 3: 3)The TF card is connected to the PC and formatted using the \u201cSDFormatter\u201d software.</li> <li>Step 4: Open the \u201cWin32DiskImager\u201d software, select the system image prepared in step 1), and click write to burn the system image.</li> <li>Step 5: 5)After the programming is completed, open the \u201cconfig.txt\u201d file in the root directory of the TF card, and add the following code at the end of \u201cconfig.txt\u201d to save and safely eject the TF card.</li> </ul> <p>max_usb_current=1 hdmi_group=2 hdmi_mode=1 hdmi_mode=87 hdmi_cvt 800 480 60 6 0 0 0 hdmi_drive=1</p> <ul> <li>Step 6: Save and insert the TF card into the Raspberry Pi.</li> <li>Step 7: Connect the touch interface of the 7-inch screen to the USB interface of the Raspberry Pi with Micro USB cable.</li> <li>Step 8: Connect the HDMI interface of the 7-inch screen to the HDMI interface of the Raspberry Pi, power on the Raspberry Pi, and turn on the \u201cbacklight\u201d switch on the back of the LCD. Wait for a few seconds to display normally.</li> </ul> <p></p>"},{"location":"Products/Display/7-inch-tft-display-for-raspberry-pi-b2b-banana-pi-bb-black.html#2-use-as-pc-monitor","title":"2: Use as PC monitor","text":"<ul> <li>Step 1: Connect the computer HDMI output signal to the LCD HDMI interface by using the HDMI cable.</li> <li>Step 2: Connect the LCD's USB Touch interface to the USB port of the device.</li> <li>Step 3: If there are several monitors, please unplug other monitor connectors first, and use LCD as the only monitor for testing.</li> </ul>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html","title":"HDMI Interface 5 Inch 800x480 TFT Display","text":""},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#description","title":"Description","text":"<p> Friendly Reminder: In the past deliveries, there is a CD with outdated driver. Please ignore the CD, we won't put the CD in the next deliveries. Download the latest driver from this page. </p> <p>This 5 inch TFT Display with Touch Screen is a mini panel-mountable HDMI monitor. So small and simple, but you can use this display with any computer that has HDMI output, and the shape makes it easy to attach to a electronic product. Although the 800x480 common HDMI display is made for Raspberry Pi, we can use it other where not only for Raspberry Pi.</p> <p>Model:RPA05010R</p> <p></p> <p></p>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#features","title":"Features","text":"<ul> <li>A good solution for those seeking for a bigger resolution display</li> <li>Good touch response</li> <li>Large viewing angle</li> <li>Fast response time</li> <li>Support backlight control alone</li> <li>Not only for Raspberry Pi</li> <li>Not only for mini-PCs, it can work as a computer monitor</li> <li>With detail user guide and image</li> </ul>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#specifications","title":"Specifications","text":"<ul> <li>5 inch TFT Resistive touch screen display, 800x480 Resolution</li> <li>HDMI input</li> <li>Usb touch and power, 5V@1A</li> <li>Touch: 4-wire resistive touch</li> <li>Lcd driver IC: ILI9486L</li> <li>Refresh rate\uff1a60HZ</li> <li>Lcd Size \uff1a121.11mm*77.93mm</li> <li>Weight:175g</li> </ul>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#interface-function","title":"Interface Function","text":"<p> \u2460 USB interface\uff1aGet 5V Power from USB,If \u2463-13*2 Pin Socket has been connected, that this USB interface can be No Connect. \u2461 HDMI interface\uff1aFor HDMI transmission. \u2462 Backlight Power switch\uff1aControls the backlight turned on and off to save power.  \u2463 13*2 Pin Socket\uff1aGet 5V Power from raspberry Pi to LCD, at the same time transfer touch signal back to raspberry Pi.  \u2464 extended interface\uff1aextended The \u2463-13*2 Pin Socket signal Pin-to-Pin.</p>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#usage","title":"Usage","text":"<p>Our 5 inch screen supports Raspbian,Ubuntu Mate,Kali Linux and Retropie system for Raspberry Pi.If you use it on PC or others that the touch function is unable to use. And next, we will teach you how to install the driver for your raspberry pi OS. If no system in your SD card, please refer to the Raspberry Pi office tutorial.</p> <p>Step1: Install the 5 inch LCD</p> <p>Install the 5 inch LCD to Raspberry-Pi 3B/2B/B+ board as below: </p> <p></p> <p>Step2: Modify your config.txt file </p> <p>Tips: If you use SSH to control Pi,please skip this step.</p> <p>Insert the SD card to your Windows/Mac PC. Find the config.txt in the SD`s root and open it. Then add the following code in the end.</p> <pre><code># --- added by elecrow-pitft-setup  ---\nhdmi_force_hotplug=1\nmax_usb_current=1\nhdmi_drive=1\nhdmi_group=2\nhdmi_mode=1\nhdmi_mode=87\nhdmi_cvt 800 480 60 6 0 0 0\ndtoverlay=ads7846,cs=1,penirq=25,penirq_pull=2,speed=50000,keep_vref_on=0,swapxy=0,pmax=255,xohms=150,xmin=200,xmax=3900,ymin=200,ymax=3900\ndisplay_rotate=0\n# --- end elecrow-pitft-setup  ---\n</code></pre> <p>Step3: Power ON and open terminal</p> <p>Tips: When the Raspberry startup, it can normal display and next step you need to install the driver.</p> <p></p> <p>Step4: Download the driver Method 1: Online installation (Raspberry Pi needs to be connected to the Internet) Run:</p> <pre><code>sudo rm -rf LCD-show\ngit clone https://github.com/goodtft/LCD-show.git \n</code></pre> <p>Tips:  For Kali Linux, you need to mount boot, run: mount /dev/mmcblk0p1 /boot/ And next: Run:</p> <pre><code>chmod -R 755 LCD-show\ncd LCD-show/\nsudo ./LCD5-show\n</code></pre> <p>Method 2: Offline installation Download LCD-show.zip Unzip 'LCD-show.zip' and copy the folder to the root directory of Raspberry Pi after flashing the image.</p> <p>Run:</p> <pre><code>cd /boot\ncd LCD-show/\nsudo ./LCD5-show\n</code></pre> <p>Step5: Rebot The screen should be working now. </p>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#touch-screen-calibration","title":"Touch screen calibration","text":""},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#old-version","title":"Old Version","text":"<p>Install the xinput-calibrator</p> <p>Run:</p> <p>sudo apt-get install -y xinput-calibrator</p> <p>And next:</p> <ul> <li>Click the Men button on the task bar, choose Preference -&gt; Calibrate Touchscreen.</li> <li>Finish the touch calibration following the prompts. Maybe rebooting is required to make calibration active.</li> <li>You can create a 99-calibration.conf file to save the touch parameters (not necessary if file exists).</li> </ul> <pre><code>/etc/X11/xorg.conf.d/99-calibration.conf\n</code></pre> <ul> <li>Save the touch parameters (may differ depending on LCD) to 99-calibration.conf, as shown in the picture:</li> </ul> <p></p>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#new-version","title":"New Version","text":"<ul> <li>Resistance touch screen calibration.pdf</li> </ul>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#install-soft-keyboard","title":"Install Soft Keyboard","text":"<ul> <li>Install the reference link</li> </ul>"},{"location":"Products/Display/hdmi-interface-5-inch-800x480-tft-display.html#resource","title":"Resource","text":"<ul> <li>5inch_HDMI_Display_User_Manual in PDF </li> <li>Config file</li> <li>5 Inch Display Configured system for B+ 2B </li> <li>5 Inch Display Configured system for 3B </li> <li>LCD-show.zip</li> </ul>"},{"location":"Products/Elecrow-Cooperator-Partner/cooperator-designer.html","title":"Cooperator Designer","text":"<p>View cooperator designer's products on this page</p> <p>It's Win-Win-Win cooperation. Elecrow bring great Projects/Products to customers and Expand cooperator's project worldwide and New customers may find Elecrow because of this design.</p> <p>Many designers and developers have encountered this problem: product design and development have proceeded smoothly, but production is a big problem. PCB Manufacturing and Assembly, Component Sourcing, Quality Control, Logistics, Payment, Packaging, and Shipping are all complicated issues that consume a lot of time and effort.</p> <p>Elecrow supplies professional hardware-related services worldwide, in order to help makers interact and learn from each other, and to create a harmonious and sustainable development environment. Now, let Elecrow help you solve your production problems. As Elecrow Cooperator Designers, you can get the following services:</p> <ul> <li>Investment in the production if your design gets approved by the Elecrow team.</li> <li>Production Services. Elecrow has a professional team to finish the PCB fabrication, Parts sourcing, PCB assembly, Testing, Packaging, and dropshipping, etc.</li> <li>Warehousing; Logistics to ensure that your design is presented to the user beautifully.</li> <li>Monthly sales report for your product.</li> <li>Drop shipping: Elecrow ships the products to your customers one by one and lower the shipping price.</li> <li>Other Special Needs</li> </ul> <p>This PDF file Elecrow partner v1.2.pdf Shows how the cooperator works.</p>"},{"location":"Products/Elecrow-Cooperator-Partner/cooperator-designer.html#qa-for-being-elecrow-cooperator","title":"Q&amp;A for being Elecrow Cooperator","text":"<ul> <li>Q: Can I send the products to Elecrow and sells them to Elecrow's online store?</li> <li> <p>A: Yes, it is ok. there will be extra stock fees if need a large place or stocked for more than 1 month.</p> </li> <li> <p>Q: What profit would the cooperate designer get?</p> </li> <li>A: The designer decides the retail price and gets 90% of the retail sale fees per sale. Elecrow shares 10% of the retail price for the promotion fee, handling fee, and payment fees</li> </ul> <p>(ps: PayPal or credit card processor will charge about 5% of the total fees that are included in the 10% that Elecrow charged).</p> <ul> <li>Q: Can I join the Elecrow affiliate program?</li> <li>A: Yes, you will get 5% to 10% affiliate fees for customers who clicked your link to purchase on the Elecrow website. Manual quoted products not included, such as PCB assembly, and Premium PCB service.</li> </ul> <p>Here are the details of Elecrow affiliate</p> <ul> <li>Q: Who responded to the loss when shipping to customers?</li> <li>A: There will be about 0.5% to 1% shipping loss for international shipping.</li> </ul> <p>Elecrow will respond to the product cost for shipping loss. Elecrow will Re-ship the product to the customer or cancel the order and refund the customer.</p> <ul> <li>Q: Can we have NDA with the design file?</li> <li> <p>A: Yes, we guarantee 100% confidentiality and allow cooperated designers worldwide to submit their work to us with complete confidence. NDA is also applicable if needed.</p> </li> <li> <p>Q: Can you give a probable quantity for the sales?</p> </li> <li> <p>A\uff1a Elecrow will not promise the sales quantity but we'll help list your design on the Elecrow store and support promotions during special events like Black Friday.</p> </li> <li> <p>Q: Is free shipping available for cooperators' products?</p> </li> <li>A: Free shipping is not available for the cooperator's products.</li> </ul> <p>Please feel free to contact us if there is any question.</p>"},{"location":"Products/Modules-for-Prototyping/adjustable-integrated-dc-dc-module--lm2596s.html","title":"Adjustable Integrated DC-DC Module- LM2596S","text":""},{"location":"Products/Modules-for-Prototyping/adjustable-integrated-dc-dc-module--lm2596s.html#description","title":"Description","text":"<p>This module integrated a volage meter with the DC-DC module \u2013 LM2596S, with this function, you can monitor your project much more easier. The voltage meter can measure the input voltage or output voltage, which is adjustable by the protentiometer, with a precision of \u00b10.1V.Note that the voltage meter would not work if the input voltage below 4V. Press the button to switch voltage to measure, between the input voltage and output voltage. There are also 2 LEDs (IN and OUT) to indicate which voltage is measuring by the voltage meter. Model:PCH2596M </p> <p></p>"},{"location":"Products/Modules-for-Prototyping/adjustable-integrated-dc-dc-module--lm2596s.html#specification","title":"Specification","text":"<ul> <li>Input Voltage: 4V~40V (1.5V higher than the output at least)</li> <li>Measurement Accuracy: \u00b10.1V</li> <li>Adjustable Output Voltage: 1.5V~35V.</li> <li>Output Current: 3A</li> <li>Dimension: 66mm x 35mm x 14mm</li> </ul>"},{"location":"Products/Modules-for-Prototyping/adjustable-integrated-dc-dc-module--lm2596s.html#interface","title":"Interface","text":""},{"location":"Products/Modules-for-Prototyping/adjustable-integrated-dc-dc-module--lm2596s.html#usage","title":"Usage","text":"<p>This module can be also calibrated manually as following method: 1. Power up the module with a stable and accurate power supply , such as a 5V power supply, and long pressing (press time &gt; 4S) the button makes the module enter the calibration model, after releasing the button, the related LED would light up to indicate which voltage is now calibrating, and the numeric display blinks the correction value.(Default: 0.0V) 2. Short press the botton to change the correction value(-0.5V ~ 0.5V), for example, if your power supply is 5V, but the result of voltage meter is 4.8, you need to set the correction value to +0.2V. 3. Long press (press time \u2248 2S), to store the input voltage correction value, the module will enter the output voltage correction value calibration model automatically. 4. Calibrate the output voltage in the same way above; The correction value will be stored in nonvolatile memory.  </p> <p></p> <p></p> <p></p> <p>You can also close the voltage meter by long pressing the button (1S&lt; press time &lt; 4S), after you releasing the button, the voltage meter would be close.</p>"},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html","title":"Breadboard Power Supply","text":""},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html#introduction","title":"Introduction","text":"<p>This Breadboard Power Supply can directly takes power from DC Jack or Mini USB port and outputs a selectable 5V or 3.3V regulated voltage directly to breadboard. This power supply fits the breadboard like Basic Bread Board With Slot.</p> <p>With this board, you can send power to both power lane of the breadboard, and each side has a on/off switch.</p> <p>Model: PSB02011B</p> <p></p>"},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html#features","title":"Features","text":"<ul> <li>5V/3.3V regulated voltage</li> <li>Dual lane output</li> <li>Separate power selection for each lane</li> <li>Dual power port input</li> <li>Special designed for Breadboard usage</li> </ul>"},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html#specification","title":"Specification","text":"Specification Conditions Min Typ max Unit Input voltage 5.0 6.5 12.0 V Output Voltage Channel 3.3V 3.235 3.3 3.365 V Channel 5V: 10mA\u2264IOUT\u2264600mA, 6.5V\u2264VIN \u226412V 4.9000 5.0 5.100 V Output Current 800 mA"},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html#usage","title":"Usage","text":""},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html#hardware-installation","title":"Hardware Installation","text":"<ol> <li>Align the polarity of pin header to breadboard. (Usually Red for +, Blue for -)</li> <li>Plug the supply board to breadboard completely.</li> </ol> <p>Now you may de-activate power by the two jumpers, or adjust the vertical switches to select different voltage. The horizontal switch is used to select Jack pin or mini USB cable as input.</p>"},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html#resource","title":"Resource","text":"<ul> <li>Breadboard Power Supply Schematic in PDF</li> </ul>"},{"location":"Products/Modules-for-Prototyping/breadboard-power-supply.html#how-to-buy","title":"How to buy","text":"<p>You can visit here to purchase it.</p>"},{"location":"Products/Sensors/1-axis-analog-gyro-module-enc03.html","title":"1-Axis Analog Gyro Module-ENC03","text":""},{"location":"Products/Sensors/1-axis-analog-gyro-module-enc03.html#description","title":"Description","text":"<p>This angular velocity sensor utilizes a Coriolis force that act on a vibrating object when an angular velocity is applied to it. The use of this unit simplifies equipment structure and circuit configuration, thus making it possible to provide outstanding performance. This module can be used for positional control and posture control of a moving object requiring precision and quick-response measurements. There is one ENC-03r senor on this module, provides 1-axis velocity with high speed, which outputs as analog voltage.</p> <p>Model:SENC031G</p> <p></p>"},{"location":"Products/Sensors/1-axis-analog-gyro-module-enc03.html#features","title":"Features","text":"<ul> <li>Supply Voltage: 2.7V~5.25V DC</li> <li>Resonance Frequency: 30.8 kHz</li> <li>Max Angular Velocity: \u00b1300 Degree</li> <li>Output (at Angular Velocity=0): 1.35 V DC</li> <li>Scale Factor: 0.67 mV/deg/sec.</li> <li>Linearity: \u00b15%;</li> </ul>"},{"location":"Products/Sensors/1-axis-analog-gyro-module-enc03.html#usage","title":"Usage","text":"<p>The module detects one-axis rotation with analog signal.</p> <p>1.Hardware Connection 5V+--5V GND--GND OUT--A0</p> <p></p> <p>2.Upload the below code.</p> <pre><code>int sensorPin = A0;             // select the input pin for the sensor\n\nfloat reference_Value=0;\n\nint sensorValue = 0;            // variable to store the value coming from the sensor\n\nvoid setup() {\n\n   int i;\n   float sum=0;\n   pinMode(sensorPin, INPUT);\n   Serial.begin(9600);\n   Serial.println(\"Please do not rotate it before calibrate!\");\n   Serial.println(\"Get the reference value:\");\n\n   for(i=0;i&lt;1000;i++)\n   {\n       // read the value from the sensor:\n       sensorValue = analogRead(sensorPin);\n       sum += sensorValue;\n       delay(5);\n   }\n   reference_Value = sum/1000.0;\n   Serial.println(reference_Value);\n   Serial.println(\"Now you can begain your test!\");\n}\n\nvoid loop() \n{\n\n   double angularVelocity;\n   sensorValue = analogRead(sensorPin);\n   angularVelocity =((double)(sensorValue-reference_Value)*4930.0)/1023.0/0.67; //get the angular velocity\n   Serial.print(angularVelocity);\n   Serial.println(\"deg/s\");\n   Serial.println(\" \");\n   delay(500);\n}\n</code></pre> <p>3.Now, it is time to the calibration. Put the sensor on your desk horizontally, and then press the Reset button on the Crowduino, and then Open the serial tool:</p> <p></p> <p>4.As you see the \"Now you can begin your test\", that means the calibration done. You can use the sensor now. Rotating direction can reference the following picture:</p> <p></p>"},{"location":"Products/Sensors/1-axis-analog-gyro-module-enc03.html#resource","title":"Resource","text":"<ul> <li>Analog_Gyro Program</li> <li>ENC-03 Datasheet </li> </ul>"},{"location":"Products/Sensors/1019dround-fingerprint-recognition-sensor-module-id809.html","title":"1019DRound fingerprint recognition sensor module ID809","text":""},{"location":"Products/Sensors/1019dround-fingerprint-recognition-sensor-module-id809.html#description","title":"Description","text":"<p>This round fingerprint module takes ID809 high-performance processor and semiconductor fingerprint sensor as the core runs the new IDfinger6.0 fingerprint algorithm, which can realize fingerprint registration, comparison, deletion functions ,and colorful lighting effects. And the integrated chip also reduces the volume of the fingerprint module.</p> <p>The product structure is simple, and the modular design improves the stability and consistency of the product. The fingerprint sensor module supports UART communication mode and with the SDK development kit, it can be connected to any microcontroller or system using a TTL serial, which is convenient for secondary development. It also comes with a 6-pin Molex style 1mm pitch connector that you can easily cut and solder directly to the wires.</p> <p>Model: DPI59818S </p> <p></p>"},{"location":"Products/Sensors/1019dround-fingerprint-recognition-sensor-module-id809.html#features","title":"Features","text":"<ul> <li>Good experience and high security: The brand-new IDfinger6.0 fingerprint algorithm is deeply optimized and fully accelerated; Fingerprint recognition has fast speed and high security, and it supports 360-degree recognition at any angle.</li> <li>High performance and low power consumption: The module CPU is produced by advanced technology, with ARM\u00ae Cortex\u2122-M4 core, which has fast operation speed and low power consumption.</li> <li>Complete functions: It integrates functions such as fingerprint collection, image processing, feature extraction, fingerprint registration, fingerprint comparison, fingerprint deletion, and other functions.</li> <li>Easy to develop: support Windows, Android, embedded systems, standard UART communication, and provide SDK development kit</li> <li>Compact size: simple structure, small size, can be flexibly embedded in various products with limited size</li> <li>Durable: high electrostatic withstand voltage, strong anti-interference ability, and sturdy shape.</li> </ul>"},{"location":"Products/Sensors/1019dround-fingerprint-recognition-sensor-module-id809.html#specifications","title":"Specifications","text":"<ul> <li>Active capacitive sensor can store 200 fingerprints</li> <li>1:1 verification time is about 300~400ms</li> <li>The communication method with the host is UART</li> <li>The pixel resolution of the sensor is 508dpi</li> <li>The pixel count of the sensor is 160x160</li> <li>360\u00b0 fingerprint entry and matching</li> <li>The outer frame size of the sensor is 12.8m in diameter, fingerprint detection area 8.0mm x 8.0mm</li> <li>The anti-scratch rating of the sensor is 4H, and the anti-static level is +/\u2010 15kV</li> <li>The working environment of the product is -40 -60\u2103/&lt;RH 90%</li> <li>PCB diameter of the product is 21mm, installation is 19mm,height is 5mm</li> <li>CNC firing metal ring, plus aperture</li> </ul>"},{"location":"Products/Sensors/1019dround-fingerprint-recognition-sensor-module-id809.html#dimensions","title":"Dimensions","text":"<p>PCB diameter: 21mm, installation diameter: 19mm, height: 5mm </p>"},{"location":"Products/Sensors/1019dround-fingerprint-recognition-sensor-module-id809.html#pinout","title":"Pinout","text":"No. Name Description 1 GND Groud 2 UART_RX UART receive 3 UART_TX UART transmit 4 VIN +3.3V: connect to work; disconnect to enter sleep 5 IRQ/WAKEUP Finger sensing output: active high 6 VCC Power supply (+3.3V)"},{"location":"Products/Sensors/1019dround-fingerprint-recognition-sensor-module-id809.html#resources","title":"Resources","text":"<ul> <li>Programm_File</li> <li>NOEM_Host.zip</li> <li>specification_ch.pdf</li> <li>Instruction_set_ch.pdf</li> </ul>"},{"location":"Products/Sensors/2-axis-analog-gyro-module-enc03.html","title":"2-Axis Analog Gyro Module-ENC03","text":""},{"location":"Products/Sensors/2-axis-analog-gyro-module-enc03.html#description","title":"Description","text":"<p>This angular velocity sensor utilizes a Coriolis force that act on a vibrating object when an angular velocity is applied to it. The use of this unit simplifies equipment structure and circuit configuration, thus making it possible to provide outstanding performance.  This module can be used for positional control and posture control of a moving object requiring precision and quick-response measurements. There is two ENC-03r senor on this module, provides 2-axis velocity with high speed, which outputs as analog voltage.</p> <p>Model:SENC032G</p> <p></p>"},{"location":"Products/Sensors/2-axis-analog-gyro-module-enc03.html#features","title":"Features","text":"<ul> <li>Supply Voltage: 2.7V~5.25V DC</li> <li>Resonance Frequency: 30.8 kHz</li> <li>Max Angular Velocity: \u00b1300 Degree</li> <li>Output (at Angular Velocity=0): 1.35 V DC</li> <li>Scale Factor: 0.67 mV/deg/sec.</li> <li>Linearity: \u00b15%;</li> </ul>"},{"location":"Products/Sensors/2-axis-analog-gyro-module-enc03.html#usage","title":"Usage","text":"<p>The module detects one-axis rotation with analog signal.</p> <p>1.Hardware Connection 5V+--5V GND--GND X--A0 Y--A1</p> <p></p> <p>2.Copy the below code to you new skecth,then upload it.</p> <pre><code>int X_Axis = A0;             // select the input pin for the sensor\nint Y_Axis = A1; \nfloat X_reference_Value=0;\nfloat Y_reference_Value=0;\n\nint X_Axis_Value = 0;            // variable to store the value coming from the sensor\nint Y_Axis_Value = 0;\n\nvoid setup() {\n\n   int i;\n   float X_sum=0,Y_sum=0;\n   pinMode(X_Axis, INPUT);\n   pinMode(Y_Axis, INPUT);\n   Serial.begin(9600);\n   Serial.println(\"Please do not rotate it before calibrate!\");\n   Serial.println(\"Get the reference value:\");\n\n   for(i=0;i&lt;1000;i++)\n   {\n       // read the value from the sensor:\n       X_Axis_Value = analogRead(X_Axis);\n       Y_Axis_Value = analogRead(Y_Axis);\n       X_sum += X_Axis_Value;\n       Y_sum += Y_Axis_Value;\n       delay(5);\n   }\n   X_reference_Value = X_sum/1000.0;\n   Y_reference_Value = Y_sum/1000.0;\n   Serial.print(\"reference_Value:   \");\n   Serial.print(\"X:\");\n   Serial.print(X_reference_Value);\n   Serial.print(\"  Y:\");\n   Serial.println(Y_reference_Value);\n   Serial.println(\"Now you can begain your test!\");\n}\n\nvoid loop() \n{\n   double X_angularVelocity,Y_angularVelocity;\n   X_Axis_Value = analogRead(X_Axis);\n   Y_Axis_Value = analogRead(Y_Axis);\n   X_angularVelocity =((double)(X_Axis_Value-X_reference_Value)*4930.0)/1023.0/0.67; //get the angular velocity\n   Y_angularVelocity =((double)(Y_Axis_Value-Y_reference_Value)*4930.0)/1023.0/0.67;\n   Serial.print(\"angularVelocity:  \");\n   Serial.print(\"X:\");\n   Serial.print(X_angularVelocity);\n   Serial.print(\"deg/s\");\n   Serial.print(\"   Y:\");\n   Serial.print(Y_angularVelocity);\n   Serial.print(\"deg/s\");\n   Serial.println(\" \");\n   delay(500);\n}\n</code></pre> <p>3.Now, it is time to the calibration. Put the sensor on your desk horizontally, and then press the Reset button on the Crowduino, and then Open the serial tool:</p> <p></p> <p>4.As you see the \"Now you can begin your test\", that means the calibration done. You can use the sensor now. Rotating direction can reference the following picture:</p> <p></p>"},{"location":"Products/Sensors/2-axis-analog-gyro-module-enc03.html#resource","title":"Resource","text":"<ul> <li>Demo code</li> <li>ENC-03 Datasheet </li> </ul>"},{"location":"Products/Sensors/3-axis-analog-gyro-module-enc03.html","title":"3-Axis Analog Gyro Module-ENC03","text":""},{"location":"Products/Sensors/3-axis-analog-gyro-module-enc03.html#description","title":"Description","text":"<p>This angular velocity sensor utilizes a Coriolis force that act on a vibrating object when an angular velocity is applied to it. The use of this unit simplifies equipment structure and circuit configuration, thus making it possible to provide outstanding performance.  This module can be used for positional control and posture control of a moving object requiring precision and quick-response measurements. There is two ENC-03r senor on this module, provides 2-axis velocity with high speed, which outputs as analog voltage.</p> <p>Model:SENC032G</p> <p></p>"},{"location":"Products/Sensors/3-axis-analog-gyro-module-enc03.html#features","title":"Features","text":"<ul> <li>Supply Voltage: 2.7V~5.25V DC</li> <li>Resonance Frequency: 30.8 kHz</li> <li>Max Angular Velocity: \u00b1300 Degree</li> <li>Output (at Angular Velocity=0): 1.35 V DC</li> <li>Scale Factor: 0.67 mV/deg/sec.</li> <li>Linearity: \u00b15%;</li> </ul>"},{"location":"Products/Sensors/3-axis-analog-gyro-module-enc03.html#usage","title":"Usage","text":"<p>The module detects one-axis rotation with analog signal.</p> <p>1.Hardware Connection 5V+--5V GND--GND X--A0 Y--A1 Z--A2</p> <p></p> <p>2.Copy the below code to you new skecth,then upload it.</p> <pre><code>int X_Axis = A0;             \nint Y_Axis = A1; \nint Z_Axis = A2;\nfloat X_reference_Value=0;\nfloat Y_reference_Value=0;\nfloat Z_reference_Value=0;\nint X_Axis_Value = 0;           \nint Y_Axis_Value = 0;\nint Z_Axis_Value = 0;\nvoid setup() {\n\n   int i;\n   float X_sum=0,Y_sum=0,Z_sum=0;\n   pinMode(X_Axis, INPUT);\n   pinMode(Y_Axis, INPUT);\n   pinMode(Z_Axis, INPUT);\n   Serial.begin(9600);\n   Serial.println(\"Please do not rotate it before calibrate!\");\n   Serial.println(\"Get the reference value:\");\n\n   for(i=0;i&lt;1000;i++)\n   {\n       // read the value from the sensor:\n       X_Axis_Value = analogRead(X_Axis);\n       Y_Axis_Value = analogRead(Y_Axis);\n       Z_Axis_Value = analogRead(Z_Axis);\n       X_sum += X_Axis_Value;\n       Y_sum += Y_Axis_Value;\n       Z_sum += Z_Axis_Value;\n       delay(5);\n   }\n   X_reference_Value = X_sum/1000.0;\n   Y_reference_Value = Y_sum/1000.0;\n   Z_reference_Value = Z_sum/1000.0;\n   Serial.print(\"reference_Value:   \");\n   Serial.print(\"X:\");\n   Serial.print(X_reference_Value);\n   Serial.print(\"  Y:\");\n   Serial.print(Y_reference_Value);\n   Serial.print(\"  Z:\");\n   Serial.println(Z_reference_Value);\n   Serial.println(\"Now you can begain your test!\");\n}\n\nvoid loop() \n{\n   double X_angularVelocity,Y_angularVelocity,Z_angularVelocity;\n   X_Axis_Value = analogRead(X_Axis);\n   Y_Axis_Value = analogRead(Y_Axis);\n   Z_Axis_Value = analogRead(Z_Axis);\n   X_angularVelocity =((double)(X_Axis_Value-X_reference_Value)*4930.0)/1023.0/0.67; //get the angular velocity\n   Y_angularVelocity =((double)(Y_Axis_Value-Y_reference_Value)*4930.0)/1023.0/0.67;\n   Z_angularVelocity =((double)(Z_Axis_Value-Z_reference_Value)*4930.0)/1023.0/0.67;\n   Serial.print(\"angularVelocity:  \");\n   Serial.print(\"X:\");\n   Serial.print(X_angularVelocity);\n   Serial.print(\"deg/s\");\n   Serial.print(\"   Y:\");\n   Serial.print(Z_angularVelocity);\n   Serial.print(\"deg/s\");\n  Serial.print(\"   Z:\");\n   Serial.print(Z_angularVelocity);\n   Serial.print(\"deg/s\");\n   Serial.println(\" \");\n   delay(500);\n}\n</code></pre> <p>3.Now, it is time to the calibration. Put the sensor on your desk horizontally, and then press the Reset button on the Crowduino, and then Open the serial tool:</p> <p></p> <p>4.As you see the \"Now you can begin your test\", that means the calibration done. You can use the sensor now. Rotating direction can reference the following picture:</p> <p></p>"},{"location":"Products/Sensors/3-axis-analog-gyro-module-enc03.html#resource","title":"Resource","text":"<ul> <li>Demo code</li> <li>ENC-03 Datasheet </li> </ul>"},{"location":"Products/Sensors/4mm-inductive-metal-proximity-sensor.html","title":"4MM Inductive Metal Proximity Sensor","text":""},{"location":"Products/Sensors/4mm-inductive-metal-proximity-sensor.html#description","title":"Description","text":"<p>Metal Proximity Sensor, which is also called non-contact proximity switch, it is composed of generator and shaping amplifier oscillator vibration in the switch after induction head, and produces an alternating magnetic field when the metal body detected. This Inductive Proximity Sensor has high sensitivity, fast frequency response, high repeat positioning accuracy and also stability and reliable, it can detects metal components in 0~4mm distance, and is widely used in modern industry, such as machinery, metallurgy, transportation, electric power, military industry and so on.</p> <p>Model:SPM0409IP</p> <p></p>"},{"location":"Products/Sensors/4mm-inductive-metal-proximity-sensor.html#specification","title":"Specification","text":"<ul> <li>Working Voltage:DC 6~36V;</li> <li>Probe Demension: 12mm diameter;</li> <li>Sensoring Distance: 0~4mm</li> <li>Output signal: Low</li> </ul>"},{"location":"Products/Sensors/4mm-inductive-metal-proximity-sensor.html#usage","title":"Usage","text":"<p>1.Hardware Connection</p> <p></p> <p>2.Copy the below code to you new skecth,then upload it.</p> <pre><code>const int ledpin=5;\nconst int Sensor = 4;\nvoid setup()\n{\n  pinMode(ledpin,OUTPUT);\n  pinMode(Sensor,INPUT); \n}\nvoid loop()\n{\n    if(digitalRead(Sensor))\n    {\n       digitalWrite(ledpin,LOW);\n    }\n    else{\n        digitalWrite(ledpin,HIGH);\n    }\n}\n</code></pre> <p>3.The LED will light up when a metal gets closed to the metal proximity sensor(0-4mm).</p>"},{"location":"Products/Sensors/4mm-inductive-metal-proximity-sensor.html#resource","title":"Resource","text":"<ul> <li>Demo code</li> </ul>"},{"location":"Products/Sensors/80cm-infrared-proximity-sensor-gp2y0a21yk0f.html","title":"80cm Infrared Proximity Sensor-GP2Y0A21YK0F","text":""},{"location":"Products/Sensors/80cm-infrared-proximity-sensor-gp2y0a21yk0f.html#description","title":"Description","text":"<p>The Sharp distance sensors are a popular choice for many projects that require accurate distance measurements. This IR sensor is more economical than sonar rangefinders, yet it provides much better performance than other IR alternatives. Interfacing to most microcontrollers is straightforward: the single analog output can be connected to an analog-to-digital converter for taking distance measurements, or the output can be connected to a comparator for threshold detection.</p> <p>Model:SPGP2YIP</p> <p></p>"},{"location":"Products/Sensors/80cm-infrared-proximity-sensor-gp2y0a21yk0f.html#specification","title":"Specification","text":"<ul> <li>Operating voltage: 4.5 V to 5.5 V</li> <li>Average current consumption: 30 mA (typical)</li> <li>Distance measuring range: 10 cm to 80 cm (4\" to 32\")</li> <li>Output type: analog voltage</li> <li>Output voltage differential over distance range: 1.9 V (typical)</li> <li>Response time: 38 \u00b1 10 ms</li> <li>Package size: 29.5\u00d713.0\u00d713.5 mm (1.16\u00d70.5\u00d70.53\")</li> <li>Weight: 3.5 g (0.12 oz)</li> </ul> <p>The detection range of this version is approximately 10 cm to 80 cm (4\" to 32\"); a plot of distance versus output voltage is shown below: </p>"},{"location":"Products/Sensors/80cm-infrared-proximity-sensor-gp2y0a21yk0f.html#usage","title":"Usage","text":"<p>The module detects one-axis rotation with analog signal.</p> <p>1.Hardware Connection</p> <p></p> <p>2.Copy the below code to you new skecth,then upload it.</p> <pre><code>/*\n *      \n *      VCC -- VCC  \n *      GND -- GND  \n *      Signal -- Analog 0 \n */\n#define pin A0\n\nvoid setup () {\n    Serial.begin (9600);\n    pinMode (pin, INPUT);\n}\n\nvoid loop () {\n    uint16_t value = analogRead (pin);\n    uint16_t range = get_gp2d12 (value);\n    Serial.print(\"Analog value:\");\n    Serial.println (value);\n    Serial.print (\"Distance:\");\n    Serial.print (range);\n    Serial.println (\" mm\");\n    Serial.println ();\n    delay (500);\n}\n\nuint16_t get_gp2d12 (uint16_t value) {\n    if (value &lt; 10) value = 10;\n    return ((67870.0 / (value - 3.0)) - 40.0);\n}\n</code></pre> <p>3.Open the serial tool,you can see the distance:</p> <p></p>"},{"location":"Products/Sensors/80cm-infrared-proximity-sensor-gp2y0a21yk0f.html#resource","title":"Resource","text":"<ul> <li>Demo code</li> <li>Datasheet</li> </ul>"},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html","title":"Accelerometer Breakout-MMA7361","text":""},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html#introduction","title":"Introduction","text":"<p>This is a breakout board for Freescale's MMA7361L three-axis analog accelerometer. The sensor requires a very low amount of power and has a g-select input which switches the accelerometer between \u00b11.5g and \u00b16g measurement ranges. Other features include a sleep mode, signal conditioning, a 1-pole low pass filter, temperature compensation, self test, and 0g-detect which detects linear freefall. Zero-g offset and sensitivity are factory set and require no external device.</p> <p>Model:SPS07361S</p> <p></p>"},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html#specification","title":"Specification","text":"<ul> <li>Two selectable measuring ranges (\u00b11.5g, \u00b16g).</li> <li>Low current consumption: 400 \u00b5ASleep mode: 3 \u00b5A.</li> <li>High sensitivity (800 mV/g at 1.5g).</li> <li>Seletable Sensitivity(\u00b11.5g, \u00b16g).</li> <li>Fast turn on time (0.5 ms enable response time).</li> <li>Dimensions: 28 * 17mm.</li> </ul>"},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html#pin-definition","title":"Pin Definition","text":"Pin Pad Name Type Description 1 5V P 5V power 2 3V3 P 3V3 power 3 GND GND GND 4 g-select I Input pin to initiate Self Test 5 Selftest I Self-Test 6 X A XOUT 7 Y A YOUT 8 Z A ZOUT 9 Sleep I Sleep mode, Low active 10 0g-detect O Linear Freefall digital logic output signal <p>A: Anlog Output  I: Digital Input  O: Digital Output</p>"},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html#usage","title":"Usage","text":"<p>it would be very easy to use this module. here we introduce 2 ways to use this module. a simple method, and a comprehensive method.</p>"},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html#use-this-module-with-the-default-settings","title":"Use this module with the default settings","text":"<p>Connect the X/Y/Z pins of the MMA7361 moduel to A0/A1/A2 of your Arduino/Crowduino. and power it with 5V power supply. Connect the \"SL\" pin to logic HIGH to enable the MMA7361 work. you can get the test result with analogRead in Arduino IDE as below:  </p> <p>1.Hardware connection  </p> <p>2.Copy the following program to Arduino IDE and upload to your Arduino/Crowduino:</p> <pre><code>// # Description:\n// # read the data from the accelerometer in default setting\n\n// # Connection:\n// #        x  -&gt; Analog pin 0\n// #        y  -&gt; Analog pin 1\n// #        z  -&gt; Analog pin 2\n// #\n\nconst int Sleep=2;\nvoid setup() \n{ \n  Serial.begin(9600); // 9600 bps\n  pinMode(Sleep, OUTPUT);\n  digitalWrite(Sleep, HIGH);\n}\nvoid loop() \n{\n  int x,y,z;\n  x=analogRead(0);\n  y=analogRead(1);\n  z=analogRead(2);\n  Serial.print(\"x= \");\n  Serial.print(x ,DEC);\n  Serial.print(',');\n  Serial.print(\"y= \");\n  Serial.print(y ,DEC);\n  Serial.print(',');\n  Serial.print(\"z= \");\n  Serial.println(z ,DEC);\n  delay(100);\n}\n</code></pre> <p>3.Open the Serial moniter , and set the baudrate to 9600, you will see the test value. </p>"},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html#use-this-module-in-a-comprehensive-way","title":"Use this module in a comprehensive way","text":"<p>1.Hardware connection </p> <p>2.You can also use the MMA7371 Library to use this module, you should first connect this module to your Arduino/Crowduino as belows: 3.Install the library and upload the program to your Arduino. please refer to here to learn how to upload the program.</p> <pre><code>#include &lt;AcceleroMMA7361.h&gt;\n\nAcceleroMMA7361 accelero;\nint x;\nint y;\nint z;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  accelero.begin(13, 12, 11, 10, A0, A1, A2);\n  accelero.setARefVoltage(3.3);                   //sets the AREF voltage to 3.3V\n  accelero.setSensitivity(LOW);                   //sets the sensitivity to +/-6G\n  accelero.calibrate();\n}\n\nvoid loop()\n{\n  x = accelero.getXAccel();\n  y = accelero.getYAccel();\n  z = accelero.getZAccel();\n  Serial.print(\"\\nx: \");\n  Serial.print(x);\n  Serial.print(\" \\ty: \");\n  Serial.print(y);\n  Serial.print(\" \\tz: \");\n  Serial.print(z);\n  Serial.print(\"\\tG*10^-2\");\n  delay(500);                                     //make it readable\n}\n</code></pre> <p>4.Open the serial monitor, after the calibrating, MMA 7361 will output the gravity on x, y and z axis. The photo below shows the output data when the accelerometor is lying flat, the gravity of Z axis is about 100(1 G).Please note keep this module flat when calibrating. </p>"},{"location":"Products/Sensors/accelerometer-breakout-mma7361.html#resource","title":"Resource","text":"<ul> <li>MMA7361 Module DataSheet</li> <li>MMA7361 Module Demo code</li> </ul>"},{"location":"Products/Sensors/acs712-current-sensor--5a.html","title":"ACS712 Current Sensor- 5A","text":""},{"location":"Products/Sensors/acs712-current-sensor--5a.html#description","title":"Description","text":"<p>Sensing and controlling current flow is a fundamental requirement in a wide variety of applications including, over-current protection circuits, battery chargers, switching mode power supplies, digital watt meters, programmable current sources, etc. This ACS721 current module is based on ACS712 sensor, which can accurately detect AC or DC current. The maximum AC or DC that can be detected can reach 5A, and the present current signal can be read via analog I / O port of Arduino.</p> <p>Model:SEL7125A</p> <p></p> <p></p>"},{"location":"Products/Sensors/acs712-current-sensor--5a.html#features","title":"Features","text":"<ul> <li>Supply Voltage: 4.5V~5.5V DC</li> <li>Measure Current Range: -5A~ 5A</li> <li>Sensitivity: 180mV/A ~190mV/A, Typical: 185mV/A</li> </ul>"},{"location":"Products/Sensors/acs712-current-sensor--5a.html#usage","title":"Usage","text":"<p>Arduino test the crrrent.</p> <p>1.Hardware connection</p> <p> 600px</p> <p>Notice:Current sensor can not directly connect on both ends of the power supply.</p> <p>2.Connect the board to PC using USB cable.</p> <p>3.Upload the following sample sketch:</p> <pre><code>void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n float average = 0;\n for(int i = 0; i &lt; 1000; i++) {\n     average = average + (.0264 * analogRead(A0) -13.51);//for the 5A mode,  \n//   average = average + (.049 * analogRead(A0) -25);// for 20A mode\n// average = average + (.742 * analogRead(A0) -37.8);// for 30A mode\n   delay(1);\n }\n Serial.print(\"Current\u00a0:\");\n Serial.print(average/1000);\n Serial.println(\"A\");\n}\n</code></pre> <p>4.Open the serial monitor.You can see the current you test.</p> <p></p>"},{"location":"Products/Sensors/acs712-current-sensor--5a.html#resource","title":"Resource","text":"<ul> <li>Demo code</li> <li>ACS712.pdf</li> </ul>"},{"location":"Products/Sensors/adjustable-infrared-sensor-switch.html","title":"Adjustable Infrared Sensor Switch","text":""},{"location":"Products/Sensors/adjustable-infrared-sensor-switch.html#introduction","title":"Introduction","text":"<p>This infrared distance switch features a high-sensitivity photoreflector to perform distance detection function,ranging from 3cm to 80cm. When the infrared light emitted by the emitter gets reflected on a surface that blocked it, the phototransistor can pick up the signal for distance calculation. Also a potentiometer for adjustment is arranged for easy and clear use. It is small, easy to use/assemble, and inexpensive. Useful for robotics, interactive media, industrial assembly line, etc. Model: SOD00380S </p> <p></p>"},{"location":"Products/Sensors/adjustable-infrared-sensor-switch.html#features","title":"Features","text":"<ul> <li>Power supply: 5V</li> <li>Current: 100mA</li> <li>Range: 3-80cm adjustable</li> <li>Red: +5V</li> <li>Yellow: Signal</li> <li>Black: GND</li> <li>Wire length: 20cm</li> </ul>"},{"location":"Products/Sensors/adjustable-infrared-sensor-switch.html#usage","title":"Usage","text":""},{"location":"Products/Sensors/adjustable-infrared-sensor-switch.html#hardware","title":"Hardware","text":"<p>Connect this sensor to your Arduino/Crowduino digital pins( D2 for example). When there is an object behind this sensor, the output would be low. </p>"},{"location":"Products/Sensors/adjustable-infrared-sensor-switch.html#programming","title":"Programming","text":"<p>1.Download the following program to Arduino, Please refer to here</p> <pre><code>void setup()  {\n Serial.begin(9600);\n pinMode(2,INPUT);\n}\nvoid loop()  {\n while(1)  {\n   delay(500);\n   if(digitalRead(2)==LOW)  {\n     Serial.println(\"object detected.\");\n   }\n   else  {\n     Serial.println(\"no object detected.\");\n   }\n }\n}\n</code></pre> <p>2.open the serial monitor , and set the baudrate to 9600, you will see the output changes with the object behind this sensor or not. </p>"},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html","title":"Analog CO/Combustible Gas Sensor(MQ9)","text":""},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html#description","title":"Description","text":"<p>The Analog CO/Combustible Gas Sensor(MQ9) module is useful for gas leakage detecting, it used the sensitive material SnO2, which with lower conductivity in clean air. It make detection by method of cycle high and low temperature, and detect CO when low temperature (heated by 1.5V). The sensors conductivity is more higher along with the gas concentration rising. When high temperature (heated by 5.0V), it detects Methane, Propane etc combustible gas and cleans the other gases adsorbed under low temperature. MQ-9 gas sensor has high sensitity to Carbon Monoxide, Methane and LPG. The sensor could be used to detect different gases contains CO and combustible gases, it is with low cost and suitable for different application. SKU: SEN90512P SES90101S</p> <p></p> <p></p>"},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html#features","title":"Features","text":"<ul> <li>High sensitivity to Methane, Propane and CO</li> <li>Long life and low cost</li> <li>Simple drive circuit</li> </ul>"},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html#application-ideas","title":"Application Ideas","text":"<ul> <li>Domestic gas leakage detector</li> <li>Industrial gas detector</li> <li>Portable gas detector</li> </ul>"},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html#usage","title":"Usage","text":""},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html#hardware-installation","title":"Hardware Installation","text":"Arduino UNO Gas Sensor 5V VCC GND GND Analog A0 A0"},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html#demo-cede","title":"Demo cede","text":"<p>1.Put the sensor in a clear air, copy the demo code to your sketch, then upload to Arduino or Crowduino board.</p> <pre><code>void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air; //  Get the value of RS via in a clear air\n  float R0;  // Get the value of R0 via in LPG\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0\u00a0; x &lt; 100\u00a0; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/9.9; // The ratio of RS/R0 is 9.9 in LPG gas\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n\n}\n</code></pre> <p>2.Open the monitor of Arduino IDE, you can see some data are printed, write down the value of R0 and you need to use it in the following program. During this step, you may pay a while time to test the value of R0.</p> <p></p> <p>3.Put the sensor in one gas where the environment you want to test in. However, don't forget to replace the R0 below with value of R0 tested above</p> <pre><code>void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n\n  Serial.print(\"\\n\\n\");\n\n  delay(1000);\n\n}\n</code></pre> <p>Now, we can get the concentration of gas from the below figure </p> <p></p>"},{"location":"Products/Sensors/analog-cocombustible-gas-sensormq9.html#resources","title":"Resources","text":"<ul> <li>Demo code</li> <li>MQ-9.pdf</li> </ul>"},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html","title":"Analog Smoke/LPG/CO Gas Sensor(MQ2)","text":""},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html#description","title":"Description","text":"<p>The Analog Smoke/LPG/CO Gas Sensor(MQ2) module utilizes an MQ-2 as the sensitive component and has a protection resistor and an adjustable resistor on board. The MQ-2 gas sensor is sensitive to LPG, i-butane, propane, methane, alcohol, Hydrogen and smoke. It could be used in gas leakage detecting equipments in family and industry. The resistance of the sensitive component changes as the concentration of the target gas changes. SKU: SEN90512P SES28011S</p> <p></p>"},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html#features","title":"Features","text":"<ul> <li>Domestic gas leakage detector</li> <li>Industrial gas detector</li> <li>Portable gas detector</li> </ul>"},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html#application-ideas","title":"Application Ideas","text":"<ul> <li>Domestic gas leakage detector</li> <li>Industrial gas detector</li> <li>Portable gas detector</li> </ul>"},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html#usage","title":"Usage","text":""},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html#hardware-installation","title":"Hardware Installation","text":"Arduino UNO Gas Sensor 5V VCC GND GND Analog A0 A0"},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html#demo-cede","title":"Demo cede","text":"<p>1.Put the sensor in a clear air, copy the demo code to your sketch, then upload to Arduino or Crowduino board.</p> <pre><code>void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  float sensor_volt; \n  float RS_air;                 //  Get the value of RS via in a clear air\n  float R0;                     // Get the value of R0 via in H2\n  float sensorValue;\n\n/*--- Get a average data by testing 100 times ---*/   \n    for(int x = 0\u00a0; x &lt; 100\u00a0; x++)\n  {\n    sensorValue = sensorValue + analogRead(A0);\n  }\n  sensorValue = sensorValue/100.0;\n/*-----------------------------------------------*/\n\n  sensor_volt = sensorValue/1024*5.0;\n  RS_air = (5.0-sensor_volt)/sensor_volt; // omit *RL\n  R0 = RS_air/10.0;                       // The ratio of RS/R0 is 10 in a clear air\n\n  Serial.print(\"sensor_volt = \");\n  Serial.print(sensor_volt);\n  Serial.println(\"V\");\n\n  Serial.print(\"R0 = \");\n  Serial.println(R0);\n  delay(1000);\n}\n</code></pre> <p>2.Open the monitor of Arduino IDE, you can see some data are printed, write down the value of R0 and you need to use it in the following program. During this step, you may pay a while time to test the value of R0.</p> <p></p> <p>3.Put the sensor in one gas where the environment you want to test in. However, don't forget to replace the R0 below with value of R0 tested above</p> <pre><code>void setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n\n  float sensor_volt;\n  float RS_gas; // Get value of RS in a GAS\n  float ratio; // Get ratio RS_GAS/RS_air\n  int sensorValue = analogRead(A0);\n  sensor_volt=(float)sensorValue/1024*5.0;\n  RS_gas = (5.0-sensor_volt)/sensor_volt; // omit *RL\n\n  /*-Replace the name \"R0\" with the value of R0 in the demo of First Test -*/\n  ratio = RS_gas/R0;  // ratio = RS/R0 \n  /*-----------------------------------------------------------------------*/\n  Serial.print(\"sensor_volt = \");\n  Serial.println(sensor_volt);\n  Serial.print(\"RS_ratio = \");\n  Serial.println(RS_gas);\n  Serial.print(\"Rs/R0 = \");\n  Serial.println(ratio);\n  Serial.print(\"\\n\\n\");\n  delay(1000);\n}\n</code></pre> <p>Now, we can get the concentration of gas from the below figure </p> <p></p>"},{"location":"Products/Sensors/analog-smokelpgco-gas-sensormq2.html#resources","title":"Resources","text":"<ul> <li>Demo code</li> <li>MQ-2.pdf</li> </ul>"},{"location":"Products/Sensors/apm25-airspeed-breakout-board-mpxv7002dp.html","title":"APM2.5 Airspeed Breakout Board MPXV7002DP","text":""},{"location":"Products/Sensors/apm25-airspeed-breakout-board-mpxv7002dp.html#description","title":"Description","text":"<p>The MPXV7002 series piezoresistive transducer in the small outline package (SOP) is a state-of-the-art monolithic silicon pressure sensor designed for a wide range of applications, but particularly those employing a microcontroller or microprocessor with A/D inputs. This patented, single element transducer combines advanced micromachining techniques, thin-film metallization, and bipolar processing to provide an accurate, high level analog output signal that is proportional to the applied pressure. The MPXV7002 is designed to measure positive and negative pressure. In addition, with an offset specifically at 2.5V instead of the conventional 0V, this new series allows to measure pressure up to 7kPa through each port for pressure sensing but also for vacuum sensing (refer to the transfer function in the data sheet for more detailed information). Model:SLF0025APM</p> <p></p>"},{"location":"Products/Sensors/apm25-airspeed-breakout-board-mpxv7002dp.html#features","title":"Features","text":"<ul> <li>-2 to 2 kPa (-0.3 to 0.3 psi)</li> <li>0.5 to 4.5 V Output</li> <li>Size:22x18x11mm</li> </ul>"},{"location":"Products/Sensors/apm25-airspeed-breakout-board-mpxv7002dp.html#usage","title":"Usage","text":"<p>1.Hardware Installation</p> <p></p> <p>2.copy the demo code to your sketch, then upload to Arduino or Crowduino board.</p> <pre><code>int sensorPin = A0;   \nint sensorValue = 0; \nfloat Vout=0;\nfloat P=0;\nvoid setup() {\n\n  // declare the ledPin as an OUTPUT:\n   Serial.begin(9600); \n}\n\nvoid loop() {\n    int i=0;\n    int sum=0;\n    int offset=0;\n    Serial.println(\"init...\");\n    for(i=0;i&lt;10;i++)\n    {\n         sensorValue = analogRead(sensorPin)-512;\n         sum+=sensorValue;\n    }\n    offset=sum/10.0;\n    Serial.println(\"Ok\");\n    while(1)\n    {\n       sensorValue = analogRead(sensorPin)-offset; \n       Vout=(5*sensorValue)/1024.0;\n       P=Vout-2.5;           \n       Serial.print(\"Presure = \" );                       \n       Serial.print(P*1000); \n       Serial.println(\"Pa\");\n       delay(1000);   \n    }\n}\n</code></pre> <p>3.Open the monitor of Arduino IDE,then blow the air to the MPXV7002DP, you can see the test result like flow.</p> <p></p>"},{"location":"Products/Sensors/apm25-airspeed-breakout-board-mpxv7002dp.html#resources","title":"Resources","text":"<ul> <li>Datasheet</li> </ul>"},{"location":"Products/Sensors/barometer-sensor.html","title":"Barometer Sensor","text":""},{"location":"Products/Sensors/barometer-sensor.html#description","title":"Description","text":"<p>This Barometer Sensor has a Bosch BMP085 which is a high-accuracy chip to detect barometric pressure and temperature. It can widely measure pressure ranging from 300hPa to 1100hPa, AKA +9000m to -500m above sea level, with a super high accuracy of 0.03hPa(0.25m) in ultra-high resolution mode. This Barometer sensor compatible with 3.3V and 5V, so it can be used in Arduinos without moditdfication.</p> <p>Model:STH01002S</p> <p></p>"},{"location":"Products/Sensors/barometer-sensor.html#features","title":"Features","text":"<ul> <li>Wide pressure range</li> <li>Arduino/Crowduino compatible interface (3.3V or 5V)</li> <li>I2C interface</li> <li>Fully calibrated</li> <li>Low power consumption: 5\u03bcA at 1 sample/sec. in standard mode</li> <li>Low noise:</li> </ul> <pre><code>   0.06hPa(0.5m) in ultra-low power mode\n   0.03hPa(0.25m) in ultra-high resolution mode\n</code></pre> <ul> <li>Possibility to lower to 0.1m(rms noise)</li> </ul>"},{"location":"Products/Sensors/barometer-sensor.html#usage","title":"Usage","text":"<p>Barometric condition is one of the criteria used to predict coming change in weather and deduce altitude above sea level. Here is a demo to show you how to read the barometric data from this Barometer Sensor.</p> <p>1.Hardware connection</p> <p></p> <p>2.Download the library 3.Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0.1\\libraries. 4.Create a new Arduino sketch and paste the codes below to it or open the code directly by the path:File -&gt; Examples -&gt;Barometer-&gt;Barometer_Sensor.</p> <pre><code>/* Barometer demo V1.0\n* Get pressure, altitude, and temperature from the BMP085.\n* Serial.print it out at 9600 baud to serial monitor.\n*\n*/\n#include \"Barometer.h\"\n#include &lt;Wire.h&gt;\nfloat temperature;\nfloat pressure;\nfloat atm;\nfloat altitude;\nBarometer myBarometer;\nvoid setup(){\n  Serial.begin(9600);\n  myBarometer.init();\n\n}\n\nvoid loop()\n{\n   temperature = myBarometer.bmp085GetTemperature(myBarometer.bmp085ReadUT()); //Get the temperature, bmp085ReadUT MUST be called first\n   pressure = myBarometer.bmp085GetPressure(myBarometer.bmp085ReadUP());//Get the temperature\n   altitude = myBarometer.calcAltitude(pressure); //Uncompensated caculation - in Meters \n   atm = pressure / 101325; \n\n  Serial.print(\"Temperature: \");\n  Serial.print(temperature, 2); //display 2 decimal places\n  Serial.println(\"deg C\");\n\n  Serial.print(\"Pressure: \");\n  Serial.print(pressure, 0); //whole number only.\n  Serial.println(\" Pa\");\n\n  Serial.print(\"Ralated Atmosphere: \");\n  Serial.println(atm, 4); //display 4 decimal places\n\n  Serial.print(\"Altitude: \");\n  Serial.print(altitude, 2); //display 2 decimal places\n  Serial.println(\" m\");\n\n  Serial.println();\n\n  delay(1000); //wait a second and get values again.\n}\n</code></pre> <p>5.Open the serial monitor.You should see the data from BMP085.</p> <p></p>"},{"location":"Products/Sensors/barometer-sensor.html#resource","title":"Resource","text":"<ul> <li>Barometer Program</li> </ul>"},{"location":"Products/Sensors/serial-jpg-camera.html","title":"Serial JPG Camera","text":""},{"location":"Products/Sensors/serial-jpg-camera.html#introduction","title":"Introduction","text":"<p>This Serial Camera is a JPEG color camera module easy for PC&amp; MCU use.It has integrated image processing DSP to generate 320*240 or 640*480 JPEG image without thumbnail information, captured picture will be stored in internal buffer and transferred via UART port. Model: SOD03010S</p> <p> </p>"},{"location":"Products/Sensors/serial-jpg-camera.html#features","title":"Features","text":"<ul> <li>Default baud rate of serial port is 38400</li> <li>640x480/320x240(default) resolution</li> <li>JPEG compressed image without Thumbnail Information</li> <li>5v power supply</li> <li>Controlled by UART protocol</li> </ul>"},{"location":"Products/Sensors/serial-jpg-camera.html#application","title":"Application","text":"<ul> <li>Digital Camara with Wireless SD Card Shield</li> <li>Vidio Monitoring</li> </ul>"},{"location":"Products/Sensors/serial-jpg-camera.html#interface","title":"Interface","text":"<p>The Serial JPG Camera module use RS232 to communicate with PC or Microcontrollers. </p>"},{"location":"Products/Sensors/serial-jpg-camera.html#usage","title":"Usage","text":""},{"location":"Products/Sensors/serial-jpg-camera.html#use-the-serial-jpg-camera-with-pc","title":"Use the Serial JPG Camera with PC","text":"<p>Step 1:Download dedicated serial port debugging tool File:Serial Camera software.zip and install it. Step 2: Connect Serial camera to PC UART Port with a USB2UART module such as the USB convertor. Step 3: Open the tool on PC.Choose the correct COM number of the port you link to the camera ,default bautrate 38400,and then open the port.   { loading=lazy }</p> <p>Step 4: Click the button \"Reset\" to reset the camera.</p> <p>Step 5::Click \"\u5355\u5f20\u62cd\u6444\"(Single capture mode) to take a picture. Of course you can modify the image to 640x480 mode, note that you should click the resume button after you modidy the setting.</p>"},{"location":"Products/Sensors/serial-jpg-camera.html#use-camera-with-arduino-and-wirelss-sd-card-shield","title":"Use Camera with Arduino and wirelss SD card shield","text":"<p>Here we use the Serial JPG Camera to make a Arduino Camera.  First, you need to install a SD card shield to Arduino, to store the pictures with SD card, and a proto shield onto the SD shield, install a button on the protoshield so that when the button pressed, the voltage on A5 would be HIGH and LOW when not pressed.  And then connect the Serial Camera to Arduino: Camera &lt;------------&gt; Arduino TX &lt;-----------&gt; Pin0 RX &lt;------------&gt;Pin1 Vcc &lt;------------&gt;5V GND &lt;------------&gt; GND  </p> <p>2. And then upload the demo code to your Arduino board, note that you may need to take away the RX/TX of camera from Arduino when uploading the code:</p> <p></p> <p>3. Press the button , the Camera will take a picture and store the picture into the SD card. you can adjust the camera lens to change the focal distance, to make the picture more clear.</p> <p></p>"},{"location":"Products/Sensors/serial-jpg-camera.html#resource","title":"Resource","text":"<p>File:SerialCameral DemoCode.zip Note that it may not work ok in Arduino1.01 sometimes, please download Arduino IDE beyond V1.0.2.</p>"},{"location":"Products/Shield/282727-tft-touch-shield.html","title":"2.8'' TFT Touch Shield","text":""},{"location":"Products/Shield/282727-tft-touch-shield.html#introduction","title":"Introduction","text":"<p>This TFT Touch Shield is Arduino/Crowduino/Arduino Mega compatible, it integrated a 2.8\u201d TFT Display and a resistive touch panel, to make this shield suitable for handheld devices. This TFT Touch Shield has 240x320 pixels with individual pixel control, it uses the ILI9341 driver and SPI interface to communicate with controllers such as Arduino, saving you much Arduino pins for other usages in your projects. Besides, A SD card socket is also added to help you develop applications that data storage is needed such as digital picture album.  </p> <p>Model: AMS320240TFT </p> <p></p>"},{"location":"Products/Shield/282727-tft-touch-shield.html#features","title":"Features","text":"<ul> <li>LCD Driver: ILI9341</li> <li>Backlight controllable</li> <li>65535 rich colors</li> <li>SPI Communication</li> <li>Voltage:4.8~5.5 V</li> <li>Max Current: 200 mA</li> <li>Resolution:320x 240</li> <li>LCD Panel Size: 2.8\u201d</li> <li>Touch Mode: Resistance</li> <li>Dimensions(mm):72.0(L)x14.5(W)x55.0(H)</li> </ul>"},{"location":"Products/Shield/282727-tft-touch-shield.html#cautions","title":"Cautions","text":"<ul> <li>Please Be careful to deposit the fragile scree,pressing too hard on the screen might cause display damage.</li> </ul>"},{"location":"Products/Shield/282727-tft-touch-shield.html#pins-usage-on-arduino","title":"Pins usage on Arduino","text":"Function Pin Name Arduino pin Description TFT Screen Control TF_CS D4 SD card select input TFT_CS D5 TFT chip select input TFT_D/C D6 TFT Data/Command control BACKLIGHT D7 TFT backlight control pin TFT SPI Interface SPI_MOSI D11 SPI data pin MOSI SPI_MISO D12 SPI data pin MISO SPI_SCK D13 SPI Clock Pin SCK Touch Interface ADC0 A0 Touch Screen Y- input ADC1 A1 Touch Screen X- input ADC2 A2 Touch Screen Y+ input ADC3 A3 Touch Screen X+ input"},{"location":"Products/Shield/282727-tft-touch-shield.html#usage","title":"Usage","text":""},{"location":"Products/Shield/282727-tft-touch-shield.html#hardware-connection","title":"Hardware connection","text":"<p>Plug 2.8 TFT Touch Shileld into Arduino or Crowduino.  Connect Arduino to PC via a USB cable. </p>"},{"location":"Products/Shield/282727-tft-touch-shield.html#program","title":"Program","text":"<p>1.Please download 2.8'TFT Program Files.zip</p> <p>2.Install the library to the Arduino IDE library to ...\\Arduino\\libraries, but please note that if you downloaded the library in .zip file, you should delete the \"-master\" in the library name when you unzip it, as the \"-\" can not be recognized in the Arduino Library.</p>"},{"location":"Products/Shield/282727-tft-touch-shield.html#draw-circle","title":"Draw Circle","text":"<p>1.Open the code directly by the path:File -&gt; Examples -&gt;TFT_Touch_Shield_v2-&gt;drawCircle.</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;TFTv2.h&gt;\n#include &lt;SPI.h&gt;\n\nvoid setup()\n{\n    TFT_BL_ON;                                          //turn on the background light \n\n    Tft.TFTinit();                                      //init TFT library             \n\n    Tft.drawCircle(100, 100, 30,YELLOW);                //center: (100, 100), r = 30 ,color\u00a0: YELLOW              \n\n    Tft.drawCircle(100, 200, 40,CYAN);                  //center: (100, 200), r = 10 ,color\u00a0: CYAN  \n\n    Tft.fillCircle(200, 100, 30,RED);                   //center: (200, 100), r = 30 ,color\u00a0: RED    \n\n    Tft.fillCircle(200, 200, 30,BLUE);                  //center: (200, 200), r = 30 ,color\u00a0: BLUE                 \n}\n\nvoid loop()\n{\n\n}\n</code></pre> <p>2.Upload the code,you will see that. </p>"},{"location":"Products/Shield/282727-tft-touch-shield.html#touch-screen","title":"Touch Screen","text":"<p>1.Open the code directly by the path:File -&gt; Examples -&gt;Touch_Screen_Driver-&gt;touchScreen.</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;SeeedTouchScreen.h&gt; \n\n#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) // mega\n#define YP A2   // must be an analog pin, use \"An\" notation!\n#define XM A1   // must be an analog pin, use \"An\" notation!\n#define YM 54   // can be a digital pin, this is A0\n#define XP 57   // can be a digital pin, this is A3 \n\n#elif defined(__AVR_ATmega32U4__) // leonardo\n#define YP A2   // must be an analog pin, use \"An\" notation!\n#define XM A1   // must be an analog pin, use \"An\" notation!\n#define YM 18   // can be a digital pin, this is A0\n#define XP 21   // can be a digital pin, this is A3 \n\n#else //168, 328, something else\n#define YP A2   // must be an analog pin, use \"An\" notation!\n#define XM A1   // must be an analog pin, use \"An\" notation!\n#define YM 14   // can be a digital pin, this is A0\n#define XP 17   // can be a digital pin, this is A3 \n\n#endif\n\n//Measured ADC values for (0,0) and (210-1,320-1)\n//TS_MINX corresponds to ADC value when X = 0\n//TS_MINY corresponds to ADC value when Y = 0\n//TS_MAXX corresponds to ADC value when X = 240 -1\n//TS_MAXY corresponds to ADC value when Y = 320 -1\n\n#define TS_MINX 116*2\n#define TS_MAXX 890*2\n#define TS_MINY 83*2\n#define TS_MAXY 913*2\n\n\n// For better pressure precision, we need to know the resistance\n// between X+ and X- Use any multimeter to read it\n// The 2.8\" TFT Touch shield has 300 ohms across the X plate\nTouchScreen ts = TouchScreen(XP, YP, XM, YM);\n\nvoid setup(void) {\n  Serial.begin(9600);\n}\n\nvoid loop(void) {\n  // a point object holds x y and z coordinates\n  Point p = ts.getPoint();\n\n  if (p.z &gt; __PRESURE) {\n     Serial.print(\"Raw X = \"); Serial.print(p.x);\n     Serial.print(\"\\tRaw Y = \"); Serial.print(p.y);\n     Serial.print(\"\\tPressure = \"); Serial.println(p.z);\n  }\n\n\n  p.x = map(p.x, TS_MINX, TS_MAXX, 0, 240);\n  p.y = map(p.y, TS_MINY, TS_MAXY, 0, 320);\n\n  // we have some minimum pressure we consider 'valid'\n  // pressure of 0 means no pressing!\n  if (p.z &gt; __PRESURE) {\n     Serial.print(\"X = \"); Serial.print(p.x);\n     Serial.print(\"\\tY = \"); Serial.print(p.y);\n     Serial.print(\"\\tPressure = \"); Serial.println(p.z);\n  }\n\n  delay(100);\n}\n</code></pre> <p>2.Upload the code,then open the serial monitor and touch the screen,you will see some information. </p>"},{"location":"Products/Shield/282727-tft-touch-shield.html#resources","title":"Resources","text":"<p>This TFT Shield uses the ILI9341 Driver IC, thanks to the Seeed TFT library, It works OK on this TFT Touch Shiled:</p> <ul> <li>2.8'TFT Program Files.zip</li> <li>SeeedTFTV2.0 Library for Arduino 1.0</li> <li>SeeedTouchScreen Library for Arduino 1.0</li> </ul>"},{"location":"Products/Shield/4-channel-i2c-motor-shield-v11.html","title":"4 Channel I2C Motor Shield v1.1","text":""},{"location":"Products/Shield/4-channel-i2c-motor-shield-v11.html#introduction","title":"Introduction","text":"<p>For Arduino beginners, there will always be problems when driving DC motors and servos. If you want to drive 4 motors and 2 servos, you need to build a platform to control their speed and direction of rotation. When the motor and steering gear are running, the current is large, and you will need a module to help you control the large current, such as a micro controller like Arduino. Therefore, Elecrow has designed the driver board you need in this type of application. This module will help users solve the problem of high-current drive and control of the motor. You only need to plug it into the Arduino or Crowduino. This module is connected to the Arduino or Crowduino through the I2C bus. Start your application and you can control 4 channels through the I2C bus. Motor. This driver board is designed based on the MOSFET H-bridge integrated circuit TB6612FNG, and its efficiency is higher than that of the transistor H-bridge driver. Compared with the L293D's average drive current of 600 mA per channel and 1.2 A pulse peak current, its output load capacity has doubled. Compared with the L298N's heat dissipation and peripheral diode freewheeling circuit, it does not require an external heat sink, and the peripheral circuit is simple. Only an external power supply filter capacitor can directly drive the motor, which is beneficial to reduce the system size. For the PWM signal, it supports frequencies up to 100 kHz, which also has greater advantages over the 5 kHz and 40 kHz of the above two chips.  </p> Motor Drive Control: <p>a. PCA9685 outputs PWM signals to control two TB6612FNG motor drive circuits, and then control 4 channels motors respectively;  </p> <p>b. Motor control mode: forward/reverse/brake/stop.</p> Servo Control: <p>The servo plug is inserted into the socket on the 4 Channel I2C Motor Shield board, and the Arduino or Crowduino controls the servo to work through D8 and D9. </p> <p>Model: ARS27361T</p> <p></p>"},{"location":"Products/Shield/4-channel-i2c-motor-shield-v11.html#features","title":"Features","text":"<ul> <li>Logic control voltage: 2.7~5.5V</li> <li>Motor power supply voltage: 6~15V</li> <li>Single channel continuous drive output current: 1.2 A</li> <li>Starting peak drive current: 2A/3.2 A (continuous pulse/single pulse)</li> <li>Driving current Io: 2A</li> <li>Maximum power consumption: 18W</li> <li>Working temperature: -20 degrees Celsius to +85 degrees Celsius</li> <li>Drive type: dual high-power H-bridge drive</li> </ul>"},{"location":"Products/Shield/4-channel-i2c-motor-shield-v11.html#specification","title":"Specification","text":""},{"location":"Products/Shield/4-channel-i2c-motor-shield-v11.html#interface-description","title":"Interface Description","text":"<p> Motor power supply voltage: ------&gt; External power supply, which may be 6~13.5V depending on the motor you use. Power indicator: ------&gt; LED indicator of external power supply. Motor driver: ------&gt; TB6612FNG high-power H-bridge driver. Drive ports: ------&gt; 4 motor ports and 2 servo ports.  </p>"},{"location":"Products/Shield/4-channel-i2c-motor-shield-v11.html#usage","title":"Usage","text":"<p>Copy the library file \"Adafruit_MotorShield\" in the \"4 Channel I2C Motor Shield-V1.1-Example\" folder to the library directory under the Arduino IDE installation directory. For example, our directory is: C:\\Program Files (x86) \\Arduino\\libraries, as shown in the figure:</p> <p></p> <ol> <li> <p>Motor control</p> <ol> <li> <p>Insert the 4 Channel I2C Motor Shield-V1.1 board into the Arduino motherboard (Crowduino UNO motherboard), connect the DC interface of the Arduino motherboard to a 12V power supply, and connect the Mini USB data cable to the USB port of the Arduino motherboard, and then connect it On the computer, as shown in the figure: </p> </li> <li> <p>Open the 4 Channel I2C Motor Shield-V1.1-Example\\DCMotorTest\\DCMotorTest.ino program and download it to the Arduino.</p> </li> <li> <p>Then connect the micro motor to the M1, M2, M3, and M4 terminals on the 4 Channel I2C Motor Shield-V1.1 board (note: each operation must be powered off before connecting the motor), as shown in the figure, After connecting the motor, turn on the electricity and observe the phenomenon.   </p> </li> <li> <p>Observe that each interface motor accelerates forward for a few seconds and accelerates reverse for a few seconds, then the DC motor drives normally.</p> <pre><code>#include &lt;Wire.h&gt;\n#include &lt;Adafruit_MotorShield.h&gt;\n#include \"utility/Adafruit_MS_PWMServoDriver.h\"\n\n// Create the motor shield object with the default I2C address\nAdafruit_MotorShield AFMS = Adafruit_MotorShield(0x60); \n// Or, create it with a different I2C address (say for stacking)\n// Adafruit_MotorShield AFMS = Adafruit_MotorShield(0x61); \n\n// Select which 'port' M1, M2, M3 or M4. In this case, M1\nAdafruit_DCMotor *myMotor = AFMS.getMotor(1);\nAdafruit_DCMotor *myMotor2 = AFMS.getMotor(2);\nAdafruit_DCMotor *myMotor3 = AFMS.getMotor(3);\nAdafruit_DCMotor *myMotor4 = AFMS.getMotor(4);\n\n// You can also make another motor on port M2\n//Adafruit_DCMotor *myOtherMotor = AFMS.getMotor(2);\n\nvoid setup() {\n  Serial.begin(9600);           // set up Serial library at 9600 bps\n  Serial.println(\"Adafruit Motorshield v2 - DC Motor test!\");\n\n  AFMS.begin();  // create with the default frequency 1.6KHz\n  //AFMS.begin(1000);  // OR with a different frequency, say 1KHz\n\n  // Set the speed to start, from 0 (off) to 255 (max speed)\n  myMotor-&gt;setSpeed(150);\n  myMotor-&gt;run(FORWARD);\n  // turn on motor\n  myMotor-&gt;run(RELEASE);\n\n  myMotor2-&gt;setSpeed(150);\n  myMotor2-&gt;run(FORWARD);\n  // turn on motor2\n  myMotor2-&gt;run(RELEASE);\n\n  myMotor3-&gt;setSpeed(150);\n  myMotor3-&gt;run(FORWARD);\n  // turn on motor3\n  myMotor3-&gt;run(RELEASE);\n\n  myMotor4-&gt;setSpeed(150);\n  myMotor4-&gt;run(FORWARD);\n  // turn on motor4\n  myMotor4-&gt;run(RELEASE);\n}\n\nvoid loop() {\n  uint8_t i;\n\n  Serial.print(\"tick\");\n\n  myMotor-&gt;run(FORWARD);\n  myMotor2-&gt;run(FORWARD);\n    myMotor3-&gt;run(FORWARD);\n    myMotor4-&gt;run(FORWARD);\n  for (i=0; i&lt;255; i++) {\n    myMotor-&gt;setSpeed(i);  \n    myMotor2-&gt;setSpeed(i);  \n    myMotor3-&gt;setSpeed(i);  \n    myMotor4-&gt;setSpeed(i);  \n    delay(10);\n  }\n  for (i=255; i!=0; i--) {\n    myMotor-&gt;setSpeed(i);  \n    myMotor2-&gt;setSpeed(i);  \n    myMotor3-&gt;setSpeed(i);  \n    myMotor4-&gt;setSpeed(i);  \n    delay(10);\n  }\n\n  Serial.print(\"tock\");\n\n  myMotor-&gt;run(BACKWARD);\n  myMotor2-&gt;run(BACKWARD);\n  myMotor3-&gt;run(BACKWARD);\n  myMotor4-&gt;run(BACKWARD);\n  for (i=0; i&lt;255; i++) {\n    myMotor-&gt;setSpeed(i); \n    myMotor2-&gt;setSpeed(i);  \n    myMotor3-&gt;setSpeed(i);  \n    myMotor4-&gt;setSpeed(i);   \n    delay(10);\n  }\n  for (i=255; i!=0; i--) {\n    myMotor-&gt;setSpeed(i);  \n    myMotor2-&gt;setSpeed(i);  \n    myMotor3-&gt;setSpeed(i);  \n    myMotor4-&gt;setSpeed(i);  \n    delay(10);\n  }\n\n  Serial.print(\"tech\");\n  myMotor-&gt;run(RELEASE);\n  myMotor2-&gt;run(RELEASE);\n  myMotor3-&gt;run(RELEASE);\n  myMotor4-&gt;run(RELEASE);\n  delay(1000);\n}\n</code></pre> </li> </ol> </li> <li> <p>Stepper control</p> <ol> <li> <p>Open the 4 Channel I2C Motor Shield-V1.1-Sample\\servo\\servo.ino program and download it to the Arduino.</p> </li> <li> <p>Connect the 9G servo to the J3 and J4 ports on the 4 Channel I2C Motor Shield-V1.1 board respectively, and observe the phenomenon, as shown in the figure: </p> </li> <li> <p>Both interfaces observe the stepping motor's forward and reverse rotation, then the drive is normal.</p> <pre><code>#include &lt;Servo.h&gt;  \nServo myservo;  // create servo object to control a servo \n              // a maximum of eight servo objects can be created \nServo myservo1;               \n\nint pos = 0;    // variable to store the servo position \n\nvoid setup() \n{ \n  myservo.attach(9);  // attaches the servo on pin 9 to the servo object \n  myservo1.attach(8);\n} \n\nvoid loop() \n{ \n  for(pos = 0; pos &lt; 180; pos += 1)   // goes from 0 degrees to 180 degrees \n  {                             // in steps of 1 degree \n    myservo.write(pos);            // tell servo to go to position in variable 'pos' \n    myservo1.write(pos);  \n    delay(15);                    // waits 15ms for the servo to reach the position \n  } \n  for(pos = 180; pos&gt;=1; pos-=1)     // goes from 180 degrees to 0 degrees \n  {                                \n    myservo.write(pos);            // tell servo to go to position in variable 'pos' \n    myservo1.write(pos); \n    delay(15);                    // waits 15ms for the servo to reach the position \n  } \n}\n</code></pre> </li> </ol> </li> </ol>"},{"location":"Products/Shield/4-channel-i2c-motor-shield-v11.html#resource","title":"Resource","text":"<ul> <li>4_Channel_I2C_Motor_Shield-V1.1-Example.zip </li> <li>4_Channel_I2C_Motor_Shield-V1.1-SCH&amp;PCB.zip </li> </ul>"},{"location":"Products/Shield/8-channel-el-shield.html","title":"8-Channel EL Shield","text":""},{"location":"Products/Shield/8-channel-el-shield.html#description","title":"Description","text":"<p>EL wire is flexible plastic cord that glows brightly when high-voltage AC is applied to it. It\u2019s available in numerous colors with cool, and requires very little current, but it can be difficult to work with because of the high-voltage requirements. The Elecrow EL Shield enables you to implement up to 8 channels of EL wires or tapes in to your project and gives you solution to control the EL modules. With Arduino or Crowduino, You will be able to control 8 EL devices simultaneously and separately. The controlling method is as simple as controlling an LED. Driven by PWM, it can create a colorful and florid effect by controlling each EL wire according to your own programs. </p> <p>This Shield comes with 4 pics of EL wire adaptors to help you connect the standard EL wires to this Shield. Of course you can purchase more to control up to 8 channels. Please also notice that a 5V invertor is needed for this EL shield.Besides, there is also the 8-Channel EL Shield Kit which includes all the modules you need for a EL wire project.</p> <p>Model: AS0008EL</p> <p> </p>"},{"location":"Products/Shield/8-channel-el-shield.html#featrues","title":"Featrues","text":"<ul> <li>8 Channels, with Eight opto-isolated, zero-crossing control channels;</li> <li>Control EL as easy as turning a LED on and off;</li> <li>Compatible with 5V or 3.3V Arduinos</li> <li>Dimensions(mm):72.5(L)x66.0(W)x23.5(H)</li> </ul>"},{"location":"Products/Shield/8-channel-el-shield.html#pin-allocatior","title":"Pin Allocatior","text":"PIN EL Channel to Control D2 EL Channel A D3 EL Channel B D4 EL Channel C D5 EL Channel D D6 EL Channel E D7 EL Channel F D8 EL Channel G D9 EL Channel H"},{"location":"Products/Shield/8-channel-el-shield.html#usage","title":"Usage","text":""},{"location":"Products/Shield/8-channel-el-shield.html#1connect-the-el-wires-to-el-shield-via-the-adaptor","title":"1.Connect the EL wires to EL Shield via the Adaptor","text":"<p>As the standard EL wires or tapes use the connectors that can not be pluged into a PCBA, we provide the Special wire adaptors to help uses connect the EL modules to the EL Shiled. 4 pcs of adaptors are packaged in the EL Shield or EL Shield Kit. connect the EL wires to EL Shiled as below: </p>"},{"location":"Products/Shield/8-channel-el-shield.html#2connect-the-inverter-to-el-shield","title":"2.Connect the inverter to EL Shield","text":"<p>The EL modules needs a driver voltage more than 110V, AC. The Elecrow customized inverter can convert the 5V-DC input to AC,110~220V, can drive a max of 15m EL wires. connecthe the inverter to EL Shield as below:  Note that the input wire of the inverter is red/white, which need to be inserted into the DC_5V terminal of EL Shield, and the output wire(black) of the inverter need to be inserted into the AC&gt;110V terminal.</p>"},{"location":"Products/Shield/8-channel-el-shield.html#3programing-on-crowduino","title":"3.Programing on Crowduino","text":"<p>Plug the EL Shield on to Crowduino, then you can begin to programming the Crowduino to control EL wires. Progrmming to control the EL wires would be as easy as control a LED, you can use the digitalwrite() to control the EL wires on&amp;off, or the analogwrite() to generate PWM to control the lightness.</p> <pre><code>void setup(){\n for(int i = 2; i&lt;10; i++)\n { \n  pinMode(i, OUTPUT);\n }\n}\n\nvoid setEL(int ch) // set a certain EL on\n{ \n  for(int i = 2; i&lt;10; i++) // all on\n digitalWrite(i, HIGH);\n delay(1000);\n for(int i = 2; i&lt;10; i++) // all off\n digitalWrite(i, LOW);\n  for(int i = 2; i&lt;10; i++) // \n {\n  digitalWrite(i, HIGH);\n  delay(200);\n  digitalWrite(i, LOW);\n }\n } \n\nint count = 0; \n\nvoid loop()\n{ \n setEL(count%4 + 1);\n delay(200);\n if(count++ == 1000)\n { \n  count = 0;\n } \n}\n</code></pre>"},{"location":"Products/Shield/8-channel-el-shield.html#4power-on-to-start","title":"4.Power On to Start","text":"<p>After uploading the sketch to Crowduino, Power the Crowduino&amp;Arduino with a 6.5~9 V DC supply via the DC jack, to enable the EL wires blink </p>"},{"location":"Products/Shield/8-channel-el-shield.html#resource","title":"Resource","text":"<ul> <li>MOC3063 Datasheet</li> <li>Z0103MN Datasheet</li> <li>LM317 Datasheet </li> </ul>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html","title":"Arduino Motor/Stepper/Servo Shield","text":""},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#description","title":"Description","text":"<p>This Adruino compatible motor Driver shield is a full-featured products that it can be used to drive 2 DC motor or two 4-wire stepper and two 5v \u2019hoppy\u2019 servo. It drive the DC motor and stepper with the L293D,and it drive the servo with arduino\u2019s pin9 and pin10.  </p> <p>Model: MCS02930M </p> <p></p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#features","title":"Features","text":"<ul> <li>Be able to drive 4 DC motor and 2 \u2018hoppy\u2019 Servo</li> <li>Be able to drive 2 stepper and 2 \u2018hoppy\u2019 Servo</li> <li>The logic control voltage Vss: 4.5~5.5V</li> <li>Motor Supply Voltage: Vss ~ 15V</li> <li>Reduced control pins needed through 8-stage serial shift registers</li> <li>Drive part of the operating current Io: 1.2A</li> </ul>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#specification","title":"Specification","text":"Items Min Typical Max Unit Control voltage 4.5 5 5.5 v Driver voltage 6 9 15 v Output Current / / 1.2 A Dimension cm Weight g"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#interface","title":"Interface","text":""},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#usage","title":"Usage","text":""},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#first-install-the-arduino-library","title":"First Install the Arduino Library","text":"<p>Before you can use the Motor shield, you must install the AF_Motor Arduino library - this will instruct the Arduino how to talk to the Adafruit Motor shield, and it isn't optional!</p> <p>1.First, download library</p> <p>2.Uncompress the ZIP file onto your desktop</p> <p>3.Rename the uncompressed folder AFMotor</p> <p>4.Check that inside AFMotor is AFMotor.cpp and AFMotor.h files. If not, check the steps above</p> <p>5.Place the AFMotor folder into your arduinosketchfolder/libraries folder. For Windows, this will probably be something like MY Documents/Arduino/libraries for Mac it will be something like Documents/arduino/libraries. If this is the first time you are installing a library, you'll need to create the libraries folder. Make sure to call it libraries exactly, no caps, no other name.</p> <p>6.Check that inside the libraries folder there is the AFMotor folder, and inside AFMotor is AFMotor.cpp AFMotor.h and some other files</p> <p>7.Quit and restart the IDE. You should now have a submenu called File-&gt;Examples-&gt;AFMotor-&gt;MotorParty</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#powering-your-dc-motors-voltage-and-current-requirements","title":"Powering your DC motors, voltage and current requirements","text":"<p>Motors need a lot of energy, especially cheap motors since they're less efficient. The first important thing to figure out what voltage the motor is going to use. If you're lucky your motor came with some sort of specifications. Some small hobby motors are only intended to run at 1.5V, but its just as common to have 6-12V motors. The motor controllers on this shield are designed to run from 4.5V to 25V.</p> <p>MOST 1.5-3V MOTORS WILL NOT WORK</p> <p>Current requirements: The second thing to figure out is how much current your motor will need. The motor driver chips that come with the kit are designed to provide up to 600 mA per motor, with 1.2A peak current. Note that once you head towards 1A you'll probably want to put a heatsink on the motor driver, otherwise you will get thermal failure, possibly burning out the chip.</p> <p>On using the SN754410: Some people use the SN754410 motor driver chip because it is pin-compatible, has output diodes and can provide 1A per motor, 2A peak. After careful reading of the datasheet and discussion with TI tech support and power engineers it appears that the output diodes were designed for ESD protection only and that using them as kickback-protection is a hack and not guaranteed for performance. For that reason the kit does not come with the SN754410 and instead uses the L293D with integrated kickback-protection diodes. If you're willing to risk it, and need the extra currrent, feel free to buy SN754410's and replace the provided chips.</p> <p>Need more power? Buy another set of L293D drivers and solder them right on top of the ones on the board (piggyback). Voila, double the current capability! You can solder 2 more chips on top before it probably isnt going to get you much benefit</p> <p>You can't run motors off of a 9V battery so don't even waste your time/batteries! Use a big Lead Acid or NiMH battery pack. Its also very much suggested that you set up two power supplies (split supply) one for the Arduino and one for the motors. 99% of 'weird motor problems' are due to noise on the power line from sharing power supplies and/or not having a powerful enough supply!</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#how-to-set-up-the-arduino-shield-for-powering-motors","title":"How to set up the Arduino + Shield for powering motors","text":"<p>Servos are powered off of the same regulated 5V that the Arduino uses. This is OK for the small hobby servos suggested. If you want something beefier, cut the trace going to + on the servo connectors and wire up your own 5-6V supply!</p> <p>The DC motors are powered off of a 'high voltage supply' and NOT the regulated 5V. Don't connect the motor power supply to the 5V line. This is a very very very bad idea unless you are sure you know what you're doing!</p> <p>There are two places you can get your motor 'high voltage supply' from. One is the DC jack on the Arduino board and the other is the 2-terminal block on the shield that is labeled EXT_PWR. The DC Jack on the Arduino has a protection diode so you won't be able to mess things up too bad if you plug in the wrong kind of power. However the EXT_PWR terminals on the shield do not have a protection diode (for a fairly good reason). Be utterly careful not to plug it in backwards or you will destroy the motor shield and/or your Arduino!</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#hardware-installation","title":"Hardware Installation","text":""},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#servos","title":"Servos","text":"<p>Hobby servos are the easiest way to get going with motor control. They have a 3-pin 0.1\" female header connection with +5V, ground and signal inputs. The motor shield simply brings out the 16bit PWM output lines to 2 3-pin headers so that its easy to plug in and go. They can take a lot of power so a 9V battery wont last more than a few minutes!</p> <p>The nice thing about using the onboard PWM is that its very precise and goes about its business in the background. You can use the built in Servo library</p> <p>Using the servos is easy, please read the official Arduino documentation for how to use them and see the example Servo sketches in the IDE</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#dc-motors","title":"DC Motors","text":"<p>DC motors are used for all sort of robotic projects. The motor shield can drive up to 4 DC motors bi-directionally. That means they can be driven forwards and backwards. The speed can also be varied at 0.5% increments using the high-quality built in PWM. This means the speed is very smooth and won't vary!</p> <p>Note that the H-bridge chip is not really meant for driving loads over 0.6A or that peak over 1.2A so this is for small motors. Check the datasheet for information about the motor to verify its OK.</p> <p>To connect a motor, simply solder two wires to the terminals and then connect them to either the M1, M2, M3, or M4. Then follow these steps in your sketch</p> <p>1. Make sure you include &lt;AFMotor.h&gt;</p> <p>2. Create the AF_DCMotor object with AF_DCMotor(motor#, frequency), to setup the motor H-bridge and latches. The constructor takes two arguments. The first is which port the motor is connected to, 1, 2, 3 or 4. frequency is how fast the speed controlling signal is. For motors 1 and 2 you can choose MOTOR12_64KHZ, MOTOR12_8KHZ, MOTOR12_2KHZ, or MOTOR12_1KHZ. A high speed like 64KHz wont be audible but a low speed like 1KHz will use less power. Motors 3 &amp; 4 are only possible to run at 1KHz and will ignore any setting given</p> <p>3. Then you can set the speed of the motor using setSpeed(speed) where the speed ranges from 0 (stopped) to 255 (full speed). You can set the speed whenever you want.</p> <p>4. To run the motor, call run(direction) where direction is FORWARD, BACKWARD or RELEASE. Of course, the Arduino doesn't actually know if the motor is 'forward' or 'backward', so if you want to change which way it thinks is forward, simply swap the two wires from the motor to the shield.</p> <pre><code>#include &lt;AFMotor.h&gt;\n\nAF_DCMotor motor(2, MOTOR12_64KHZ); // create motor #2, 64KHz pwm\n/*or defined like this\nAF_DCMotor motor(2);*/\n\nvoid setup() {\n  Serial.begin(9600);           // set up Serial library at 9600 bps\n  Serial.println(\"Motor test!\");\n\n  motor.setSpeed(200);     // set the speed to 200/255\n}\n\nvoid loop() {\n  Serial.print(\"tick\");\n\n  motor.run(FORWARD);      // turn it on going forward\n  delay(1000);\n\n  Serial.print(\"tock\");\n  motor.run(BACKWARD);     // the other way\n  delay(1000);\n\n  Serial.print(\"tack\");\n  motor.run(RELEASE);      // stopped\n  delay(1000);\n}\n</code></pre>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#steppers","title":"Steppers","text":"<p>Stepper motors are great for (semi-)precise control, perfect for many robot and CNC projects. This motor shield supports up to 2 stepper motors. The library works identically for bi-polar and uni-polar motors</p> <p>For unipolar motors: to connect up the stepper, first figure out which pins connected to which coil, and which pins are the center taps. If its a 5-wire motor then there will be 1 that is the center tap for both coils. Theres plenty of tutorials online on how to reverse engineer the coils pinout. The center taps should both be connected together to the GND terminal on the motor shield output block. then coil 1 should connect to one motor port (say M1 or M3) and coil 2 should connect to the other motor port (M2 or M4).</p> <p>For bipolar motors: its just like unipolar motors except theres no 5<sup>th</sup> wire to connect to ground. The code is exactly the same.</p> <p>Running a stepper is a little more intricate than running a DC motor but its still very easy</p> <p>1. Make sure you include &lt;AFMotor.h&gt;</p> <p>2. Create the stepper motor object with AF_Stepper(steps, stepper#) to setup the motor H-bridge and latches. Steps indicates how many steps per revolution the motor has. a 7.5degree/step motor has 360/7.5 = 48 steps. Stepper# is which port it is connected to. If you're using M1 and M2, its port 1. If you're using M3 and M4 its port 2</p> <p>3. Set the speed of the motor using setSpeed(rpm) where rpm is how many revolutions per minute you want the stepper to turn.</p> <p>4. Then every time you want the motor to move, call the step(#steps, direction, steptype) procedure. #steps is how many steps you'd like it to take. direction is either FORWARD or BACKWARD and the step type is SINGLE, DOUBLE. INTERLEAVE or MICROSTEP. \"Single\" means single-coil activation, \"double\" means 2 coils are activated at once (for higher torque) and \"interleave\" means that it alternates between single and double to get twice the resolution (but of course its half the speed). \"Microstepping\" is a method where the coils are PWM'd to create smooth motion between steps. Theres tons of information about the pros and cons of these different stepping methods in the resources page. You can use whichever stepping method you want, changing it \"on the fly\" to as you may want minimum power, more torque, or more precision.</p> <p>5. By default, the motor will 'hold' the position after its done stepping. If you want to release all the coils, so that it can spin freely, call release()</p> <p>6. The stepping commands are 'blocking' and will return once the steps have finished. If someone wants to be awesome and write a version of the library that does background stepping that would be cool! :)</p> <pre><code>#include &lt;AFMotor.h&gt;\n\n\nAF_Stepper motor(48, 2);\n\n\nvoid setup() {\n  Serial.begin(9600);           // set up Serial library at 9600 bps\n  Serial.println(\"Stepper test!\");\n\n  motor.setSpeed(10);  // 10 rpm   \n\n  motor.step(100, FORWARD, SINGLE); \n  motor.release();\n  delay(1000);\n}\n\nvoid loop() {\n  motor.step(100, FORWARD, SINGLE); \n  motor.step(100, BACKWARD, SINGLE); \n\n  motor.step(100, FORWARD, DOUBLE); \n  motor.step(100, BACKWARD, DOUBLE);\n\n  motor.step(100, FORWARD, INTERLEAVE); \n  motor.step(100, BACKWARD, INTERLEAVE); \n\n  motor.step(100, FORWARD, MICROSTEP); \n  motor.step(100, BACKWARD, MICROSTEP); \n}\n</code></pre> <p>If you want two stepper motors to step at once you'll need to write something like this:</p> <pre><code>void doublestep (int steps, int direction, int style) {\n  while (steps--) {\n    motor1.step(1, direction, style); \n    motor2.step(1, direction, style); \n  }\n}\n</code></pre>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#faq","title":"FAQ","text":"<p>Please list your question here:</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#additional-idea","title":"Additional Idea","text":"<p>The Additional Idea is the place to write your project ideas about this product, or other usages you've found. Or you can write them on Projects page.</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#resources","title":"Resources","text":"<ul> <li>Library for arduino1.0</li> <li>Library for arduino0022</li> <li>L293D datasheet</li> <li>Wikipedia has tons of information on steppers</li> <li>Jones on stepper motor types</li> <li>Jason on reverse engineering the stepper wire pinouts</li> </ul>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#how-to-buy","title":"How to buy","text":"<p>Click here to buy.</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#see-also","title":"See Also","text":"<p>Other related products and resources.</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#licensing","title":"Licensing","text":"<p>This documentation is licensed under the Creative Commons Attribution-ShareAlike License 3.0 Source code and libraries are</p> <p>licensed under GPL/LGPL, see source code files for details.</p>"},{"location":"Products/Shield/arduino-motorstepperservo-shield.html#external-links","title":"External Links","text":"<p>Links to external webpages which provide more application ideas, documents/datasheet or software libraries</p>"},{"location":"Products/Shield/avr-isp-shield.html","title":"AVR ISP Shield","text":""},{"location":"Products/Shield/avr-isp-shield.html#introduction","title":"Introduction","text":"<p>Did you know your Arduino can burn bootloaderds onto Atmega chips, turning them into Arduino compatible microcontrollers. It required a breadboard and a whole mess of jumper wires but we've just made it a ton easier on you with the AVR ISP Shield! It is very easy to use. Just following the Arduino tutorial, You can turn your Atmega chips to Arduino compatible microcontrollers or change the bootloader of the Arduino boards. Such as you can turn the Crowduino to a Arduino UNO board.</p> <p>Model: ACS26020S </p> <p></p>"},{"location":"Products/Shield/avr-isp-shield.html#features","title":"Features","text":"<p>Dimensions(mm):60.0(L)x53.5(W)x34.0(H)</p>"},{"location":"Products/Shield/avr-isp-shield.html#usage","title":"Usage","text":"<p>1.Plug AVR ISP Shield onto the Arduino/Crowduino. Connect the board to PC using USB cable.</p> <p></p> <p>2.Upload the ArduinoISP firmware (in Examples) to your Arduino board.(File&gt;examples&gt;ArduinoISP)</p> <p></p> <p>3.Select the items in the Tools &gt; Board and Serial Port menus that correspond to the board you are using as the programmer (not the board being programmed).</p> <p> </p> <p>4.Upload the ArduinoISP sketch.</p> <p></p> <p>5.Plug the atmega328P-PU IC into the IC holder of the AVR ISP shield. please be careful about the direction of the atmega328 Or Wire your Arduino board to the target as shown in the diagram below.</p> <p> </p> <p>7.Select the item in the Tools &gt; Board menu that corresponds to the board on which you want to burn the bootloader (not the board that you're using as the programmer). See the board descriptions on the environment page for details. For example:  Burn the bootloader to the Arduino UNO.</p> <p></p> <p>Burn the bootloader to the Crowduino Leonardo.</p> <p></p> <p>8.Use the Burn Bootloader &gt; Arduino as ISP command.</p> <p> </p> <p>9.When burning the bootloader, you will see the LED(PROG) on AVR ISP Shield is blinking, and it will put out when completing the burn. </p> <p> </p>"},{"location":"Products/Shield/avr-isp-shield.html#resources","title":"Resources","text":"<ul> <li>Schematic</li> <li>ArduinoISP Tutorial</li> </ul>"},{"location":"Products/Shield/binocular-stereo-vision-expansion-board-for-raspberry-pi.html","title":"Binocular Stereo Vision Expansion Board for Raspberry Pi","text":""},{"location":"Products/Shield/binocular-stereo-vision-expansion-board-for-raspberry-pi.html#introduction","title":"Introduction","text":"<p>This binocular stereo vision expansion board is specially designed for Raspberry Pi Compute Module, compatible with CM3 / CM3 Lite / CM3+ / CM3+ Lite. Small in size but powerful in function. It features three CSI camera ports that can be connected by camera with different viewing angles or baseline value. It is flexible to build different Raspberry Pi stereo vision projects such as binocular parallax ranging, facial recognition, vivo detection, VR video recording and so on. Also, it has some common used ports like DSI and USB, it is convenient to be connected to LCD display and burning mirror directly. Moreover, it has peripheral interfaces like 24PIN HDMI and 36PIN GPIO are also supported through the FPC connector.</p> <p>Model: RPA20901S</p> <p></p>"},{"location":"Products/Shield/binocular-stereo-vision-expansion-board-for-raspberry-pi.html#features","title":"Features","text":"<ul> <li>Comes with three camera ports</li> <li>DSI port allows directly connecting with DSI display</li> <li>With USB connector, convenient for burning mirror</li> <li>36PIN GPIO connector for extending UART port and Raspberry Pi GPIO</li> <li>24PIN HDMI extended connector for connecting with HDMI display</li> <li>10PIN GPIO/I2C extended connector for connecting ICM20948 IMU fill light board</li> <li>Integrates DS1307 RTC chip and comes with CR1220 battery holder</li> <li>Comes with acrylic mounting plate and tripod adapter</li> <li>Compatible with Raspberry Pi Compute Module CM3 / CM3 Lite / CM3+ / CM3+ Lite compatibly</li> </ul>"},{"location":"Products/Shield/binocular-stereo-vision-expansion-board-for-raspberry-pi.html#usager","title":"Usager","text":"<ul> <li> <p>1. Burn image</p> </li> <li> <p>1.1 Flash the image to Compute Module 3/Compute Module 3+</p> </li> </ul> <p>If you are using Raspberry Pi Compute Module 3 or Compute Module 3+. For these computing modules with eMMC, you need to burn the image to the eMMC on the computing module when using them, otherwise they cannot be used.</p> <p>The steps to burn to eMMC are as follows:</p> <p>1) Run RPiboot_Setup software on the computer and install the Raspberry Pi USB driver. It is recommended to turn off the anti-virus software before installation. After the installation is successful, there will be a rpiboot.exe software in the start folder, as shown in the following figure:</p> <p></p> <p>2) Switch the USB SLAVE ENABLE switch on the STEREO expansion board to the EN end</p> <p>3) Connect the computing module (computing module with eMMC)</p> <p>4) Connect the USB interface on the STEREO expansion board to the PC via a USB cable</p> <p>5) At this time, open the software rpiboot.exe with administrator authority , and the PC will automatically recognize the eMMC in the computing module as a U disk.</p> <p>6) Run Win32DiskImager-burn Record the image software , select the image, and burn the image to the eMMC.</p> <p>Note: If the image has been burned before, you can use the Panasonic_SDFormatter-SD card formatting software to format it before burning.</p> <p>7) After programming is complete, disconnect the USB cable. After disconnecting the power supply, reconnect the power supply to the PWR interface of the STEREO expansion board to start the system from eMMC.</p> <ul> <li>Note</li> <li> <p>During the programming process, the PC should not read and write other USB devices to avoid conflicts;</p> </li> <li> <p>The official image provided by Raspberry Pi, the default account is: pi and the password is: Raspberry.</p> </li> <li> <p>Since the eMMC of CM3 is only 4G (the latest CM3+ has expanded the capacity of eMMC and can support normal Raspberry Pi mirroring), the size of the burned image cannot exceed 4G. Therefore, if you burn Raspbian, you can only use the Lite version of the mirror. If you want a GUI. You can install the GUI by running the following command after the installation is complete:</p> </li> </ul> <pre><code>sudo apt - get update\nsudo apt - get install raspberrypi - ui - mods\n</code></pre> <p>If you can\u2019t program normally with the STEREO expansion board, please try the following steps:</p> <ul> <li> <p>Use WIN10 system to burn, most customers feedback that WIN7 or linux system is unstable.</p> </li> <li> <p>Make sure your CM3/CM3+ version is normal, there will be an additional IC on the back of eMMC. Only the eMMC version can be burned in the current way. For those without eMMC, please refer to \"Flashing Image to Compute Module 3 Lite or Compute Module 3+ Lite\".</p> </li> </ul> <p></p> <ul> <li> <p>Note that the PWR interface needs to be connected to a 5V power adapter.</p> </li> <li> <p>Replace a USB data cable.</p> </li> <li> <p>Replace the USB interface of a PC.</p> </li> <li> <p>Try to restart the PC.</p> </li> <li> <p>Try to unplug and plug CM3/CM3+ again.</p> </li> <li> <p>Try to burn on another computer.</p> </li> <li> <p>1.2 Flash the image to Compute Module 3 Lite or Compute Module 3+ Lite</p> </li> </ul> <p>The operation of flashing the image to Lite is:</p> <p>1) Download the image that seems to be flashing.</p> <p>2) Insert the TF card with a card reader into the computer. The minimum requirement for the TF card is 8G (16G or 32G is recommended).</p> <p>3) Open Win32DiskImager-burning image software, and select the image burning prepared in step 1. (Same as burning the Raspberry Pi image)</p> <p>4) After the burning is successful, insert the TF card into the TF card slot of the STEREO expansion board and power on.</p> <ul> <li>2. Connect to DSI screen</li> </ul> <p>The DSI screen model used in this experiment is: 4.3inch DSI LCD, or the Raspberry Pi screen provided by the Raspberry Pi Foundation</p> <p>1) Make sure to operate under power off</p> <p>2) Connect the 15Pin FPC cable to the DISP1 interface of the STEREO expansion board and the DSI screen</p> <p>3) Connect power</p> <p>4) Wait a few seconds before the screen starts</p> <ul> <li>Note:</li> </ul> <p>If you use the official image, you need to copy dt-blob.bin to the /boot directory to use it normally</p> <p>Device tree source file and its binary file</p> <p></p> <ul> <li>3. Connect HDMI screen</li> </ul> <p>The HDMI screen model used in this experiment is: 7 inch HDMI screen: ESP01215E</p> <p>1) Remove the DSI screen, connect the HDMI adapter board to the HDMI interface of STEREO</p> <p>2) Connect the HDMI screen, (if the HDMI screen Connect with the DSI screen, then the Raspberry Pi will only drive the DSI screen)</p> <p>3) Change the config.txt file in the TF card to modify the resolution. For the screen model used this time, 7inch HDMI LCD (H) (with case) , Need to add the following statement at the end of config.txt:</p> <pre><code>max_usb_current = 1\n  hdmi_force_hotplug = 1 \n  config_hdmi_boost = 10\n  hdmi_group = 2 \n  hdmi_mode = 87 \n  hdmi_cvt 1024 600 60 6 0 0 0\n</code></pre> <p>4) After the change, restart the Raspberry Pi to drive the HDMI screen.</p> <ul> <li>4. Connect CSI camera</li> </ul> <p>4.1 Test the Raspberry Pi camera</p> <p>The method to test the Raspberry Pi camera is:</p> <p>1) Make sure that the mirror is downloaded from the Micro Snow Encyclopedia, the device tree is configured for the mirror, and the two cameras can be driven by commands without modification.</p> <p>2)Connect the camera to the CAM0 and CAM1 interfaces. The CSI camera model used in this experiment is: IMX219-77 Camera.</p> <p>3)After connecting, power on, after power on, you can check the camera effect:</p> <p>View the first camera screen connected:</p> <pre><code>sudo raspivid - t 0 - cs 0\n</code></pre> <p>View the second camera screen connected:</p> <pre><code>sudo raspivid - t 0 - cs 1\n</code></pre> <p>The -cs parameter indicates the number of cameras that are connected, but the camera number indicated by the -cs parameter is not exactly the same as the silkscreen of the board and the shell (the parameter -cs indicates the number of cameras that are connected, if only it is connected If a camera is connected to the CAM1 interface, check that the -cs parameter of the camera command is 0 to indicate the 0<sup>th</sup> camera connected).</p> <p>4.2 Source image, modify the device tree to drive the camera</p> <p>If you use the image provided by us, the device tree has already been configured. This step can be skipped directly. If you are using a brand new image provided by the official, you need to reconfigure the device tree.</p> <p>1)Run raspi-config, select Interfacing Options-&gt;Camera-&gt;Yes-&gt;Finish-Yes, reboot the system, and turn on enable camera.</p> <p>2)The device tree file download official, the Raspberry Pi Foundation device tree referral link , Raspberry Pi Foundation device tree download 1 link  , download link 2</p> <p>3)After downloading the device tree file, next, you need to modify the device tree file. The specific device tree is modified as follows:</p> <p></p> <p></p> <p>Namely: Compared with the official device tree file, the specific modification is: the LDE and SHUTDOWN of Camera0 are changed from the original 4,5 pins to 32,33 pins.</p> <p>4\uff09After modifying the device tree file, compile the device tree file, the compilation method is as follows:</p> <pre><code>dtc - I dts - O dtb - o dt - blob . bin dt - blob - disp1 - cam2 . dts\n</code></pre> <p>5\uff09After compilation, a dt-blob.bin file will be generated. Just copy (replace) this file directly to the boot directory.</p> <p>6\uff09Restart, you can test the dual camera with the following command:</p> <pre><code>sudo raspivid - t 0 - cs 0 \nsudo raspivid - t 0 - cs 1\n</code></pre> <p>How to use CAM3 interface The CAM3 interface and the CAM1 interface are switched through the GPIO38 pin. If the GPIO38 interface is set to high level, the CS1 interface calls the camera of the CAM3 interface. If the GPIO38 interface is set to low level, the CS1 interface calls the camera of the CAM1 interface.</p> <p>7) Run the following program</p> <pre><code>cd ~ /CM_STEREO_BOARD\nsudo chmod +x CAM3_CAM1_Switch.sh\n./ CAM3_CAM1_Swtich . Sh 1\n</code></pre> <p>/CAM3_CAM1_Switch.sh 1 Switch to use CAM3 interface</p> <p>8) Run the camera command test after switching</p> <pre><code>sudo raspivid - t 0 - cs 1\n</code></pre> <ul> <li>5. Test ICM20948</li> </ul> <p>1) First download the sample program</p> <pre><code>HTTP wget\u00a0: //www.waveshare.net/w/upload/d/d8/CM_STEREO_BOARD.zip\nunzip CM_STEREO_BOARD . zip\n</code></pre> <p>2) Connect the ICM20948 fill light board to the STEREO expansion board through a 10pin cable</p> <p>3)Turn on the I2C interface</p> <pre><code>sudo raspi - config\n</code></pre> <p>Select Interfacing Options -&gt; I2C -&gt; Yes-&gt;OK</p> <p>4) Check the I2c address</p> <pre><code>i2cdetect - y 1\n</code></pre> <p></p> <p>Two addresses of 68 69 can be detected, indicating that the module is connected normally Where 68 is the address of the RTC, 69 is the address of the ICM20948 chip</p> <p>5) Run the following command to test ICM20948</p> <pre><code>cd ~ /CM_STEREO_BOARD/ 10Dof - D_Demo /\nsudo make\nsudo ./ 10Dof - D\n</code></pre> <p>After running the program, the terminal interface will print the information of the ICM20948 chip</p> <p></p> <p>Ctrl+c can close the program</p> <ul> <li>6. Test RTC</li> </ul> <p>1)The STEREO expansion board has a RTC spare battery holder, you can connect to the CR1220 button battery, the battery needs to be purchased separately</p> <p>2)Modify the rc.local file</p> <pre><code>Nano sudo / etc / rc . local\n</code></pre> <p>Add the following statement to the front of exit0</p> <pre><code>sudo modprobe i2c - dev &amp;\nsudo modprobe i2c - bcm2708 &amp;\necho \"ds1307 0x68\" | sudo tee / sys / class / i2c - adapter / i2c - 1 / new_device &amp;\n</code></pre> <p></p> <p>3) Reboot the system</p> <pre><code>sudo reboot\n</code></pre> <p>4) After restarting, check the I2c address again, and you will find that the original address 68 has become UU, which is normal</p> <p>5)Read RTC time</p> <pre><code>sudo hwclock \u2013 r\n</code></pre> <p>After the command is executed, the current network time will be printed out. If the time is not correct, set the time zone in the system and test again.</p> <p>6)You can also write the RTC time into the system</p> <pre><code>sudo hwclock \u2013 s\n</code></pre> <ul> <li>7. Test fill light and buttons</li> </ul> <p>On the ICM20948 board, there are two fill lights onboard, one is white fill light and the other is infrared fill light. Here we combine the buttons on the STEREO board to test the fill light function</p> <p>1)Run command</p> <pre><code>cd ~ /CM_STEREO_BOARD/\nPython KEY_LED sudo . Py\n</code></pre> <p>After successfully running the program, the infrared fill light will light up, press the button to switch between the infrared fill light and the white fill light Note that the brightness of the white fill light is relatively high. When testing, cover it to avoid direct exposure to the eyes.</p> <p>Ctrl+C can terminate the program.</p> <ul> <li>8. Test the serial port expansion board</li> </ul> <p>1)Connect the serial port expansion board to the STEREO board through the 36PIN cable</p> <p>2)Connect the USB port on the serial port expansion board to the computer with a USB cable</p> <p>3)The Raspberry Pi system enables the serial port debugging interface function</p> <pre><code>sudo raspi \u2013 config\n</code></pre> <p>Select Interfacing Options -&gt; Serial -&gt; Yes -&gt; No -&gt; OK</p> <p>4)Restart the system, then open the putty software on the computer and use the serial port to log in to the Raspberry Pi</p>"},{"location":"Products/Shield/bluetooth-shield-v10.html","title":"Bluetooth Shield v1.0","text":""},{"location":"Products/Shield/bluetooth-shield-v10.html#description","title":"Description","text":"<p>The Bluetooth Shield integrates a Serial Bluetooth module. It can be easily used with Arduino /Crowduino for transparent wireless serial communication. You can choose two pins from Arduino D0 to D7 as Software Serial Ports to communicate with Bluetooth Shield (D0 and D1 is Hardware Serial Port). It also expand five analog IOs that you can use it to connect other devices.</p> <p>Model: MCS01108S</p> <p></p>"},{"location":"Products/Shield/bluetooth-shield-v10.html#features","title":"Features","text":"<ul> <li>Crowduino/Arduino compatible.</li> <li>Standard Shield designed that you can use it easily.</li> <li>Up to10m communication distance in house without obstacle</li> <li>UART interface (TTL) with programmable baud rate (SPP firmware installed)</li> <li>Default baud rate: 38400, data bits: 8, stop bit: 1, Parity: No parity</li> <li>Default PINCODE:\u201d0000\u201d</li> <li>A full set of configuration commands</li> <li>On board PCB antenna</li> <li>FCC ID certificated</li> </ul>"},{"location":"Products/Shield/bluetooth-shield-v10.html#application-idea","title":"Application Idea","text":"<p>1. Communicate with two Bluetooth Shield.  2. Use your Android phone to control the Arduino car. 3. Communicate with your computer.  </p>"},{"location":"Products/Shield/bluetooth-shield-v10.html#specification","title":"Specification","text":"Items Min Typical Max Unit Voltage 2.8 3.3 3.5 v Current 3 / 100 mA Communication Distance(in house) / / 10 m Protocol Bluetooth V2.0 with SPP firmware / Interface Uart Serial Port(TTL) / Supported Baudrate 9600, 19200, 38400, 57600, 115200, 230400, 460800 bps ESD contact discharge \u00b14 KV ESD air discharge \u00b18 / Dimensions 47.3(L)x55.0(W)x23.5(H) mm Net Weight g"},{"location":"Products/Shield/bluetooth-shield-v10.html#interface","title":"Interface","text":""},{"location":"Products/Shield/bluetooth-shield-v10.html#usage","title":"Usage","text":""},{"location":"Products/Shield/bluetooth-shield-v10.html#communicating-between-two-bluetooth-shield","title":"Communicating between two Bluetooth Shield","text":"<p> This demo will show you how to communicate between two Arduino/Crowduino through Bluetooth Shield.For the special applications, you may need to write the code by yourself.</p> <ul> <li>Download the Arduino Library for the shield, and unzip it into the path of Arduino Libraries. This library includes two sketch, one for Master and the other for Slave. Make sure Software Serial Library is included as well.</li> </ul> <p></p> <ul> <li>Upload the sketch Master.ino and Slave.ino to two separate Arduino/Crowduino.</li> <li>Open two Serial Terminals on your PC, with the setting of 38400, 8, 1, N. Open the two Com Port of Arduino/Crowduino.</li> <li>Plug the Bluetooth Shields to the Master board and the Slave Board, and reset the two boards.</li> </ul> <p>Then you will see the red and green LED on the board are flashing in interval indicting they are inquiring for each other. After a while only the green led is flashing one time per second indicating that they are connected. There's also some information printed on the two terminal as following.</p> <p></p> <ul> <li>The connection is successful now, and you can type any character on the Serial Terminal and send to each .</li> </ul>"},{"location":"Products/Shield/bluetooth-shield-v10.html#connecting-bluetooth-shield-to-android-phone","title":"Connecting Bluetooth Shield to Android Phone","text":"<p>This demo will show you how to connect Bluetooth Shield to Android Phone. Here we test on HTC Legend with Android 2.2.For the special applications, you may need to write the code by yourself.</p> <ul> <li>Download the Arduino Library for the shield, and unzip it into the path of Arduino Libraries. This library includes two sketch, one for Master and the other for Salve. Make sure Serial Library is included as well.</li> <li>Plug the Bluetooth Shield onto the Arduino/Crowduino, and upload the Slave.ino to the board.Open the Serial Terminal with setting of 9600, 8, 1, N.</li> </ul> <p></p> <ul> <li> <p>Download an Serial Terminal for Android to the phone. Install the apk(Bluetooth SPP).</p> </li> <li> <p>Enable the bluetooth function and scan for devices. You will find the CrowBTSlave device.</p> </li> <li> <p>Select and pair with the \"CrowBTSlave\", input the PIN code 0000, choose OK.</p> </li> </ul> <p></p> <ul> <li> <p>Now let's open the Bluetooth SPP on Android. It illustrates Press [search] key to find Bluetooth-enabled device.and there will be a list of devices found shown the phone.</p> </li> <li> <p>Select \"CrowBTSlave\", and press connect key, wait a second, the connection will be established. And you can receive and send any character through this terminal.</p> </li> </ul> <p> </p> <ul> <li>Notice:you can also send data to your phone.</li> </ul>"},{"location":"Products/Shield/bluetooth-shield-v10.html#resource","title":"Resource","text":"<ul> <li>Schematic in PDF</li> <li>SoftwareSerial library</li> <li>Bluetooth - module Datasheet</li> <li>Bluetooth Software instruction</li> </ul>"},{"location":"Products/Shield/bluetooth-shield-v10.html#how-to-buy","title":"How to buy","text":"<p>You can visit here to purchase it.</p>"},{"location":"Products/Shield/breakout-board-for-microbit-io-expansion-board.html","title":"Breakout Board for micro:bit IO Expansion Board","text":""},{"location":"Products/Shield/breakout-board-for-microbit-io-expansion-board.html#introduction","title":"Introduction","text":"<p>Microbit expansion board is an IO port expansion board that supports micro:bit. It can draw out all resources on the micro:bit and also has its own buzzer. Not only can it be connected to the P0 pin through a jumper cap, but it can also be released through the jumper cap. The small and unique size is very suitable for various small projects of micro:bit.</p> <p>Model: DTS02018B</p> <p></p>"},{"location":"Products/Shield/breakout-board-for-microbit-io-expansion-board.html#features","title":"Features","text":"<ul> <li>All IO ports are led out</li> <li>Comes with buzzer</li> <li>With LEGO compatible latch holes</li> <li>3PN interface distinguished by yellow, red and black</li> </ul>"},{"location":"Products/Shield/breakout-board-for-microbit-io-expansion-board.html#usage","title":"Usage","text":"<p>For use with micro:bit, the connection is as shown below:</p> <p></p> <p>Then log in to the makecode website https://makecode.microbit.org/ and click on New Project.</p> <p></p>"},{"location":"Products/Shield/breakout-board-for-microbit-io-expansion-board.html#example-1-digital-output","title":"Example 1 digital output","text":"<p>1. Connect the positive and negative poles of the power supply and the IO port</p> <p></p> <p>2. Write a light program.</p> <p></p> <p>3. Running result</p> <p> </p>"},{"location":"Products/Shield/breakout-board-for-microbit-io-expansion-board.html#example-2-i2c-mode","title":"Example 2 I2C mode","text":"<p>1. Add the i2c program module to makecode. Here we take oled as an example. Click \"Extensions\", enter OLED in the search box, and select the \"oled-ssd1306\" module.</p> <p></p> <p></p> <p>2. Connection module I2C interface</p> <p></p> <p>3. Write a program to display \"Micro:bit\"</p> <p></p> <p>4. Run and check the display effect</p> <p></p>"},{"location":"Products/Shield/can-bus-shield.html","title":"CAN-BUS Shield","text":""},{"location":"Products/Shield/can-bus-shield.html#introduction","title":"Introduction","text":"<p>CAN-BUS is a common industrial bus because of its long travel distance, medium communication speed and high reliability. It is widely used as the automotive diagnostic bus, and also commonly used on modern machine tools. This CAN-Bus shield gives the Arduino CAN-Bus capability, It uses the Microchip MCP2515 CAN controller with MCP2551 CAN transceiver, the CAN connection is via a standard 9-way sub-D for use with OBD-II cable, ideal for automotive CAN application. The shield also has a Micro SD card holder, which helps you store the diagnostic information in the SD card directly, making this shield ideal for data logging application.</p> <p>Model: AS54887CAN </p>"},{"location":"Products/Shield/can-bus-shield.html#features","title":"Features","text":"<ul> <li>Arduino Mega and Leonardo compatible</li> <li>Implements CAN V2.0B at up to 1 Mb/s</li> <li>SPI Interface up to 10 MHz</li> <li>Standard (11 bit) and extended (29 bit) data and remote frames</li> <li>Two receive buffers with prioritized message storage</li> <li>Industrial standard 9 pin sub-D connector</li> <li>Two LED indicators</li> <li>SD card holder for information storage</li> <li>Dimensions(mm):74.3(L)x53.6(W)x23.5(H)</li> </ul>"},{"location":"Products/Shield/can-bus-shield.html#usage","title":"Usage","text":""},{"location":"Products/Shield/can-bus-shield.html#hardware-installation","title":"Hardware Installation","text":"<p>Plug the CAN-BUS Shield onto the Arduino. And then connect the Crowduino to PC with USB cable. </p>"},{"location":"Products/Shield/can-bus-shield.html#upload-the-program","title":"Upload the program","text":"<p>1. Download the CAN-BUS Source code file for Arduino 1.0 and release it in the libraries file in the Arduino-1.0 program.: ..\\arduino-1.0\\libraries.</p> <p>If the folder name include \"-master\", just remove it.</p> <p>2. Open the Arduino-1.0, and you will find 8 examples: receive_check ,send and receive_interrupt and so on. Here we'll use send and receive_check, open it then you should get two programming windows now.</p> <p>  2.1 Send data:</p> <pre><code>// demo: CAN-BUS Shield, send data\n#include &lt;mcp_can.h&gt;\n#include &lt;SPI.h&gt;\n\n// the cs pin of the version after v1.1 is default to D9\n// v0.9b and v1.0 is default D10\nconst int SPI_CS_PIN = 9;\n\nMCP_CAN CAN(SPI_CS_PIN);                                    // Set CS pin\n\nvoid setup()\n{\n    Serial.begin(115200);\n\nSTART_INIT:\n\n    if(CAN_OK == CAN.begin(CAN_500KBPS))                   // init can bus\u00a0: baudrate = 500k\n    {\n        Serial.println(\"CAN BUS Shield init ok!\");\n    }\n    else\n    {\n        Serial.println(\"CAN BUS Shield init fail\");\n        Serial.println(\"Init CAN BUS Shield again\");\n        delay(100);\n        goto START_INIT;\n    }\n}\n\nunsigned char stmp[8] = {0, 1, 2, 3, 4, 5, 6, 7};\nvoid loop()\n{\n    // send data:  id = 0x00, standrad frame, data len = 8, stmp: data buf\n    CAN.sendMsgBuf(0x00, 0, 8, stmp);\n    delay(100);                       // send data per 100ms\n}\n</code></pre> <p>2.2 Receive data</p> <pre><code>// demo: CAN-BUS Shield, receive data with check mode\n// send data coming to fast, such as less than 10ms, you can use this way\n\n\n#include &lt;SPI.h&gt;\n#include \"mcp_can.h\"\n\n\n// the cs pin of the version after v1.1 is default to D9\n// v0.9b and v1.0 is default D10\nconst int SPI_CS_PIN = 9;\n\nMCP_CAN CAN(SPI_CS_PIN);                                    // Set CS pin\n\nvoid setup()\n{\n    Serial.begin(115200);\n\nSTART_INIT:\n\n    if(CAN_OK == CAN.begin(CAN_500KBPS))                   // init can bus\u00a0: baudrate = 500k\n    {\n        Serial.println(\"CAN BUS Shield init ok!\");\n    }\n    else\n    {\n        Serial.println(\"CAN BUS Shield init fail\");\n        Serial.println(\"Init CAN BUS Shield again\");\n        delay(100);\n        goto START_INIT;\n    }\n}\n\n\nvoid loop()\n{\n    unsigned char len = 0;\n    unsigned char buf[8];\n\n    if(CAN_MSGAVAIL == CAN.checkReceive())            // check if data coming\n    {\n        CAN.readMsgBuf(&amp;len, buf);    // read data,  len: data length, buf: data buf\n\n        unsigned char canId = CAN.getCanId();\n\n        Serial.println(\"-----------------------------\");\n        Serial.println(\"get data from ID: \");\n        Serial.println(canId);\n\n        for(int i = 0; i&lt;len; i++)    // print the data\n        {\n            Serial.print(buf[i]);\n            Serial.print(\"\\t\");\n        }\n        Serial.println();\n    }\n}\n</code></pre> <p>3. Upload two examples to two boards separately. Choose the board via the path: Tools --&gt;Serial Port--&gt;COMX. Note down which board is assigned as a \"send\" node and which board is assigned as a \"receive\" node.</p> <p>4. Open the \"Serial Monitor\" on the \"receive\" COM, you will get message sent from the \"send\" node. Here we have the preset message \"0 1 2 3 4 5 6 7\" showing in the following picture.</p> <p></p>"},{"location":"Products/Shield/can-bus-shield.html#reference","title":"Reference","text":""},{"location":"Products/Shield/can-bus-shield.html#1-set-the-baudrate","title":"1. Set the BaudRate","text":"<p>This function is used to initialize the baudrate of the CAN Bus system.</p> <p>The available baudrates are listed as follws:</p> <p>CAN_5KBPS, CAN_10KBPS, CAN_20KBPS, CAN_40KBPS, CAN_50KBPS, CAN_80KBPS, CAN_100KBPS, CAN_125KBPS, CAN_200KBPS, CAN_250KBPS, CAN_500KBPS and CAN_1000KBPS</p>"},{"location":"Products/Shield/can-bus-shield.html#2-set-receive-mask-and-filter","title":"2. Set Receive Mask and Filter","text":"<p>There are 2 receive mask registers and 5 filter registers on the controller chip that guarantee you get data from the target device. They are useful especially in a large network consisting of numerous nodes.</p> <p>We provide two functions for you to utilize these mask and filter registers. They are:</p> <p>init_Mask(unsigned char num, unsigned char ext, unsigned char ulData); &amp; init_Filt(unsigned char num, unsigned char ext, unsigned char ulData);</p> <p>\"num\" represents which register to use. You can fill 0 or 1 for mask and 0 to 5 for filter.</p> <p>\"ext\" represents the status of the frame. 0 means it's a mask or filter for a standard frame. 1 means it's for a extended frame.</p> <p>\"ulData\" represents the content of the mask of filter.</p>"},{"location":"Products/Shield/can-bus-shield.html#3-check-receive","title":"3. Check Receive","text":"<p>The MCP2515 can operate in either a polled mode, where the software checks for a received frame, or using additional pins to signal that a frame has been received or transmit completed. Use the following function to poll for received frames.</p> <p>INT8U MCP_CAN::checkReceive(void);</p> <p>The function will return 1 if a frame arrives, and 0 if nothing arrives.</p>"},{"location":"Products/Shield/can-bus-shield.html#4-get-can-id","title":"4. Get CAN ID","text":"<p>When some data arrive, you can use the following function to get the CAN ID of the \"send\" node.</p> <p>INT32U MCP_CAN::getCanId(void)</p>"},{"location":"Products/Shield/can-bus-shield.html#5-send-data","title":"5. Send Data","text":"<p>CAN.sendMsgBuf(INT8U id, INT8U ext, INT8U len, data_buf);</p> <p>is a function to send data onto the bus. In which:</p> <p>\"id\" represents where the data come from.</p> <p>\"ext\" represents the status of the frame. '0' means standard frame. '1' means extended frame.</p> <p>\"len\" represents the length of this frame.</p> <p>\"data_buf\" is the content of this message.</p> <p>For example, In the 'send' example, we have:</p> <pre><code>unsigned char stmp[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n\nCAN.sendMsgBuf(0x00, 0, 8, stmp); //send out the message 'stmp' to the bus and tell other devices this is a standard frame from 0x00.\n</code></pre>"},{"location":"Products/Shield/can-bus-shield.html#6-receive-data","title":"6. Receive Data","text":"<p>The following function is used to receive data on the 'receive' node:</p> <p>CAN.readMsgBuf(unsigned char len, unsigned char buf);</p> <p>In conditions that masks and filters have been set. This function can only get frames that meet the requirements of masks and filters.</p> <p>\"len\" represents the data length.</p> <p>\"buf\" is where you store the data.</p>"},{"location":"Products/Shield/can-bus-shield.html#resources","title":"Resources","text":"<ul> <li>CAN-BUS Source code file for Arduino 1.0</li> <li>MCP2551 datasheet</li> <li>MCP2515 datasheet</li> </ul>"},{"location":"Products/Shield/capacitive-touch-shield.html","title":"Capacitive Touch Shield","text":""},{"location":"Products/Shield/capacitive-touch-shield.html#introduction","title":"Introduction","text":"<p>The MPR121 is a capacitive touch sensor controller that makes it very easy to integrate capacitive touch sensing into your project. It communicates via I2C, and works by measuring the capacitance of twelve electrode points. When an object comes close to the electrode connector, the measured capacitance changes. This signals the MPR121 that something has touched a 'button'. This Capacitive Touch Shield has 9 build-on capacitive touch pads, and the other 3 electrode for further usage. With this shield you can have a total of 12 touch sensitive buttons. . Compares to other touch shield that using digital pins, this shield uses less pins, which allows more pins left for other usage.</p> <p>Model: AS00121CTH </p>"},{"location":"Products/Shield/capacitive-touch-shield.html#features","title":"Features","text":"<ul> <li>12 Channels totally</li> <li>Build-On 9 keypad, 3 reserved pins for external usage</li> <li>Power status indicator</li> <li>I2C Communication, use less Arduino pins</li> <li>Dimensions(mm):60.0(L)x53.5(W)x2.8(H)</li> </ul>"},{"location":"Products/Shield/capacitive-touch-shield.html#basic-knowledge","title":"Basic Knowledge","text":"<ul> <li>please skit over this prograph if you do not interested on this, it do not your usage on this capacitive Touch Shield</li> </ul>"},{"location":"Products/Shield/capacitive-touch-shield.html#how-to-sense-the-touch","title":"How to Sense the \"Touch\"","text":"<p>The MPR121 measures the capacitance changes that between the pins and \"ground\" to detect the human touch. The complete capacitance measurement system is composed by sensing electrode pads connected to MPR121 sensing inputs, and the MPR121 communicating with the host processor via I2C bus and interrupt output .</p> <p>The capacitance measured on each sensing channel is the total capacitance to ground which can be the combination of background parasitic capacitance to ground(Cb) and finger touch induced capacitance to ground(Cx). The MPR121 uses a constant DC charge current scheme for capacitance measurement. Each channel is charged and then discharged completely to ground periodically to measure the capacitance. All the channels are measured sequentially, when one channel is in the charge/discharge and measurement period the other channels are shorted to ground.</p> <p>The amount of charge(Q)applied is programmable by setting the charge current(I), And the charge time(T). Once the electrode is charged, the peak voltage(V)at the end of chage is measured by internal 10 bit ADC. This voltage V is reverse proportional to the capatance(C)on the sensing channel.</p> <pre><code> &lt;i&gt;&lt;b&gt;C = Q/V = (I*T)/V&lt;/b&gt;&lt;/i&gt;\n</code></pre> <p>That is, If charge the outside cap with a some value of current(I) and time(T), and get the voltage(V), We can get the value of captance, using this way.</p>"},{"location":"Products/Shield/capacitive-touch-shield.html#how-the-mpr121-measures-the-capacitance-and-calibrate","title":"How the mpr121 measures the capacitance and calibrate","text":"<p>The ADC raw data outputs run through 3 levels of digital filtering to filter out the high frequency and low frequency noise encountered. The first level filter is a simple running average filter, the second level filter result is 10bit and stored in the output data registers as the immediate capacitance of each sensing input, the third level filter result is an even lower frequency content of signal change using the second level filter output, mainly used as the baseline value representing the capacitance variation over the long term and slow environment change such as atmospheric moisture and dirt for touch detection. </p> <p> <p>Touch and release is determined by comparing the immediate capacitance deviation that is the electrode second level filtered output data deviation to the baseline value. If the deviation passed the setting threshold, then a touch or release status is detected and reported in the status register. The touch and release threshold are independent and individually programmable for each electrode, providing hysteresis and electrode independence. Debounce setting can be used for further noise filtering to provide glitch free touch and release detection.</p></p> <p></p>"},{"location":"Products/Shield/capacitive-touch-shield.html#usage","title":"Usage","text":"<p>1.Hardware connection All the header pins are not soldered, so you can solder them by yourself to use it as Arduino \u201cShield\u201d, or just solder the necessary pins(Power/GND/I2C/IRQ) to make this board more easy to implement anywhere. There are 9 pads on the touch shield, the pad name connect with the MPR121 with :</p> <pre><code>&lt;i&gt;&lt;b&gt;Pad Name&lt;---&gt; MPR121 Pin&lt;/b&gt;&lt;/i&gt;\n\u00a0\u00a0\u00a0\u00a01&lt;---&gt;ELE8\n\u00a0\u00a0\u00a0\u00a02&lt;---&gt;ELE5\n\u00a0\u00a0\u00a0\u00a03&lt;---&gt;ELE2\n\u00a0\u00a0\u00a0\u00a04&lt;---&gt;ELE7\n\u00a0\u00a0\u00a0\u00a05&lt;---&gt;ELE4\n\u00a0\u00a0\u00a0\u00a06&lt;---&gt;ELE1\n\u00a0\u00a0\u00a0\u00a07&lt;---&gt;ELE6\n\u00a0\u00a0\u00a0\u00a08&lt;---&gt;ELE3\n\u00a0\u00a0\u00a0\u00a09&lt;---&gt;ELE0\n</code></pre> <p>And the ELE9~11 can be use for external usage. you can use any mental material you\u2019ve chosen to use as your electrode.   </p> <p>The Touch Shield uses I2C to communicate with controller. An IRQ(D2) was used to report the controller there is a \"Touch\" happened.  2.Download the Touch Shield demo code 3.Unzip it into the libraries file of Arduino IDE by the path: ..\\arduino-1.0\\libraries. 4.Open the code directly by the path:File -&gt; Example -&gt;Touch_Shield_Example.  </p> <pre><code>#include \"mpr121.h\"\n#include \"i2c.h\"\n\n// 11 max digits used\n#define DIGITS 11 \n\n// Match key inputs with electrode numbers\n#define ONE 8\n#define TWO 5\n#define THREE 2\n#define FOUR 7\n#define FIVE 4\n#define SIX 1\n#define SEVEN 6\n#define EIGHT 3\n#define NINE 0\n\n//extras (not used)\n#define ELE9 9\n#define ELE10 10\n#define ELE11 11\n\n//interupt pin\nint irqpin = 2;  // D2\n\nvoid setup()\n{\n  //make sure the interrupt pin is an input and pulled high\n  pinMode(irqpin, INPUT);\n  digitalWrite(irqpin, HIGH);\n\n  //configure serial out\n  Serial.begin(9600);\n\n  //output on ADC4 (PC4, SDA)\n  DDRC |= 0b00010011;\n  // Pull-ups on I2C Bus\n  PORTC = 0b00110000; \n  // initalize I2C bus. Wiring lib not used. \n  i2cInit();\n\n  delay(100);\n  // initialize mpr121\n  mpr121QuickConfig();\n\n  // Create and interrupt to trigger when a button\n  // is hit, the IRQ pin goes low, and the function getNumber is run. \n  attachInterrupt(0,getNumber,LOW);\n\n  // prints 'Ready...' when you can start hitting numbers\n  Serial.println(\"Ready...\");\n}\n\nvoid loop()\n{\n  //You can put additional code here. The interrupt will run in the backgound. \n}\n\nvoid getNumber()\n{\n  int i = 0;\n  int touchNumber = 0;\n  uint16_t touchstatus;\n  char digits[DIGITS];\n\n  touchstatus = mpr121Read(0x01) &lt;&lt; 8;\n  touchstatus |= mpr121Read(0x00);\n\n  for (int j=0; j&lt;12; j++)  // Check how many electrodes were pressed\n  {\n    if ((touchstatus &amp; (1&lt;&lt;j)))\n      touchNumber++;\n  }\n\n  if (touchNumber == 1)\n  {\n    if (touchstatus &amp; (1&lt;&lt;SEVEN))\n      digits[i] = '7';\n    else if (touchstatus &amp; (1&lt;&lt;FOUR))\n      digits[i] = '4';\n    else if (touchstatus &amp; (1&lt;&lt;ONE))\n      digits[i] = '1';\n    else if (touchstatus &amp; (1&lt;&lt;EIGHT))\n      digits[i] = '8';\n    else if (touchstatus &amp; (1&lt;&lt;FIVE))\n      digits[i] = '5';\n    else if (touchstatus &amp; (1&lt;&lt;TWO))\n      digits[i] = '2';\n    else if (touchstatus &amp; (1&lt;&lt;NINE))\n      digits[i] = '9';\n    else if (touchstatus &amp; (1&lt;&lt;SIX))\n      digits[i] = '6';\n    else if (touchstatus &amp; (1&lt;&lt;THREE))\n      digits[i] = '3';\n\n    Serial.print(digits[i]);\n    i++;\n  }\n  //do nothing if more than one button is pressed\n  else if (touchNumber == 0)\n    ;\n  else\n    ;\n}\n</code></pre> <p>5.Uplaod the code, then touch the pad on the shield, you will see outputs as below:  6.If you want to use the extern 3 pins, add the follows codes in the if (touchNumber == 1) function in the loop()</p> <pre><code>   else if (touchstatus &amp; (1 &lt;&lt; ELE9))\n{\n  digits = 'A';\n}\nelse if (touchstatus &amp; (1 &lt;&lt; ELE10))\n{\n digits = 'B';\n}\nelse if (touchstatus &amp; (1 &lt;&lt; ELE11))\n{\n digits = 'C';\n}\n</code></pre> <p>If your IRQ was used for other modules and you do not want to use the IRQ, you can also inquery the toush status with about 100ms interval, you can take a reference of Touch Shield with no IRQ.zip</p>"},{"location":"Products/Shield/capacitive-touch-shield.html#resources","title":"Resources","text":"<ul> <li>Touch Shield demo code</li> </ul>"},{"location":"Products/Shield/cc3000-wifi-shield.html","title":"CC3000 WiFi Shield","text":""},{"location":"Products/Shield/cc3000-wifi-shield.html#introduction","title":"Introduction","text":"<p>This is a shield for the CC3000 WiFi Module. The CC3000 from TI (Texas Instruments) is a self-contained wireless network processor that makes incorporating internet connectivity into your project simple. Instead of the more standard UART communication method, the CC3000 module utilizes an SPI interface allowing you, the user, to control the flow of data as you please. What makes the CC3000 unique is its ability to associate to a WiFi access point using a cell phone app in the Texas Instruments process called SmartConfig.</p> <p>Model: (Discontinued) </p>"},{"location":"Products/Shield/cc3000-wifi-shield.html#features","title":"Features","text":"<ol> <li>Arduino, Crowduino, Seeeduino, Arduino Mega and Crowduino Mega compatible</li> <li>Support SD card 2GB and 4GB</li> <li>Wireless network processor <ul> <li>IEEE 802.11 b/g ( 2.4GHz)</li> <li>Embedded IPv4 TCP/IP stack</li> </ul> </li> <li>Best-in-class radio performance <ul> <li>TX power: +18.0 dBm at 11 Mbps, CCK</li> <li>RX sensitivity: \u201388 dBm, 8% PER, 11 Mbps</li> </ul> </li> <li>Works with low MIPS and low-cost MCUs with compact memory footprint <ul> <li>Small code size (Flash and RAM) required for MCU</li> </ul> </li> <li>FCC, IC, CE and TELEC certified reference design with a chip antenna</li> <li>Integrated crystal and power management</li> <li>Small form factor <ul> <li>16.3 mm \u00d7 13.5 mm \u00d7 2 mm</li> </ul> </li> <li>Operating temperature: \u201320\u00b0C to 70\u00b0C</li> <li>SmartConfig technology enables simple Wi-Fi configuration using a smartphone, tablet or PC</li> <li>Proven Wi-Fi interoperability; based on TI\u2019s seventh generation of proven Wi-Fi solutions</li> <li>Complete platform solution including user and porting guides, API guide, sample applications, and support community</li> </ol>"},{"location":"Products/Shield/cc3000-wifi-shield.html#specifications","title":"Specifications","text":"<p>CC3000 Specifications</p> CC3000's Characteristics Standards 802.11 b/g, BSS Station Wi-Fi Security Modes WEP, WPA/WPA2 (AES and TKIP \u2013 Personal) Embedded Wi-Fi TCP/IP stack (IPv4 \u2013 DHCP client, DNS, mDNS, ARP), Wi-Fi driver, security supplicant, Auto-calibrated radio Required Code size As low as 5KB Flash &amp; 360B RAM Host Interface SPI at 16MHz Power Modes Active Mode (92mA typ RX current), Shutdown Mode (&lt;5uA) Power Supply 2.9V \u2013 4.8V I/O Voltage 1.8V \u2013 3.6V Connections 4 Sockets (UDP or TCP) Throughput (TCP) ~4 Mbps***Note** This was measured for CC3000, when combined with MSP430FR5739 Headless Configuration SmartConfig\u2122 Technology"},{"location":"Products/Shield/cc3000-wifi-shield.html#usage","title":"Usage","text":""},{"location":"Products/Shield/cc3000-wifi-shield.html#hardware-installation","title":"Hardware Installation","text":"<p>Assemble these parts together like the picture below. and mount the shield onto your Arduino/Crowduino.</p>"},{"location":"Products/Shield/cc3000-wifi-shield.html#software-programming","title":"Software Programming","text":"<p>1.First you have to make sure that Arduino1.0 has already been installed on your computer. 2.Download the CC3000 WiFi Shield library here CC3000_Library.zip and unzip it into the libraries file of Arduino via this path: ..\\arduino-1.0\\libraries 3.Open the code directly by the path:File -&gt; Example -&gt;CC3000_Library-&gt;buildtest.</p> <pre><code>#include &lt;Adafruit_CC3000.h&gt;\n#include &lt;ccspi.h&gt;\n#include &lt;SPI.h&gt;\n#include &lt;string.h&gt;\n#include \"utility/debug.h\"\n\n// These are the interrupt and control pins\n#define ADAFRUIT_CC3000_IRQ   3  // MUST be an interrupt pin!\n// These can be any two pins\n#define ADAFRUIT_CC3000_VBAT  5\n#define ADAFRUIT_CC3000_CS    10\n// Use hardware SPI for the remaining pins\n// On an UNO, SCK = 13, MISO = 12, and MOSI = 11\nAdafruit_CC3000 cc3000 = Adafruit_CC3000(ADAFRUIT_CC3000_CS, ADAFRUIT_CC3000_IRQ, ADAFRUIT_CC3000_VBAT,\n                                         SPI_CLOCK_DIVIDER); // you can change this clock speed but DI\n\n#define WLAN_SSID       \"myNetwork\"        // cannot be longer than 32 characters!\n#define WLAN_PASS       \"myPassword\"\n// Security can be WLAN_SEC_UNSEC, WLAN_SEC_WEP, WLAN_SEC_WPA or WLAN_SEC_WPA2\n#define WLAN_SECURITY   WLAN_SEC_WPA2\n\n\n\n/**************************************************************************/\n/*!\n    @brief  Sets up the HW and the CC3000 module (called automatically\n            on startup)\n*/\n/**************************************************************************/\nvoid setup(void)\n{\n  Serial.begin(115200);\n  Serial.println(F(\"Hello, CC3000!\\n\")); \n\n  displayDriverMode();\n  Serial.print(\"Free RAM: \"); Serial.println(getFreeRam(), DEC);\n\n  /* Initialise the module */\n  Serial.println(F(\"\\nInitialising the CC3000 ...\"));\n  if (!cc3000.begin())\n  {\n    Serial.println(F(\"Unable to initialise the CC3000! Check your wiring?\"));\n    while(1);\n  }\n\n  /* Optional: Update the Mac Address to a known value */\n/*\n  uint8_t macAddress[6] = { 0x08, 0x00, 0x28, 0x01, 0x79, 0xB7 };\n   if (!cc3000.setMacAddress(macAddress))\n   {\n     Serial.println(F(\"Failed trying to update the MAC address\"));\n     while(1);\n   }\n*/\n\n  uint16_t firmware = checkFirmwareVersion();\n  if (firmware &lt; 0x113) {\n    Serial.println(F(\"Wrong firmware version!\"));\n    for(;;);\n  } \n\n  displayMACAddress();\n\n  /* Optional: Get the SSID list (not available in 'tiny' mode) */\n#ifndef CC3000_TINY_DRIVER\n  listSSIDResults();\n#endif\n\n  /* Delete any old connection data on the module */\n  Serial.println(F(\"\\nDeleting old connection profiles\"));\n  if (!cc3000.deleteProfiles()) {\n    Serial.println(F(\"Failed!\"));\n    while(1);\n  }\n\n  /* Optional: Set a static IP address instead of using DHCP.\n     Note that the setStaticIPAddress function will save its state\n     in the CC3000's internal non-volatile memory and the details\n     will be used the next time the CC3000 connects to a network.\n     This means you only need to call the function once and the\n     CC3000 will remember the connection details.  To switch back\n     to using DHCP, call the setDHCP() function (again only needs\n     to be called once).\n  */\n  /*\n  uint32_t ipAddress = cc3000.IP2U32(192, 168, 1, 19);\n  uint32_t netMask = cc3000.IP2U32(255, 255, 255, 0);\n  uint32_t defaultGateway = cc3000.IP2U32(192, 168, 1, 1);\n  uint32_t dns = cc3000.IP2U32(8, 8, 4, 4);\n  if (!cc3000.setStaticIPAddress(ipAddress, netMask, defaultGateway, dns)) {\n    Serial.println(F(\"Failed to set static IP!\"));\n    while(1);\n  }\n  */\n  /* Optional: Revert back from static IP addres to use DHCP.\n     See note for setStaticIPAddress above, this only needs to be\n     called once and will be remembered afterwards by the CC3000.\n  */\n  /*\n  if (!cc3000.setDHCP()) {\n    Serial.println(F(\"Failed to set DHCP!\"));\n    while(1);\n  }\n  */\n\n  /* Attempt to connect to an access point */\n  char *ssid = WLAN_SSID;             /* Max 32 chars */\n  Serial.print(F(\"\\nAttempting to connect to \")); Serial.println(ssid);\n\n  /* NOTE: Secure connections are not available in 'Tiny' mode!\n     By default connectToAP will retry indefinitely, however you can pass an\n     optional maximum number of retries (greater than zero) as the fourth parameter.\n\n     ALSO NOTE: By default connectToAP will retry forever until it can connect to\n     the access point.  This means if the access point doesn't exist the call\n     will _never_ return!  You can however put in an optional maximum retry count\n     by passing a 4th parameter to the connectToAP function below.  This should\n     be a number of retries to make before giving up, for example 5 would retry\n     5 times and then fail if a connection couldn't be made.\n  */\n  if (!cc3000.connectToAP(WLAN_SSID, WLAN_PASS, WLAN_SECURITY)) {\n    Serial.println(F(\"Failed!\"));\n    while(1);\n  }\n\n  Serial.println(F(\"Connected!\"));\n\n  /* Wait for DHCP to complete */\n  Serial.println(F(\"Request DHCP\"));\n  while (!cc3000.checkDHCP())\n  {\n    delay(100); // ToDo: Insert a DHCP timeout!\n  }  \n\n  /* Display the IP address DNS, Gateway, etc. */  \n  while (! displayConnectionDetails()) {\n    delay(1000);\n  }\n\n#ifndef CC3000_TINY_DRIVER\n  /* Try looking up www.adafruit.com */\n  uint32_t ip = 0;\n  Serial.print(F(\"www.adafruit.com -&gt; \"));\n  while  (ip  ==  0)  {\n    if  (!  cc3000.getHostByName(\"www.adafruit.com\", &amp;ip))  {\n      Serial.println(F(\"Couldn't resolve!\"));\n    }\n    delay(500);\n  }  \n  cc3000.printIPdotsRev(ip);\n\n  /* Do a quick ping test on adafruit.com */  \n  Serial.print(F(\"\\n\\rPinging \")); cc3000.printIPdotsRev(ip); Serial.print(\"...\");  \n  uint8_t replies = cc3000.ping(ip, 5);\n  Serial.print(replies); Serial.println(F(\" replies\"));\n  if (replies)\n    Serial.println(F(\"Ping successful!\"));\n#endif\n\n  /* You need to make sure to clean up after yourself or the CC3000 can freak out */\n  /* the next time you try to connect ... */\n  Serial.println(F(\"\\n\\nClosing the connection\"));\n  cc3000.disconnect();\n}\n\nvoid loop(void)\n{\n  delay(1000);\n}\n\n/**************************************************************************/\n/*!\n    @brief  Displays the driver mode (tiny of normal), and the buffer\n            size if tiny mode is not being used\n\n    @note   The buffer size and driver mode are defined in cc3000_common.h\n*/\n/**************************************************************************/\nvoid displayDriverMode(void)\n{\n  #ifdef CC3000_TINY_DRIVER\n    Serial.println(F(\"CC3000 is configure in 'Tiny' mode\"));\n  #else\n    Serial.print(F(\"RX Buffer\u00a0: \"));\n    Serial.print(CC3000_RX_BUFFER_SIZE);\n    Serial.println(F(\" bytes\"));\n    Serial.print(F(\"TX Buffer\u00a0: \"));\n    Serial.print(CC3000_TX_BUFFER_SIZE);\n    Serial.println(F(\" bytes\"));\n  #endif\n}\n\n/**************************************************************************/\n/*!\n    @brief  Tries to read the CC3000's internal firmware patch ID\n*/\n/**************************************************************************/\nuint16_t checkFirmwareVersion(void)\n{\n  uint8_t major, minor;\n  uint16_t version;\n\n#ifndef CC3000_TINY_DRIVER  \n  if(!cc3000.getFirmwareVersion(&amp;major, &amp;minor))\n  {\n    Serial.println(F(\"Unable to retrieve the firmware version!\\r\\n\"));\n    version = 0;\n  }\n  else\n  {\n    Serial.print(F(\"Firmware V.\u00a0: \"));\n    Serial.print(major); Serial.print(F(\".\")); Serial.println(minor);\n    version = major; version &lt;&lt;= 8; version |= minor;\n  }\n#endif\n  return version;\n}\n\n/**************************************************************************/\n/*!\n    @brief  Tries to read the 6-byte MAC address of the CC3000 module\n*/\n/**************************************************************************/\nvoid displayMACAddress(void)\n{\n  uint8_t macAddress[6];\n\n  if(!cc3000.getMacAddress(macAddress))\n  {\n    Serial.println(F(\"Unable to retrieve MAC Address!\\r\\n\"));\n  }\n  else\n  {\n    Serial.print(F(\"MAC Address\u00a0: \"));\n    cc3000.printHex((byte*)&amp;macAddress, 6);\n  }\n}\n\n\n/**************************************************************************/\n/*!\n    @brief  Tries to read the IP address and other connection details\n*/\n/**************************************************************************/\nbool displayConnectionDetails(void)\n{\n  uint32_t ipAddress, netmask, gateway, dhcpserv, dnsserv;\n\n  if(!cc3000.getIPAddress(&amp;ipAddress, &amp;netmask, &amp;gateway, &amp;dhcpserv, &amp;dnsserv))\n  {\n    Serial.println(F(\"Unable to retrieve the IP Address!\\r\\n\"));\n    return false;\n  }\n  else\n  {\n    Serial.print(F(\"\\nIP Addr: \")); cc3000.printIPdotsRev(ipAddress);\n    Serial.print(F(\"\\nNetmask: \")); cc3000.printIPdotsRev(netmask);\n    Serial.print(F(\"\\nGateway: \")); cc3000.printIPdotsRev(gateway);\n    Serial.print(F(\"\\nDHCPsrv: \")); cc3000.printIPdotsRev(dhcpserv);\n    Serial.print(F(\"\\nDNSserv: \")); cc3000.printIPdotsRev(dnsserv);\n    Serial.println();\n    return true;\n  }\n}\n\n/**************************************************************************/\n/*!\n    @brief  Begins an SSID scan and prints out all the visible networks\n*/\n/**************************************************************************/\n\nvoid listSSIDResults(void)\n{\n  uint32_t index;\n  uint8_t valid, rssi, sec;\n  char ssidname[33]; \n\n  if (!cc3000.startSSIDscan(&amp;index)) {\n    Serial.println(F(\"SSID scan failed!\"));\n    return;\n  }\n\n  Serial.print(F(\"Networks found: \")); Serial.println(index);\n  Serial.println(F(\"================================================\"));\n\n  while (index) {\n    index--;\n\n    valid = cc3000.getNextSSID(&amp;rssi, &amp;sec, ssidname);\n\n    Serial.print(F(\"SSID Name    : \")); Serial.print(ssidname);\n    Serial.println();\n    Serial.print(F(\"RSSI         : \"));\n    Serial.println(rssi);\n    Serial.print(F(\"Security Mode: \"));\n    Serial.println(sec);\n    Serial.println();\n  }\n  Serial.println(F(\"================================================\"));\n\n  cc3000.stopSSIDscan();\n}\n</code></pre> <p>4.Before you run the sketch, edit it to replace the dummy SSID and password with your own:</p> <pre><code> #define WLAN_SSID       \"yourNetwork\"        // cannot be longer than 32 characters!\n #define WLAN_PASS       \"yourPassword\"\n</code></pre> <p>If you're using WEP, the password should look like this:</p> <pre><code>const char WLAN_PASS[] = {0x1A, 0x2B, 0x3C, 0x4D, 0x5E, 0x00}; \n</code></pre> <p>Since it's a collection of bytes not 'passphrase' style key Also, make sure that the right wireless security scheme is selected (unsecured, WEP, WPA, or WPA2) Copy Code</p> <p>// Security can be WLAN_SEC_UNSEC, WLAN_SEC_WEP, WLAN_SEC_WPA or WLAN_SEC_WPA2</p> <pre><code>#define WLAN_SECURITY   WLAN_SEC_WPA2\n</code></pre> <p>5.Here's a sample of the Serial Monitor output of buildtest. You should see something similar:  </p>"},{"location":"Products/Shield/cc3000-wifi-shield.html#resource","title":"Resource","text":"<ul> <li>CC3000 Library</li> <li>More usage</li> <li>File:CC3000 Module.pdf</li> </ul>"},{"location":"Products/Wireless/24g-wireless-nrf24l01.html","title":"2.4G Wireless nRF24L01","text":""},{"location":"Products/Wireless/24g-wireless-nrf24l01.html#description","title":"Description","text":"<p>This module uses the newest 2.4GHz transceiver from Nordic Semiconductor, the nRF24L01.This transceiver IC operates in the 2.4GHz band and has many new features! Take all the coolness of the nRF2401A and add some extra pipelines, buffers, and an auto-retransmit feature.</p> <p>Model:WRF24010R</p> <p></p>"},{"location":"Products/Wireless/24g-wireless-nrf24l01.html#features","title":"Features","text":"<ul> <li>Worldwide license-free 2.4GHz ISM band operation</li> <li>250kbps, 1Mbps and 2Mbps on-air data-rate options</li> <li>Enhanced ShockBurst?hardware protocol accelerator</li> <li>Ultra low power consumption?months to years of battery lifetime</li> </ul>"},{"location":"Products/Wireless/24g-wireless-nrf24l01.html#specification","title":"Specification","text":"<ul> <li>Power supply : 1.9~3.6V</li> <li>IO port working voltage : 0~3.3v / 5v</li> <li>Transmitting rate : +7dB</li> <li>Receiving sensitivity : -90dB</li> <li>Transmission range : 250m in open area</li> <li>Dimension : 15x29mm</li> </ul>"},{"location":"Products/Wireless/24g-wireless-nrf24l01.html#usage","title":"Usage","text":""},{"location":"Products/Wireless/24g-wireless-nrf24l01.html#with-arduino","title":"With Arduino","text":"<p>The nRF24L01 module can be controlled in many ways, one of which is Arduino or Crowduino. We tried and tested it, then made a demo. Let\u2019s see how it works with Arduino. 1.Hardware Connection. First of all, of course, you need two Arduino boards and at least two RF modules, one to transmit and the other to receive.  </p> <p> </p> <p>2.Download the code below into the TX Arduino (transmit) \u2014 This code will drive the nRF24L01 module to send out data form 0\u00d700 to 0xFF .</p> <pre><code>/** ******************************************************************\n**   SPI-compatible                                                 **\n**   CS -  to digital pin 8                                         **\n**   CSN - to digital pin 9   (SS pin)                              **\n**   IRQ - to digital pin 10  (IRQ pin)                             **\n**   MOSI - to digital pin 11 (MOSI pin)                            **\n**   MISO - to digital pin 12 (MISO pin)                            **\n**   CLK - to digital pin 13  (SCK pin)                             **\n*********************************************************************/\n\n#include &lt;SPI.h&gt;\n#include \"API.h\"\n#include \"nRF24L01.h\"\n\n//***************************************************\n#define TX_ADR_WIDTH    5   // 5 unsigned chars TX(RX) address width\n#define TX_PLOAD_WIDTH  32  // 32 unsigned chars TX payload\n\nunsigned char TX_ADDRESS[TX_ADR_WIDTH]  = \n{\n  0x34,0x43,0x10,0x10,0x01\n}; // Define a static TX address\n\nunsigned char rx_buf[TX_PLOAD_WIDTH] = {0}; // initialize value\nunsigned char tx_buf[TX_PLOAD_WIDTH] = {0};\n//***************************************************\nvoid setup() \n{\n  Serial.begin(9600);\n  pinMode(CE,  OUTPUT);\n  pinMode(CSN, OUTPUT);\n  pinMode(IRQ, INPUT);\n  SPI.begin();\n  delay(50);\n  init_io();                        // Initialize IO port\n  unsigned char sstatus=SPI_Read(STATUS);\n  Serial.println(\"*******************TX_Mode Start****************************\");\n  Serial.print(\"status = \");    \n  Serial.println(sstatus,HEX);     // There is read the mode\u2019s status register, the default value should be \u2018E\u2019\n  TX_Mode();                       // set TX mode\n}\n\nvoid loop() \n{\n  int k = 0;\n  for(;;)\n  {\n    for(int i=0; i&lt;32; i++)\n        tx_buf[i] = k++;        \n    unsigned char sstatus = SPI_Read(STATUS);                   // read register STATUS's value\n    if(sstatus&amp;TX_DS)                                           // if receive data ready (TX_DS) interrupt\n    {\n      SPI_RW_Reg(FLUSH_TX,0);                                  \n      SPI_Write_Buf(WR_TX_PLOAD,tx_buf,TX_PLOAD_WIDTH);       // write playload to TX_FIFO\n    }\n    if(sstatus&amp;MAX_RT)                                         // if receive data ready (MAX_RT) interrupt, this is retransmit than  SETUP_RETR                          \n    {\n      SPI_RW_Reg(FLUSH_TX,0);\n      SPI_Write_Buf(WR_TX_PLOAD,tx_buf,TX_PLOAD_WIDTH);      // disable standy-mode\n    }\n    SPI_RW_Reg(WRITE_REG+STATUS,sstatus);                     // clear RX_DR or TX_DS or MAX_RT interrupt flag\n    delay(1000);\n  }\n}\n\n//**************************************************\n// Function: init_io();\n// Description:\n// flash led one time,chip enable(ready to TX or RX Mode),\n// Spi disable,Spi clock line init high\n//**************************************************\nvoid init_io(void)\n{\n  digitalWrite(IRQ, 0);\n  digitalWrite(CE, 0);          // chip enable\n  digitalWrite(CSN, 1);                 // Spi disable  \n}\n\n/************************************************************************\n**   * Function: SPI_RW();\n * \n * Description:\n * Writes one unsigned char to nRF24L01, and return the unsigned char read\n * from nRF24L01 during write, according to SPI protocol\n************************************************************************/\nunsigned char SPI_RW(unsigned char Byte)\n{\n  return SPI.transfer(Byte);\n}\n\n/**************************************************/\n\n/**************************************************\n * Function: SPI_RW_Reg();\n * \n * Description:\n * Writes value 'value' to register 'reg'\n/**************************************************/\nunsigned char SPI_RW_Reg(unsigned char reg, unsigned char value)\n{\n  unsigned char status;\n\n  digitalWrite(CSN, 0);                   // CSN low, init SPI transaction\n  SPI_RW(reg);                            // select register\n  SPI_RW(value);                          // ..and write value to it..\n  digitalWrite(CSN, 1);                   // CSN high again\n\n  return(status);                   // return nRF24L01 status unsigned char\n}\n/**************************************************/\n\n/**************************************************\n * Function: SPI_Read();\n * \n * Description:\n * Read one unsigned char from nRF24L01 register, 'reg'\n/**************************************************/\nunsigned char SPI_Read(unsigned char reg)\n{\n  unsigned char reg_val;\n\n  digitalWrite(CSN, 0);                // CSN low, initialize SPI communication...\n  SPI_RW(reg);                         // Select register to read from..\n  reg_val = SPI_RW(0);                 // ..then read register value\n  digitalWrite(CSN, 1);                // CSN high, terminate SPI communication\n\n  return(reg_val);                     // return register value\n}\n/**************************************************/\n\n/**************************************************\n * Function: SPI_Read_Buf();\n * \n * Description:\n * Reads 'unsigned chars' #of unsigned chars from register 'reg'\n * Typically used to read RX payload, Rx/Tx address\n/**************************************************/\nunsigned char SPI_Read_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)\n{\n  unsigned char sstatus,i;\n\n  digitalWrite(CSN, 0);                   // Set CSN low, init SPI tranaction\n  sstatus = SPI_RW(reg);            // Select register to write to and read status unsigned char\n\n  for(i=0;i&lt;bytes;i++)\n  {\n    pBuf[i] = SPI_RW(0);    // Perform SPI_RW to read unsigned char from nRF24L01\n  }\n\n  digitalWrite(CSN, 1);                   // Set CSN high again\n\n  return(sstatus);                  // return nRF24L01 status unsigned char\n}\n/**************************************************/\n\n/**************************************************\n * Function: SPI_Write_Buf();\n * \n * Description:\n * Writes contents of buffer '*pBuf' to nRF24L01\n * Typically used to write TX payload, Rx/Tx address\n/**************************************************/\nunsigned char SPI_Write_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)\n{\n  unsigned char sstatus,i;\n\n  digitalWrite(CSN, 0);                   // Set CSN low, init SPI tranaction\n  sstatus = SPI_RW(reg);             // Select register to write to and read status unsigned char\n  for(i=0;i&lt;bytes; i++)             // then write all unsigned char in buffer(*pBuf)\n  {\n    SPI_RW(*pBuf++);\n  }\n  digitalWrite(CSN, 1);                   // Set CSN high again\n  return(sstatus);                  // return nRF24L01 status unsigned char\n}\n/**************************************************/\n\n/**************************************************\n * Function: TX_Mode();\n * \n * Description:\n * This function initializes one nRF24L01 device to\n * TX mode, set TX address, set RX address for auto.ack,\n * fill TX payload, select RF channel, datarate &amp; TX pwr.\n * PWR_UP is set, CRC(2 unsigned chars) is enabled, &amp; PRIM:TX.\n * \n * ToDo: One high pulse(&gt;10us) on CE will now send this\n * packet and expext an acknowledgment from the RX device.\n **************************************************/\nvoid TX_Mode(void)\n{\n  digitalWrite(CE, 0);\n\n  SPI_Write_Buf(WRITE_REG + TX_ADDR, TX_ADDRESS, TX_ADR_WIDTH);    // Writes TX_Address to nRF24L01\n  SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH); // RX_Addr0 same as TX_Adr for Auto.Ack\n\n  SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);      // Enable Auto.Ack:Pipe0\n  SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);  // Enable Pipe0\n  SPI_RW_Reg(WRITE_REG + SETUP_RETR, 0x1a); // 500us + 86us, 10 retrans...\n  SPI_RW_Reg(WRITE_REG + RF_CH, 40);        // Select RF channel 40\n  SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);   // TX_PWR:0dBm, Datarate:2Mbps, LNA:HCURR\n  SPI_RW_Reg(WRITE_REG + CONFIG, 0x0e);     // Set PWR_UP bit, enable CRC(2 unsigned chars) &amp; Prim:TX. MAX_RT &amp; TX_DS enabled..\n  SPI_Write_Buf(WR_TX_PLOAD,tx_buf,TX_PLOAD_WIDTH);\n\n  digitalWrite(CE, 1);\n} \n</code></pre> <p>3.Download the code below into the RX Arduino (receive) \u2013 This code will drive the nFR24L01 module to receive the data that transmit form the TX module and print it to serial port.</p> <pre><code>/** ******************************************************************\n**   SPI-compatible                                                 **\n**   CS -  to digital pin 8                                         **\n**   CSN - to digital pin 9   (SS pin)                              **\n**   IRQ - to digital pin 10  (IRQ pin)                             **\n**   MOSI - to digital pin 11 (MOSI pin)                            **\n**   MISO - to digital pin 12 (MISO pin)                            **\n**   CLK - to digital pin 13  (SCK pin)                             **\n*********************************************************************/\n\n#include &lt;SPI.h&gt;\n#include \"API.h\"\n#include \"nRF24L01.h\"\n\n//***************************************************\n#define TX_ADR_WIDTH    5   // 5 unsigned chars TX(RX) address width\n#define TX_PLOAD_WIDTH  32  // 32 unsigned chars TX payload\n\nunsigned char TX_ADDRESS[TX_ADR_WIDTH]  = \n{\n  0x34,0x43,0x10,0x10,0x01\n}; // Define a static TX address\n\nunsigned char rx_buf[TX_PLOAD_WIDTH] = {0}; // initialize value\nunsigned char tx_buf[TX_PLOAD_WIDTH] = {0};\n//***************************************************\nvoid setup() \n{\n  Serial.begin(9600);\n  pinMode(CE,  OUTPUT);\n  pinMode(CSN, OUTPUT);\n  pinMode(IRQ, INPUT);\n  SPI.begin();\n  delay(50);\n  init_io();                        // Initialize IO port\n  unsigned char sstatus=SPI_Read(STATUS);\n  Serial.println(\"*******************RX_Mode Start****************************\");\n  Serial.print(\"status = \");    \n  Serial.println(sstatus,HEX);     // There is read the mode\u2019s status register, the default value should be \u2018E\u2019\n  RX_Mode();                        // set RX mode\n}\n\nvoid loop() \n{\n  for(;;)\n  {\n    unsigned char status = SPI_Read(STATUS);                         // read register STATUS's value\n    if(status&amp;RX_DR)                                                 // if receive data ready (TX_DS) interrupt\n    {\n      SPI_Read_Buf(RD_RX_PLOAD, rx_buf, TX_PLOAD_WIDTH);             // read playload to rx_buf\n      SPI_RW_Reg(FLUSH_RX,0);                                        // clear RX_FIFO\n      for(int i=0; i&lt;32; i++)\n      {\n          Serial.print(\" \");\n          Serial.print(rx_buf[i],HEX);                              // print rx_buf\n      }\n      Serial.println(\" \");\n    }\n    SPI_RW_Reg(WRITE_REG+STATUS,status);                             // clear RX_DR or TX_DS or MAX_RT interrupt flag\n    delay(1000);\n  }\n}\n\n//**************************************************\n// Function: init_io();\n// Description:\n// flash led one time,chip enable(ready to TX or RX Mode),\n// Spi disable,Spi clock line init high\n//**************************************************\nvoid init_io(void)\n{\n  digitalWrite(IRQ, 0);\n  digitalWrite(CE, 0);          // chip enable\n  digitalWrite(CSN, 1);                 // Spi disable  \n}\n\n/************************************************************************\n**   * Function: SPI_RW();\n * \n * Description:\n * Writes one unsigned char to nRF24L01, and return the unsigned char read\n * from nRF24L01 during write, according to SPI protocol\n************************************************************************/\nunsigned char SPI_RW(unsigned char Byte)\n{\n  return SPI.transfer(Byte);\n}\n\n/**************************************************/\n\n/**************************************************\n * Function: SPI_RW_Reg();\n * \n * Description:\n * Writes value 'value' to register 'reg'\n/**************************************************/\nunsigned char SPI_RW_Reg(unsigned char reg, unsigned char value)\n{\n  unsigned char status;\n\n  digitalWrite(CSN, 0);                   // CSN low, init SPI transaction\n  SPI_RW(reg);                            // select register\n  SPI_RW(value);                          // ..and write value to it..\n  digitalWrite(CSN, 1);                   // CSN high again\n\n  return(status);                   // return nRF24L01 status unsigned char\n}\n/**************************************************/\n\n/**************************************************\n * Function: SPI_Read();\n * \n * Description:\n * Read one unsigned char from nRF24L01 register, 'reg'\n/**************************************************/\nunsigned char SPI_Read(unsigned char reg)\n{\n  unsigned char reg_val;\n\n  digitalWrite(CSN, 0);                // CSN low, initialize SPI communication...\n  SPI_RW(reg);                         // Select register to read from..\n  reg_val = SPI_RW(0);                 // ..then read register value\n  digitalWrite(CSN, 1);                // CSN high, terminate SPI communication\n\n  return(reg_val);                     // return register value\n}\n/**************************************************/\n\n/**************************************************\n * Function: SPI_Read_Buf();\n * \n * Description:\n * Reads 'unsigned chars' #of unsigned chars from register 'reg'\n * Typically used to read RX payload, Rx/Tx address\n/**************************************************/\nunsigned char SPI_Read_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)\n{\n  unsigned char sstatus,i;\n\n  digitalWrite(CSN, 0);                   // Set CSN low, init SPI tranaction\n  sstatus = SPI_RW(reg);            // Select register to write to and read status unsigned char\n\n  for(i=0;i&lt;bytes;i++)\n  {\n    pBuf[i] = SPI_RW(0);    // Perform SPI_RW to read unsigned char from nRF24L01\n  }\n\n  digitalWrite(CSN, 1);                   // Set CSN high again\n\n  return(sstatus);                  // return nRF24L01 status unsigned char\n}\n/**************************************************/\n\n/**************************************************\n * Function: SPI_Write_Buf();\n * \n * Description:\n * Writes contents of buffer '*pBuf' to nRF24L01\n * Typically used to write TX payload, Rx/Tx address\n/**************************************************/\nunsigned char SPI_Write_Buf(unsigned char reg, unsigned char *pBuf, unsigned char bytes)\n{\n  unsigned char sstatus,i;\n\n  digitalWrite(CSN, 0);                   // Set CSN low, init SPI tranaction\n  sstatus = SPI_RW(reg);             // Select register to write to and read status unsigned char\n  for(i=0;i&lt;bytes; i++)             // then write all unsigned char in buffer(*pBuf)\n  {\n    SPI_RW(*pBuf++);\n  }\n  digitalWrite(CSN, 1);                   // Set CSN high again\n  return(sstatus);                  // return nRF24L01 status unsigned char\n}\n/**************************************************/\n\nvoid RX_Mode(void)\n{\n  digitalWrite(CE, 0);\n\n  SPI_Write_Buf(WRITE_REG + RX_ADDR_P0, TX_ADDRESS, TX_ADR_WIDTH); // Use the same address on the RX device as the TX device\n  SPI_RW_Reg(WRITE_REG + EN_AA, 0x01);      // Enable Auto.Ack:Pipe0\n  SPI_RW_Reg(WRITE_REG + EN_RXADDR, 0x01);  // Enable Pipe0\n  SPI_RW_Reg(WRITE_REG + RF_CH, 40);        // Select RF channel 40\n  SPI_RW_Reg(WRITE_REG + RX_PW_P0, TX_PLOAD_WIDTH); // Select same RX payload width as TX Payload width\n  SPI_RW_Reg(WRITE_REG + RF_SETUP, 0x07);   // TX_PWR:0dBm, Datarate:2Mbps, LNA:HCURR\n  SPI_RW_Reg(WRITE_REG + CONFIG, 0x0f);     // Set PWR_UP bit, enable CRC(2 unsigned chars) &amp; Prim:RX. RX_DR enabled..\n  digitalWrite(CE, 1);                             // Set CE pin high to enable RX device\n  //  This device is now ready to receive one packet of 16 unsigned chars payload from a TX device sending to address\n  //  '3443101001', with auto acknowledgment, retransmit count of 10, RF channel 40 and datarate = 2Mbps.\n} \n</code></pre> <p>4.Now power on both Arduino , and connect the RX one to PC via USB. Open the IDE serial port monitor , change the baud rate to 9600 bps , and you can see the data that received. </p>"},{"location":"Products/Wireless/315433mhz-rf-link-kit.html","title":"315/433Mhz RF Link Kit","text":""},{"location":"Products/Wireless/315433mhz-rf-link-kit.html#introduction","title":"Introduction","text":"<p>The 315/433MHz RF link kit is consisted of transmitter and receiver, popular used for remote control. It will be easy to use this kit to transmit data via RF With the suggestArduino VirtualWire library. Model: WRF43301R WRF31501R </p> <p></p>"},{"location":"Products/Wireless/315433mhz-rf-link-kit.html#specification","title":"Specification","text":"<ul> <li>Frequency: 315/433Mhz</li> <li>Modulation: ASK</li> <li>Receiver Data Output: High - \u00bd Vcc, Low - 0.7v</li> <li>Transmitor Input Voltage: 3-12V (high voltage = more transmitting power)</li> </ul>"},{"location":"Products/Wireless/315433mhz-rf-link-kit.html#usage","title":"Usage","text":""},{"location":"Products/Wireless/315433mhz-rf-link-kit.html#hardware","title":"Hardware","text":"<p>There are one transmitter and one receiver in this kit, you will needs 2 arduino main board in your application. one for coding and senting the message, with the RF transmitter, the other one for receiving message and decoding. the whole system working as belows:  </p>"},{"location":"Products/Wireless/315433mhz-rf-link-kit.html#programming","title":"Programming","text":"<p>with the virtualwire arduino library,please refer to how to install library and upload program, it would be easy to transmit data or message from the transmitter to receiver. on the transmitter, After connecting the transmitter data pin to arduino D2 and installing the virtualwire library, program the arduino as below:</p> <pre><code>#include &lt;VirtualWire.h&gt;\nint RF_TX_PIN = 2;\nvoid setup()\n{\n  vw_set_tx_pin(RF_TX_PIN); // Setup transmit pin\n  vw_setup(2000); // Transmission speed in bits per second.\n}\n\nvoid loop()\n{\n  const char *msg = \"hi,RFlink\";\n  vw_send((uint8_t *)msg, strlen(msg));  // Send 'hello' every 400ms.\n  delay(400);\n}\n</code></pre> <p>on the receiver, After connecting the receiver data pin to arduino D2 and installing the virtualwire library, program the arduino as below:</p> <pre><code>#include &lt;VirtualWire.h&gt; \nint RF_RX_PIN = 2;\nvoid setup()\n{\n  Serial.begin(9600);//init the UART between arduino and PC\n  Serial.println(\"setup\");\n  vw_set_rx_pin(RF_RX_PIN); \n  vw_setup(2000); // Transmission speed in bits per second.\n  vw_rx_start(); // Start the PLL receiver.\n}\n\nvoid loop()\n{\n  uint8_t buf[VW_MAX_MESSAGE_LEN];\n  uint8_t buflen = VW_MAX_MESSAGE_LEN;\n  if(vw_get_message(buf, &amp;buflen)) // non-blocking I/O\n  {\n    int i;\n    // Message with a good checksum received, dump HEX\n    Serial.print(\"Got: \");\n    for(i = 0; i &lt; buflen; ++i)\n    {\n    // Serial.write(buf[i]);//print the received message to the serial\n    }\n    Serial.println(\"\");\n  }\n}\n</code></pre>"},{"location":"Products/Wireless/315433mhz-rf-link-kit.html#resource","title":"Resource","text":"<p>File:Virtualwire.zip Virtualwire Introduction</p>"},{"location":"Products/Wireless/433mhz-rf-transceiver-cc1101-module.html","title":"433MHz RF Transceiver CC1101 Module","text":""},{"location":"Products/Wireless/433mhz-rf-transceiver-cc1101-module.html#introduction","title":"Introduction","text":"<p>The CC1101 is a low-cost sub- 1 GHz transceiver designed for very low-power wireless applications. The circuit is mainly intended for the ISM (Industrial, Scientific and Medical) and SRD (Short Range Device) frequency bands at 315, 433, 868, and 915 MHz, but can easily be programmed for operation at otherfrequencies in the 300-348 MHz, 387-464 MHz and 779-928 MHz bands.</p> <p>Model: WRF11010R </p> <p></p>"},{"location":"Products/Wireless/433mhz-rf-transceiver-cc1101-module.html#features","title":"Features:","text":"<ul> <li>Input voltage :3.3V</li> <li>Maximum operating speed: 500kbps, support 2-FSK, GFSK and MSK modulation</li> <li>Can be modify the baud rate, power, frequency and other related parameters by software</li> <li>High sensitivity (&lt;1.2kbps -110dDm, 0.1% packet error rate)</li> <li>CRC error detection and built-in hardware address multipoint communication control</li> <li>Lower current consumption (RX, 15.6mA; 2.4kbps, 433MHz)</li> <li>Programmable control of output power, maximum output power of +10dBm</li> <li>Standard 2.0mm DIP pitch interfaces for embedded applications</li> <li>Separate 64-byte RX and TX data FIFO</li> <li>Transmission distance: 300 - 500 meters (Depending on the specific situation of the environment and communication baud rate, etc.)</li> </ul>"},{"location":"Products/Wireless/433mhz-rf-transceiver-cc1101-module.html#usage","title":"Usage","text":"<p>1.Hardware connection  2.Download the code below into the TX Arduino (transmit) \u2014 This code will drive the 433MHz RF Transceiver CC1101 module to send out data form 0 to 10.</p> <pre><code>#include &lt;ELECHOUSE_CC1101.h&gt;\n\n#define size 11\n\nbyte TX_buffer[size]={0};\nbyte i;\n\nvoid setup()\n{\n  Serial.begin(9600);\n  ELECHOUSE_cc1101.Init();\n  for(i=0;i&lt;size;i++)\n  {\n     TX_buffer[i]=i;\n  }\n}\n\nvoid loop()\n{\n  ELECHOUSE_cc1101.SendData(TX_buffer,size);\n  delay(1);\n}\n</code></pre> <p>3.Download the code below into the RX Arduino (receive) \u2013 This code will drive the 433MHz RF Transceiver CC1101 module to receive the data that transmit form the TX module and print it to serial port.</p> <pre><code> #include &lt;ELECHOUSE_CC1101.h&gt;\n\n void setup()\n{\n  Serial.begin(9600);\n  ELECHOUSE_cc1101.Init();\n  ELECHOUSE_cc1101.SetReceive();\n}\n\nbyte RX_buffer[11]={0};\nbyte size,i,flag;\n\nvoid loop()\n{\n  if(ELECHOUSE_cc1101.CheckReceiveFlag())\n  {\n    size=ELECHOUSE_cc1101.ReceiveData(RX_buffer);\n    for(i=0;i&lt;size;i++)\n    {\n      Serial.print(RX_buffer[i],DEC);\n      Serial.print(\"  \");\n    }\n    Serial.println(\"\");\n    ELECHOUSE_cc1101.SetReceive();\n  }\n}\n</code></pre> <p>4.Now power on both Arduino , and connect the RX one to PC via USB. Open the IDE serial port monitor , change the baud rate to 9600 bps , and you can see the data that received. </p>"},{"location":"Products/Wireless/433mhz-rf-transceiver-cc1101-module.html#resource","title":"Resource","text":"<ul> <li>CC101 module demo code for Arduino</li> <li>CC101 module demo code for Arduino of panstamp</li> </ul>"},{"location":"Products/Wireless/433mhz-rf-transceiver-cc1101-module.html#related-links","title":"Related links","text":"<p>Click here to buy 433MHz RF Transceiver CC1101 Module</p>"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html","title":"CrowBot-BOLT Programmable Smart Robot Car STEAM Robot Kit","text":""},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#description","title":"Description","text":"<p>CrowBot BOLT is a programmable educational car that can be easily used. It is small and beautiful in shape and easy to install. It uses ESP32-WROVER-B as the MCU, with Bluetooth and WiFi functions. It has a wealth of sensors(such as photodiode, ultrasonic sensor, line Tracking Sensor), can quickly realize functions such as light chasing, line tracking, obstacle avoidance, remote control, and light show.  As an entry-level ESP32 programmed educational robot, the cool and cute Bolt makes robot programming learning, and teaching easy and fun. It comes with 16 lessons in three languages (Letscode, Ardunio, MicroPython), provides rich programming, and allows programming beginner to learn to program in the fun of creativity. It has reserved 2 expansion interfaces, which can be expanded and used with 150+ kinds of Crowtail modules. Unlimited creativity, waiting for you to discover!</p> <p>Model: CRB00157C </p> <p> </p>"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#features","title":"Features","text":"<ul> <li>Support for Letscode, Arduino and Python</li> <li>Can be controlled by IR remote control, Bluetooth/WiFi control</li> <li>The car is equipped with ultrasonic, infrared tracking, photodiode and other sensors</li> <li>With 16 courses, it is the best choice for the entry of ESP32</li> <li>Equipped with on board indicator LED , through which you can intuitively understand the working condition of the car</li> <li>4Pin I2C and A/D ports are reserved to connect Crowtail sensors, creating more possibilities</li> <li>Compatible with CrowBot Joystick, provides various methods to play</li> </ul>"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#specifications","title":"Specifications","text":"Item Description MCU ESP32-WROVER-B\uff088MB\uff09 Programmatically Letscode\uff0cArdunio\uff0cMicropython Control method Bluetooth Remote Control/Infrared Remote Control Input Button, Photodiode, Infrared Receiving Module, Ultrasonic Sensor, Line Tracking Sensor Output Buzzer, Programmable RGB_LED, Motor Wifi&amp;Bluetooth Supported Photodiode Can realize the function of chasing light or avoiding light Ultrasonic Sensor(with RGB; 4Pin interface) When an obstacle is detected, the driving route of the car can be corrected to avoid the obstacle RPR220 Line Tracking Sensor Can make the car move along the dark/black lines, intelligently judge and correct the driving path Buzzer Can make the car sing, bringing a more direct sensory experience Programmable RGB_LED Through programming, it can show colorful lights in different scenes Infrared receiver(3Pin interface) Receive infrared remote control signals to realize remote control Interface Type c x1\uff0cI2C port x1\uff0cA/D port x1 Motor type N20 Gear Motor(drive: L9110S) Operating Voltage 3.3V~5V(AAA battery x4) Work Temperature -10\u2103~+55\u2103 Dimension 128*92*64mm Weight 200g"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#io-port-diagram","title":"IO Port Diagram","text":""},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#top-overview","title":"Top Overview","text":""},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#bottom-overview","title":"Bottom Overview","text":""},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#usage","title":"Usage","text":""},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#crowbot-bolt-assambly-instrustion","title":"CrowBot-BOLT Assambly Instrustion","text":"<p>STEP 1: Preparation STEP 2: Install battery holder Install 4 AAA batteries into the battery holder, and plug the cable of the battery holder into the 2pin battery(BAT) interface on the chassis.  STEP 3: Install acrylic plates STEP 4: Mounting wheels STEP 5: Connect ultrasonic sensor Insert the 4pin ultrasonic sensor into ultrasonic module interface on the chassis.  </p> <p>STEP 6: Finish! </p>"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#factory-procedures","title":"Factory Procedures","text":"<p>The factory default program has been loaded and you can play with CrowBot out of the box. But if you need to re-flash the program, please download Factory_source_code.zip to re-upload the factory default program. The folder contains a tutorial on how to set the Arduino for ESP32. </p>"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#programming","title":"Programming","text":"<p>Play with Python</p> <p> Please download Python_Lessons_Code.zip. The folder contains 16 Python Lessons code, firmware and tutorial. Play with Arduino</p> <p> Please download Arduino_Lessons_Code.zip. The folder contains 16 Arduino Lessons code, library needed and tutorial. Play with Letscode</p> <p> Please download Letscode_Lessons_Code.zip.  </p>"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#faqs","title":"FAQS","text":"<p>Q1: How to connect CrowBot with Joystick via Bluetooth? A1: Turn on the Bluetooth switch on CrowBot board.</p> <p> Q2: How to re-upload the factory default code to CrowBot and joystick? A2: 1. The factory default program files are ino files. Please download Factory_source_code.zip to re-upload the factory default program. The folder contains a tutorial on how to set the Arduino for ESP32.</p> <p>Q3: Is there any WiFi connection tutorial or code? A3: We didn't write the code to realize WiFi control function, you can DIY a project to make it come true.</p> <p>You can post your questions on our forum or contact with techsupport@elecrow.com for technology support.</p>"},{"location":"Products/Wireless/crowbot-bolt-programmable-smart-robot-car-steam-robot-kit.html#resources","title":"Resources","text":"<p>Crowbot_BOLT_Beginner's_Guide.pdf Python_Lessons_Code.zip Arduino_Lessons_Code.zip Letscode_Lessons_Code.zip Factory_Source_Code.zip CrowBot-BOLT_Schematic.pdf CrowBot-BOLT_Eagle file_SCH&amp;PCB Joystick_for_Crowbot_Eagle file_SCH&amp;PCB CrowBot-BOLT_Structural_3D_Model_stp.zip</p>"},{"location":"blog/index.html","title":"Blog","text":""},{"location":"files/2.0inch-SPI-Arduino-Demo-zip.html","title":"File:2.0inch SPI Arduino Demo.zip","text":""},{"location":"files/2.0inch-SPI-Arduino-Demo-zip.html#file","title":"File","text":"<p>2.0inch SPI Arduino Demo.zip (file size: 4.14 MB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/2.0inch-SPI-Arduino-Demo-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 02:37, 22 June 2022 (4.14 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/2.0inch-SPI-Arduino-Demo-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/2.8%27TFT-Program-Files-zip.html","title":"File:2.8'TFT Program Files.zip","text":""},{"location":"files/2.8%27TFT-Program-Files-zip.html#file","title":"File","text":"<p>2.8'TFT_Program_Files.zip (file size: 604 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/2.8%27TFT-Program-Files-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:16, 6 June 2022 (604 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/2.8%27TFT-Program-Files-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/24unosch-pdf.html","title":"File:2.4unosch.pdf","text":""},{"location":"files/24unosch-pdf.html#file","title":"File","text":"<p>2.4unosch.pdf (file size: 11 KB, MIME type: application/pdf)</p>"},{"location":"files/24unosch-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:14, 6 June 2022 (11 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/24unosch-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/32U4-with-A7-test-zip.html","title":"File:32U4 with A7 test.zip","text":""},{"location":"files/32U4-with-A7-test-zip.html#file","title":"File","text":"<p>32U4_with_A7_test.zip (file size: 1 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/32U4-with-A7-test-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 06:49, 23 August 2019 (87 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/32U4-with-A7-test-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/32U4-with-A9-eagle-files-zip.html","title":"File:32U4 with A9 eagle files.zip","text":""},{"location":"files/32U4-with-A9-eagle-files-zip.html#file","title":"File","text":"<p>32U4_with_A9_eagle_files.zip (file size: 73 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/32U4-with-A9-eagle-files-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:19, 24 August 2019 (73 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/32U4-with-A9-eagle-files-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/32U4-with-A9-test-zip.html","title":"File:32U4 with A9 test.zip","text":""},{"location":"files/32U4-with-A9-test-zip.html#file","title":"File","text":"<p>32U4_with_A9_test.zip (file size: 387 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/32U4-with-A9-test-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:59, 23 August 2019 (387 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/32U4-with-A9-test-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/32u4-with-A6-GPRSGSM-zip.html","title":"File:32u4 with A6 GPRSGSM.zip","text":""},{"location":"files/32u4-with-A6-GPRSGSM-zip.html#file","title":"File","text":"<p>32u4_with_A6_GPRSGSM.zip (file size: 87 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/32u4-with-A6-GPRSGSM-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 11:02, 22 August 2019 (87 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/32u4-with-A6-GPRSGSM-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/32u4-with-A7-GPRS-GSM-GPS-eagle-file-zip.html","title":"File:32u4 with A7 GPRS GSM GPS eagle file.zip","text":""},{"location":"files/32u4-with-A7-GPRS-GSM-GPS-eagle-file-zip.html#file","title":"File","text":"<p>32u4_with_A7_GPRS_GSM_GPS_eagle_file.zip (file size: 83 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/32u4-with-A7-GPRS-GSM-GPS-eagle-file-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:12, 23 August 2019 (83 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/32u4-with-A7-GPRS-GSM-GPS-eagle-file-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/32u4-with-A9G-GPS-test-step-pdf.html","title":"File:32u4 with A9G GPS test step.pdf","text":""},{"location":"files/32u4-with-A9G-GPS-test-step-pdf.html#file","title":"File","text":"<p>32u4_with_A9G_GPS_test_step.pdf (file size: 3.68 MB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/32u4-with-A9G-GPS-test-step-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 06:20, 14 January 2020 (3.68 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/32u4-with-A9G-GPS-test-step-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/4-Channel-I2C-Motor-Shield-V1.1-Example-zip.html","title":"File:4 Channel I2C Motor Shield-V1.1-Example.zip","text":""},{"location":"files/4-Channel-I2C-Motor-Shield-V1.1-Example-zip.html#file","title":"File","text":"<p>4 Channel I2C Motor Shield-V1.1-Example.zip (file size: 25 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/4-Channel-I2C-Motor-Shield-V1.1-Example-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:36, 26 October 2021 (25 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/4-Channel-I2C-Motor-Shield-V1.1-Example-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/4-Channel-I2C-Motor-Shield-V1.1-SCH.html","title":"File:4 Channel I2C Motor Shield-V1.1-SCH","text":""},{"location":"files/4-Channel-I2C-Motor-Shield-V1.1-SCH.html#file","title":"File","text":"<p>No file by this name exists.</p>"},{"location":"files/4-Channel-I2C-Motor-Shield-V1.1-SCH.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/5inch-HDMI-Display-User-Manual-pdf.html","title":"File:5inch HDMI Display User Manual.pdf","text":""},{"location":"files/5inch-HDMI-Display-User-Manual-pdf.html#file","title":"File","text":"<p>No file by this name exists.</p>"},{"location":"files/5inch-HDMI-Display-User-Manual-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/80-Infrare-Datasheet-pdf.html","title":"File:80 Infrared Datasheet.pdf","text":""},{"location":"files/80-Infrare-Datasheet-pdf.html#file","title":"File","text":"<p>80_Infrared_Datasheet.pdf  (file size: 365 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/80-Infrare-Datasheet-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:52, 23 August 2019 (365 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/80-Infrare-Datasheet-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/80-Infrared-Arduino-Demo-zip.html","title":"File:80 Infrared Arduino Demo.zip","text":""},{"location":"files/80-Infrared-Arduino-Demo-zip.html#file","title":"File","text":"<p>80_Infrared_Arduino_Demo.zip  (file size: 710 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/80-Infrared-Arduino-Demo-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:26, 26 August 2019 (710 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/80-Infrared-Arduino-Demo-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/A7-%28GSM%2BGPS%2BGPRS%2BGPRS%29-module-Hardware-introduction-pdf.html","title":"File:A7 (GSM+GPS+GPRS+GPRS) module Hardware introduction .pdf","text":""},{"location":"files/A7-%28GSM%2BGPS%2BGPRS%2BGPRS%29-module-Hardware-introduction-pdf.html#file","title":"File","text":"<p>A7_(GSM+GPS+GPRS+GPRS)module_Hardware_introduction.pdf (file size: 256 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/A7-%28GSM%2BGPS%2BGPRS%2BGPRS%29-module-Hardware-introduction-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 07:08, 23 August 2019 (256 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/A7-%28GSM%2BGPS%2BGPRS%2BGPRS%29-module-Hardware-introduction-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/ACS712-pdf.html","title":"File:ACS712.pdf","text":""},{"location":"files/ACS712-pdf.html#file","title":"File","text":"<p>No file by this name exists.</p>"},{"location":"files/ACS712-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/ACS712-zip.html","title":"File:ACS712.zip","text":""},{"location":"files/ACS712-zip.html#file","title":"File","text":"<p>ACS712.zip (file size: 520 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/ACS712-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 09:47, 23 August 2019 (520 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/ACS712-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/AcceleroMMA7361-v0.8b-zip.html","title":"File:AcceleroMMA7361 v0.8b.zip","text":""},{"location":"files/AcceleroMMA7361-v0.8b-zip.html#file","title":"File","text":"<p>AcceleroMMA7361_v0.8b.zip (file size: 92 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/AcceleroMMA7361-v0.8b-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:27, 26 August 2019 (92 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/AcceleroMMA7361-v0.8b-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Analog-Gyro-3-Axis-zip.html","title":"File:Analog Gyro 3 Axis.zip","text":""},{"location":"files/Analog-Gyro-3-Axis-zip.html#file","title":"File","text":"<p>Analog Gyro 3 Axis.zip (file size: 948 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Analog-Gyro-3-Axis-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:21, 24 August 2019 (948 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Analog-Gyro-3-Axis-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Analog-Gyro-Axis-zip.html","title":"File:Analog Gyro 2 Axis.zip","text":""},{"location":"files/Analog-Gyro-Axis-zip.html#file","title":"File","text":"<p>Analog_Gyro_2_Axis.zip (file size: 901 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Analog-Gyro-Axis-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 09:57, 23 August 2019 (901 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Analog-Gyro-Axis-zip.html#file-usage","title":"File usage","text":"<p>The following file is a duplicate of this file (more details):</p> <ul> <li>File:Serial Camera software.zip</li> </ul> <p>There are no pages that use this file.</p>"},{"location":"files/Analog-Gyro-zip.html","title":"File:Analog Gyro.zip","text":""},{"location":"files/Analog-Gyro-zip.html#file","title":"File","text":"<p>Analog_Gyro.zip (file size: 754 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Analog-Gyro-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:52, 23 August 2019 (754 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Analog-Gyro-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Arduino-Demo-code-ArduinoUNO%26Mega2560-zip.html","title":"File:Arduino Demo code ArduinoUNO&Mega2560.zip","text":""},{"location":"files/Arduino-Demo-code-ArduinoUNO%26Mega2560-zip.html#file","title":"File","text":"<p>Arduino_Demo_code_ArduinoUNO&amp;Mega2560.zip (file size: 2.47 MB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Arduino-Demo-code-ArduinoUNO%26Mega2560-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:03, 6 June 2022 (2.47 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Arduino-Demo-code-ArduinoUNO%26Mega2560-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Arduino-Demo-for-16x16-LED-zip.html","title":"File:Arduino Demo for 16x 16 LED.zip","text":""},{"location":"files/Arduino-Demo-for-16x16-LED-zip.html#file","title":"File","text":"<p>Arduino_Demo_for_16x_16_LED.zip (file size: 45 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Arduino-Demo-for-16x16-LED-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 11:14, 22 August 2019 (45 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Arduino-Demo-for-16x16-LED-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Barometer-zip.html","title":"File:Barometer.zip","text":""},{"location":"files/Barometer-zip.html#file","title":"File","text":"<p>Barometer.zip (file size: 4 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Barometer-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:13, 23 August 2019 (4 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Barometer-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/CAN-BUS-Shield-master-zip.html","title":"File:CAN BUS Shield master.zip","text":""},{"location":"files/CAN-BUS-Shield-master-zip.html#file","title":"File","text":"<p>CAN_BUS_Shield_master.zip (file size: 25 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/CAN-BUS-Shield-master-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:22, 23 August 2019 (25 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/CAN-BUS-Shield-master-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/CC1101-zip.html","title":"File:CC1101.zip","text":""},{"location":"files/CC1101-zip.html#file","title":"File","text":"<p>CC1101.zip (file size: 7 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/CC1101-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 07:00, 24 August 2019 (7 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/CC1101-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/CC3000-Library-zip.html","title":"File:CC3000 Library.zip","text":""},{"location":"files/CC3000-Library-zip.html#file","title":"File","text":"<p>CC3000_Library.zip (file size: 237 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/CC3000-Library-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 02:51, 24 August 2019 (237 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/CC3000-Library-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/CC3000-Module-pdf.html","title":"File:CC3000 Module.pdf","text":""},{"location":"files/CC3000-Module-pdf.html#file","title":"File","text":"<p>CC3000_Module.pdf (file size: 615 KB, MIME type: application/pdf)</p>"},{"location":"files/CC3000-Module-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:33, 5 August 2021 (615 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/CC3000-Module-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Config-zip.html","title":"File:Config.zip","text":""},{"location":"files/Config-zip.html#file","title":"File","text":"<p>Config.zip (file size: 1,023 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Config-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:56, 23 August 2019 (1,023 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Config-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Crazepony-5.2-ble-fc-0929-6f07e60-hex-zip.html","title":"File:Crazepony-5.2-ble-fc-0929-6f07e60-hex.zip","text":""},{"location":"files/Crazepony-5.2-ble-fc-0929-6f07e60-hex-zip.html#file","title":"File","text":"<p>Crazepony-5.2-ble-fc-0929-6f07e60-hex.zip (file size: 61 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Crazepony-5.2-ble-fc-0929-6f07e60-hex-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:13, 23 August 2019 (61 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Crazepony-5.2-ble-fc-0929-6f07e60-hex-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Crazepony-5.2-ble-zip.html","title":"File:Crazepony 5.2 ble.zip","text":""},{"location":"files/Crazepony-5.2-ble-zip.html#file","title":"File","text":"<p>Crazepony_5.2_ble.zip (file size: 44 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Crazepony-5.2-ble-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:36, 24 August 2019 (44 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Crazepony-5.2-ble-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Crazepony-Datasheet-zip.html","title":"File:Crazepony Datasheet.zip","text":""},{"location":"files/Crazepony-Datasheet-zip.html#file","title":"File","text":"<p>Crazepony_Datasheet.zip (file size: 5.88 MB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Crazepony-Datasheet-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 09:12, 26 August 2019 (5.88 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Crazepony-Datasheet-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Crazepony-Schematic-zip.html","title":"File:Crazepony Schematic.zip","text":""},{"location":"files/Crazepony-Schematic-zip.html#file","title":"File","text":"<p>Crazepony_Schematic.zip (file size: 69 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Crazepony-Schematic-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:22, 23 August 2019 (69 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Crazepony-Schematic-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Crazepony-firmware-none-5.2-ble-zip.html","title":"File:Crazepony-firmware-none-5.2-ble.zip","text":""},{"location":"files/Crazepony-firmware-none-5.2-ble-zip.html#file","title":"File","text":"<p>Crazepony-firmware-none-5.2-ble.zip (file size: 424 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Crazepony-firmware-none-5.2-ble-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:35, 23 August 2019 (424 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Crazepony-firmware-none-5.2-ble-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/CrazeponyV5.1-GUI-zip.html","title":"File:CrazeponyV5.1 GUI.zip","text":""},{"location":"files/CrazeponyV5.1-GUI-zip.html#file","title":"File","text":"<p>CrazeponyV5.1_GUI.zip (file size: 267 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/CrazeponyV5.1-GUI-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:25, 26 August 2019 (267 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/CrazeponyV5.1-GUI-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/DFRobot-ID809-master-zip.html","title":"File:DFRobot ID809-master.zip","text":""},{"location":"files/DFRobot-ID809-master-zip.html#file","title":"File","text":"<p>DFRobot_ID809-master.zip (file size: 31 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/DFRobot-ID809-master-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:20, 26 August 2022 (31 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/DFRobot-ID809-master-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/ELE-AVR-ISP-Sheld-pdf.html","title":"File:ELE-AVR ISP-Sheld.pdf","text":""},{"location":"files/ELE-AVR-ISP-Sheld-pdf.html#file","title":"File","text":"<p>ELE-AVR_ISP-Sheld.pdf (file size: 63 KB, MIME type: application/pdf)</p>"},{"location":"files/ELE-AVR-ISP-Sheld-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 02:31, 24 August 2019 (63 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/ELE-AVR-ISP-Sheld-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/ENC-03-pdf.html","title":"File:ENC-03.pdf","text":""},{"location":"files/ENC-03-pdf.html#file","title":"File","text":"<p>No file by this name exists.</p>"},{"location":"files/ENC-03-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Elecrow-partner-v12-pdf.html","title":"File:Elecrow partner v1.2.pdf","text":""},{"location":"files/Elecrow-partner-v12-pdf.html#file","title":"File","text":"<p>Elecrow_partner_v1.2.pdf (file size: 289 KB, MIME type: application/pdf)</p>"},{"location":"files/Elecrow-partner-v12-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 07:01, 5 March 2021 (289 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Elecrow-partner-v12-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Gas-Sensor-MQ2-zip.html","title":"File:Gas Sensor MQ2.zip","text":""},{"location":"files/Gas-Sensor-MQ2-zip.html#file","title":"File","text":"<p>Gas_Sensor_MQ2.zip (file size: 177 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Gas-Sensor-MQ2-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:17, 23 August 2019 (177 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Gas-Sensor-MQ2-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Gas-Sensor-MQ9-zip.html","title":"File:Gas Sensor MQ9.zip","text":""},{"location":"files/Gas-Sensor-MQ9-zip.html#file","title":"File","text":"<p>Gas_Sensor_MQ9.zip (file size: 2 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Gas-Sensor-MQ9-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:46, 24 August 2019 (2 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Gas-Sensor-MQ9-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/How-to-calibrate-the-resistance-touch-screen-pdf.html","title":"File:How to calibrate the resistance touch screen.pdf","text":""},{"location":"files/How-to-calibrate-the-resistance-touch-screen-pdf.html#file","title":"File","text":"<p>How_to_calibrate_the_resistance_touch_screen.pdf (file size: 659 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/How-to-calibrate-the-resistance-touch-screen-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:51, 19 October 2021 (659 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/How-to-calibrate-the-resistance-touch-screen-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/ID%E4%B8%89%E8%83%BD1016C%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E8%A7%84%E6%A0%BC%E4%B9%A6-pdf.html","title":"File:ID\u4e09\u80fd1016C\u6307\u7eb9\u6a21\u5757\u89c4\u683c\u4e66.pdf","text":""},{"location":"files/ID%E4%B8%89%E8%83%BD1016C%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E8%A7%84%E6%A0%BC%E4%B9%A6-pdf.html#file","title":"File","text":"<p>ID\u4e09\u80fd1016C\u6307\u7eb9\u6a21\u5757\u89c4\u683c\u4e66.pdf (file size: 386 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/ID%E4%B8%89%E8%83%BD1016C%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E8%A7%84%E6%A0%BC%E4%B9%A6-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current [10:26, 26 August 2022](ID\u4e09\u80fd1016C\u6307\u7eb9\u6a21\u5757\u89c4\u683c\u4e66.pdf (file size: 386 KB, MIME type: application/pdf) ) (386 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/ID%E4%B8%89%E8%83%BD1016C%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E8%A7%84%E6%A0%BC%E4%B9%A6-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/ID%E4%B8%89%E8%83%BD%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%28%E6%8C%87%E4%BB%A4%E9%9B%86B%29-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C-V3.0%281%29-pdf.html","title":"File:ID\u4e09\u80fd\u6307\u7eb9\u6a21\u5757\u901a\u8baf\u534f\u8bae\uff08\u6307\u4ee4\u96c6B\uff09\u4f7f\u7528\u624b\u518c-V3.0 (1).pdf","text":""},{"location":"files/ID%E4%B8%89%E8%83%BD%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%28%E6%8C%87%E4%BB%A4%E9%9B%86B%29-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C-V3.0%281%29-pdf.html#file","title":"File","text":"<p>ID\u4e09\u80fd\u6307\u7eb9\u6a21\u5757\u901a\u8baf\u534f\u8bae\uff08\u6307\u4ee4\u96c6B\uff09\u4f7f\u7528\u624b\u518c-V3.0_(1).pdf (file size: 4.58 MB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/ID%E4%B8%89%E8%83%BD%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%28%E6%8C%87%E4%BB%A4%E9%9B%86B%29-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C-V3.0%281%29-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:28, 26 August 2022 (4.58 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/ID%E4%B8%89%E8%83%BD%E6%8C%87%E7%BA%B9%E6%A8%A1%E5%9D%97%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE%28%E6%8C%87%E4%BB%A4%E9%9B%86B%29-%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C-V3.0%281%29-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/ILI9341-Datasheet-pdf.html","title":"File:ILI9341 Datasheet.pdf","text":""},{"location":"files/ILI9341-Datasheet-pdf.html#file","title":"File","text":"<p>ILI9341_Datasheet.pdf (file size: 3.41 MB, MIME type: application/pdf)</p>"},{"location":"files/ILI9341-Datasheet-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:13, 6 June 2022 (3.41 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/ILI9341-Datasheet-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/LCD-show-zip.html","title":"File:LCD-show.zip","text":""},{"location":"files/LCD-show-zip.html#file","title":"File","text":"<p>LCD-show.zip (file size: 4.53 MB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/LCD-show-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 06:29, 5 August 2022 (4.53 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/LCD-show-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/MCP2515-pdf.html","title":"File:MCP2515.pdf","text":""},{"location":"files/MCP2515-pdf.html#file","title":"File","text":"<p>MCP2515.pdf (file size: 1.04 MB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/MCP2515-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 02:21, 24 August 2019 (1.04 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/MCP2515-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/MPXV7002-pdf.html","title":"File:MPXV7002.pdf","text":""},{"location":"files/MPXV7002-pdf.html#file","title":"File","text":"<p>MPXV7002.pdf (file size: 177 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/MPXV7002-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 08:17, 23 August 2019 (177 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/MPXV7002-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/MQ-2-pdf.html","title":"File:MQ-2.pdf","text":""},{"location":"files/MQ-2-pdf.html#file","title":"File","text":"<p>MQ-2.pdf (file size: 57 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/MQ-2-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:00, 23 August 2019 (57 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/MQ-2-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/MQ-9-pdf.html","title":"File:MQ-9.pdf","text":""},{"location":"files/MQ-9-pdf.html#file","title":"File","text":"<p>MQ-9.pdf (file size: 51 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/MQ-9-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 02:38, 24 August 2019 (51 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/MQ-9-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Mcp2551en-pdf.html","title":"File:Mcp2551en.pdf","text":""},{"location":"files/Mcp2551en-pdf.html#file","title":"File","text":"<p>Mcp2551en.pdf (file size: 344 KB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Mcp2551en-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 02:07, 24 August 2019 (344 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Mcp2551en-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Metal-Proximity-Sensor-zip.html","title":"File:Metal Proximity Sensor.zip","text":""},{"location":"files/Metal-Proximity-Sensor-zip.html#file","title":"File","text":"<p>Metal Proximity Sensor.zip (file size: 538 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Metal-Proximity-Sensor-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 06:46, 23 August 2019 (538 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Metal-Proximity-Sensor-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/NOEM-Host-zip.html","title":"File:NOEM Host.zip","text":""},{"location":"files/NOEM-Host-zip.html#file","title":"File","text":"<p>NOEM_Host.zip (file size: 1.48 MB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/NOEM-Host-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 10:23, 26 August 2022   (1.48 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/NOEM-Host-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Panstamp-zip.html","title":"File:Panstamp.zip","text":""},{"location":"files/Panstamp-zip.html#file","title":"File","text":"<p>Panstamp.zip (file size: 131 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Panstamp-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:17, 26 August 2019 (131 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Panstamp-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/RFM95-pdf.html","title":"File:RFM95.pdf","text":""},{"location":"files/RFM95-pdf.html#file","title":"File","text":"<p>RFM95.pdf (file size: 1.84 MB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/RFM95-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 11:08, 22 August 2019 (1.84 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/RFM95-pdf.html#file-usage","title":"File usage","text":"<p>The following file is a duplicate of this file (more details):</p> <ul> <li>File:RFM95~98 2.4G.pdf</li> </ul> <p>There are no pages that use this file.</p>"},{"location":"files/RFM95~98-2.4G-pdf.html","title":"File:RFM95~98 2.4G.pdf","text":""},{"location":"files/RFM95~98-2.4G-pdf.html#file","title":"File","text":"<p>RFM95~98_2.4G.pdf (file size: 1.84 MB, MIME type: application/pdf)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/RFM95~98-2.4G-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:37, 24 August 2019 (1.84 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/RFM95~98-2.4G-pdf.html#file-usage","title":"File usage","text":"<p>The following file is a duplicate of this file (more details):</p> <ul> <li>File:RFM95.pdf</li> </ul> <p>There are no pages that use this file.</p>"},{"location":"files/RadioHead-zip.html","title":"File:RadioHead.zip","text":""},{"location":"files/RadioHead-zip.html#file","title":"File","text":"<p>RadioHead.zip (file size: 375 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/RadioHead-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 09:07, 24 August 2019 (375 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/RadioHead-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Remote-Control-Source-Code-zip.html","title":"File:Remote Control Source Code.zip","text":""},{"location":"files/Remote-Control-Source-Code-zip.html#file","title":"File","text":"<p>Remote_Control_Source_Code.zip (file size: 912 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Remote-Control-Source-Code-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 09:30, 24 August 2019 (912 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Remote-Control-Source-Code-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Rf95-client-zip.html","title":"File:Rf95 client.zip","text":""},{"location":"files/Rf95-client-zip.html#file","title":"File","text":"<p>Rf95_client.zip (file size: 2 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Rf95-client-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 06:59, 24 August 2019 (2 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Rf95-client-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Rf95-server-zip.html","title":"File:Rf95 server.zip","text":""},{"location":"files/Rf95-server-zip.html#file","title":"File","text":"<p>Rf95_server.zip (file size: 2 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Rf95-server-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 11:22, 22 August 2019 (2 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Rf95-server-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/SSD1306-zip-zip.html","title":"File:SSD1306.zip.zip","text":""},{"location":"files/SSD1306-zip-zip.html#file","title":"File","text":"<p>SSD1306.zip.zip (file size: 8 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/SSD1306-zip-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:51, 24 August 2019 (8 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/SSD1306-zip-zip.html#file-usage","title":"File usage","text":"<p>The following file is a duplicate of this file (more details):</p> <ul> <li>File:SSD1306.zip </li> </ul> <p>There are no pages that use this file.</p>"},{"location":"files/SSD1306-zip.html","title":"File:SSD1306.zip","text":""},{"location":"files/SSD1306-zip.html#file","title":"File","text":"<p>SSD1306.zip (file size: 8 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/SSD1306-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 11:03, 22 August 2019 (8 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/SSD1306-zip.html#file-usage","title":"File usage","text":"<p>The following file is a duplicate of this file (more details):</p> <ul> <li>File:SSD1306.zip.zip </li> </ul> <p>There are no pages that use this file.</p>"},{"location":"files/ST7789VW-datasheet-pdf.html","title":"File:ST7789VW datasheet.pdf","text":""},{"location":"files/ST7789VW-datasheet-pdf.html#file","title":"File","text":"<p>ST7789VW datasheet.pdf (file size: 2.99 MB, MIME type: application/pdf)</p>"},{"location":"files/ST7789VW-datasheet-pdf.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 02:52, 22 June 2022 (2.99 MB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/ST7789VW-datasheet-pdf.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Serial-Camera-software-zip.html","title":"File:Serial Camera software.zip","text":""},{"location":"files/Serial-Camera-software-zip.html#file","title":"File","text":"<p>Serial_Camera_software.zip (file size: 901 bytes, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Serial-Camera-software-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 09:58, 23 August 2019 (901 bytes) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Serial-Camera-software-zip.html#file-usage","title":"File usage","text":"<p>The following file is a duplicate of this file (more details):</p> <ul> <li>File:Analog Gyro 2 Axis.zip</li> </ul> <p>The following page uses this file:</p> <ul> <li>Serial JPG Camera</li> </ul>"},{"location":"files/SerialCameral-DemoCode-zip.html","title":"File:SerialCameral DemoCode.zip","text":""},{"location":"files/SerialCameral-DemoCode-zip.html#file","title":"File","text":"<p>SerialCameral_DemoCode.zip (file size: 2 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/SerialCameral-DemoCode-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:52, 26 August 2019 (2 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/SerialCameral-DemoCode-zip.html#file-usage","title":"File usage","text":"<p>The following page uses this file:</p> <ul> <li>Serial JPG Camera</li> </ul>"},{"location":"files/SoftwareSerial-zip.html","title":"File:SoftwareSerial.zip","text":""},{"location":"files/SoftwareSerial-zip.html#file","title":"File","text":"<p>SoftwareSerial.zip (file size: 8 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/SoftwareSerial-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:10, 26 August 2019 (8 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/SoftwareSerial-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Sscom1-zip.html","title":"File:Sscom1.zip","text":""},{"location":"files/Sscom1-zip.html#file","title":"File","text":"<p>Sscom1.zip (file size: 410 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Sscom1-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 06:04, 18 January 2023  (410 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Sscom1-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/TFT-ILI9163C-library-zip.html","title":"File:TFT ILI9163C library.zip","text":""},{"location":"files/TFT-ILI9163C-library-zip.html#file","title":"File","text":"<p>TFT_ILI9163C_library.zip (file size: 329 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/TFT-ILI9163C-library-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 04:23, 23 August 2019 (329 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/TFT-ILI9163C-library-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Touch-Shield-Example-zip.html","title":"File:Touch Shield Example.zip","text":""},{"location":"files/Touch-Shield-Example-zip.html#file","title":"File","text":"<p>Touch_Shield_Example.zip (file size: 7 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Touch-Shield-Example-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 09:37, 24 August 2019 (7 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Touch-Shield-Example-zip.html#file-usage","title":"File usage","text":"<p>There are no pages that use this file.</p>"},{"location":"files/Virtualwire-zip.html","title":"File:Virtualwire.zip","text":""},{"location":"files/Virtualwire-zip.html#file","title":"File","text":"<p>Virtualwire.zip (file size: 248 KB, MIME type: application/zip)</p> <p>Warning: This file type may contain malicious code. By executing it, your system may be compromised.</p>"},{"location":"files/Virtualwire-zip.html#file-history","title":"File history","text":"<p>Click on a date/time to view the file as it appeared at that time.</p> Date/Time Dimensions User Comment current 03:43, 24 August 2019 (248 KB) Admin (talk | contribs) <ul> <li>You cannot overwrite this file.</li> </ul>"},{"location":"files/Virtualwire-zip.html#file-usage","title":"File usage","text":"<p>The following page uses this file:</p> <ul> <li>315/433Mhz RF Link Kit</li> </ul>"},{"location":"how/how-to-install-the-librarys-and-upload-programs-to-arduino.html","title":"How to install the librarys and upload programs to Arduino","text":""},{"location":"how/how-to-install-the-librarys-and-upload-programs-to-arduino.html#how-to-install-elecrow-library-to-your-computer","title":"How to install elecrow library to your computer","text":"<p>Download the libraries and unzip them , intall library in your computer: On your Mac: In (home directory)/Documents/Arduino/libraries On your PC: ...\\arduino\\libraries On your Linux box: (home directory)/sketchbook/libraries  </p>"},{"location":"how/how-to-install-the-librarys-and-upload-programs-to-arduino.html#the-specific-steps-for-uploading-the-code","title":"The specific steps for uploading the code","text":"<p>1. Open the demo code in library by path: Files-&gt;Examples:  2. Selet the right Arduino board you are using and the Serial Port the board using by the path: Tools -- Board-- you can also get the Serial port using in the computer hardware management.  3. Select the correct serial port you are using by the path: Tools -&gt; Serial Port  4. Upload the demo code as below show: </p> <p>When there appears \"Done uploading\", congratulate you upload successfully.</p>"}]}